//! Hermes runtime extensions

use wasmtime::{
    component::{Component, Linker},
    Config, Engine, Store,
};

use self::bindings::{
    exports::hermes::cardano::event_on_block::BlockSrc,
    hermes::{
        cardano::api::{CardanoBlock, CardanoBlockchainId, CardanoTxn},
        cron::api::CronTagged,
    },
};
use crate::state::HermesState;

pub(crate) mod bindings;
pub(crate) mod hermes;
pub(crate) mod state;
pub(crate) mod wasi;

/// Example of how to call the autogenerated entry points
#[allow(dead_code)]
fn example() -> anyhow::Result<()> {
    use crate::runtime_extensions::state::{Context, Stateful};

    // Configure an `Engine` and compile the `Component` that is being run for
    // the application.
    let mut config = Config::new();
    config.wasm_component_model(true);
    let engine = Engine::new(&config)?;
    let component = Component::from_file(&engine, "./your-component.wasm")?;

    // Instantiation of bindings always happens through a `Linker`.
    //
    // Note that the closure provided here is a projection from `T` in
    // `Store<T>` to `&mut U` where `U` implements the `HelloWorldImports`
    // trait. In this case the `T`, `MyState`, is stored directly in the
    // structure so no projection is necessary here.
    let mut linker = Linker::new(&engine);
    bindings::Hermes::add_to_linker(&mut linker, |state: &mut HermesState| state)?;

    let instance_pre = linker.instantiate_pre(&component)?;

    // As with the core wasm API of Wasmtime instantiation occurs within a
    // `Store`. The bindings structure contains an `instantiate` method which
    // takes the store, component, and linker. This returns the `bindings`
    // structure which is an instance of `HelloWorld` and supports typed access
    // to the exports of the component.
    let mut store = Store::new(
        &engine,
        HermesState::new(&Context::new("my-app".to_string())),
    );

    //
    let (bindings, _) = bindings::Hermes::instantiate_pre(&mut store, &instance_pre)?;

    // Show how we call the events in our API.
    let _result = bindings.hermes_init_event().call_init(&mut store)?;

    // HTTP API to be rewritten, but this is how its called.
    // let arg1 = ??;
    // let arg2 = ??;
    // let result = bindings.interface0.call_handle(&mut store, arg1, arg2)?;

    // Example of calling on_block.
    let arg0 = CardanoBlockchainId::Mainnet;
    let arg1 = CardanoBlock::new();
    let arg2 = BlockSrc::TIP;
    bindings
        .hermes_cardano_event_on_block()
        .call_on_cardano_block(&mut store, arg0, &arg1, arg2)?;

    // Example of calling on_txn.
    let arg0 = CardanoBlockchainId::Mainnet;
    let arg1: u64 = 123_456;
    let arg2: u32 = 12;
    let arg3 = CardanoTxn::new();

    bindings
        .hermes_cardano_event_on_txn()
        .call_on_cardano_txn(&mut store, arg0, arg1, arg2, &arg3)?;

    // Example of calling on_rollback.
    let arg0 = CardanoBlockchainId::Mainnet;
    let arg1: u64 = 123_456;
    bindings
        .hermes_cardano_event_on_rollback()
        .call_on_cardano_rollback(&mut store, arg0, arg1)?;

    // Example of calling on_cron.
    let arg0 = CronTagged {
        when: "* * * * *".to_string(),
        tag: "tag".to_string(),
    };
    let arg1 = false;
    let _result = bindings
        .hermes_cron_event()
        .call_on_cron(&mut store, &arg0, arg1)?;

    // Example of calling kv_update
    let arg0 = "key";
    let arg1 = bindings::hermes::kv_store::api::KvValues::KvString("value".to_string());
    bindings
        .hermes_kv_store_event()
        .call_kv_update(&mut store, arg0, &arg1)?;

    Ok(())
}
