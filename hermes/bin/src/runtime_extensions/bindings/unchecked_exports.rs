//! Hermes WIT exports for event handlers.
//!
//! Unlike the functions of [`super::Hermes`] (generated by
//! [`wasmtime::component::bindgen`]), these aren't checked for presence in WASM until
//! use.

use wasmtime::{
    component::{self, ComponentNamedList, Resource, TypedFunc},
    AsContextMut,
};

use crate::{
    runtime_context::HermesRuntimeContext,
    runtime_extensions::bindings::exports::hermes::{
        cardano::{event_on_block::Block, event_on_immutable_roll_forward::SubscriptionId},
        cron::event::CronTagged,
        http_gateway::event::HttpGatewayResponse,
        integration_test::event::TestResult,
        ipfs::event::PubsubMessage,
        kv_store::event::KvValues,
    },
};

/// WASM function lookup failure.
#[derive(Debug, thiserror::Error)]
pub enum Error {
    /// A WIT interface and/or function is missing from WASM exports.
    #[error("event handler is not exported")]
    NotExported,
    /// An export is found but its signature doesn't match the one defined in WIT.
    #[error("invalid event handler signature")]
    InvalidSignature,
}

/// Lookup a function in WASM by its path and signature.
fn get_typed_func<Params, Return>(
    instance: &component::Instance,
    store: &mut wasmtime::Store<HermesRuntimeContext>,
    wit_interface_name: &str,
    wit_func_name: &str,
) -> Result<TypedFunc<Params, Return>, Error>
where
    Params: ComponentNamedList + component::Lower,
    Return: ComponentNamedList + component::Lift,
{
    let Some(untyped) = instance
        .get_export_index(store.as_context_mut(), None, wit_interface_name)
        .and_then(|interface_idx| {
            instance.get_export_index(store.as_context_mut(), Some(&interface_idx), wit_func_name)
        })
        .and_then(|func_idx| instance.get_func(store.as_context_mut(), func_idx))
    else {
        return Err(Error::NotExported);
    };
    untyped.typed(store).map_err(|_| Error::InvalidSignature)
}

/// Defines an extension trait for [`wasmtime::component::Instance`] and immediately
/// implements it. Uses [`get_typed_func`] internally.
macro_rules! define_exports {
    ($(#[$attr:meta])* $vis:vis trait $ext_trait:ident {$(
        #[wit($wit_interface:literal, $wit_func:literal)]
        fn $rust_func:ident$(<$l:lifetime>)?($($param_name:ident: $param:ty),* $(,)?) $(-> $return:ty)?;
    )*}) => {
        #[allow(dead_code)]
        $vis trait $ext_trait {$(
            #[doc = concat!('"', $wit_func , "\" from \"", $wit_interface, "\"\n\n# Params\n")]
            #[doc = concat!($("\n- ", stringify!($param_name), ": ", stringify!($param)),*)]
            fn $rust_func$(<$l>)?(
                self,
                store: &mut ::wasmtime::Store<$crate::runtime_context::HermesRuntimeContext>
            ) -> Result<::wasmtime::component::TypedFunc<($($param,)*), ($($return,)?)>, Error>;
        )*}

        impl $ext_trait for &::wasmtime::component::Instance {$(
            fn $rust_func$(<$l>)?(
                self,
                store: &mut ::wasmtime::Store<$crate::runtime_context::HermesRuntimeContext>
            ) -> Result<::wasmtime::component::TypedFunc<($($param,)*), ($($return,)?)>, Error> {
                get_typed_func(self, store, $wit_interface, $wit_func)
            }
        )*}
    };
}

define_exports! {
    /// Extends [`wasmtime::component::Instance`] with guest accessors
    /// similar to the ones generated for [`super::Hermes`] by [`wasmtime::component::bindgen`].
    pub trait ComponentInstanceExt {
        #[wit("hermes:cardano/event-on-block", "on-cardano-block")]
        fn hermes_cardano_event_on_block_on_cardano_block(
            subscription_id: Resource<SubscriptionId>, block_id: Resource<Block>,
        );

        #[wit("hermes:cardano/event-on-immutable-roll-forward", "on-immutable-roll-forward")]
        fn hermes_cardano_event_on_immutable_roll_forward_on_cardano_immutable_roll_forward(
            subscription_id: Resource<SubscriptionId>, block_id: Resource<Block>,
        );

        #[wit("hermes:cron/event", "on-cron")]
        fn hermes_cron_event_on_cron<'p>(
            event: &'p CronTagged, last: bool,
        ) -> bool;

        #[wit("hermes:init/event", "init")]
        fn hermes_init_event_init() -> bool;

        #[wit("hermes:ipfs/event", "on-topic")]
        fn hermes_ipfs_event_on_topic<'p>(message: &'p PubsubMessage) -> bool;

        #[wit("hermes:kv-store/event", "kv-update")]
        fn hermes_kv_store_event_kv_update<'p>(key: &'p str, value: &'p KvValues);

        #[wit("hermes:integration-test/event", "test")]
        fn hermes_integration_test_event_test(test: u32, run: bool) -> Option<TestResult>;

        #[wit("hermes:integration-test/event", "bench")]
        fn hermes_integration_test_event_bench(test: u32, run: bool) -> Option<TestResult>;

        #[wit("hermes:http-gateway/event", "reply")]
        fn hermes_http_gateway_event_reply<'p> (
            body: &'p [u8],
            headers: &'p [(String, Vec<String>)],
            path: &'p str,
            method: &'p str,
        ) -> Option<HttpGatewayResponse>;

        #[wit("hermes:http-request/event", "on-http-response")]
        fn hermes_http_request_event_on_http_response<'p>(request_id: Option<u64>, response: &'p [u8]);
    }
}
