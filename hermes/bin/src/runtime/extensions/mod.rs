//! Hermes runtime extensions
//!
//! *Note*
//! Inspect the generated code with:
//! ```
//! cargo expand --bin hermes runtime::extensions
//! ```
#![allow(clippy::indexing_slicing)]

use wasmtime::{
    component::{bindgen, Component, Linker},
    Config, Engine, Store,
};

use self::{
    exports::hermes::cardano::event_on_block::BlockSrc,
    hermes::{
        cardano::api::{CardanoBlock, CardanoBlockchainId, CardanoTxn},
        cron::api::CronTagged,
    },
};
use crate::{runtime, wasm::context::Context};

bindgen!({
    world: "hermes",
    path: "../../wasm/wasi/wit",
});

/// All Hermes runtime extensions states need to implement this.
pub(crate) trait Stateful {
    /// Initial state for the given context
    fn new(ctx: &Context) -> Self;
}

#[allow(dead_code)]
/// State for Hermes runtime
pub(crate) struct HermesState {
    /// Hermes custom extensions state
    pub hermes: runtime::host::hermes::State,

    /// WASI standard extensions state
    pub wasi: runtime::host::wasi::State,

    /// The context of the wasm modules using this State.
    pub ctx: Context,
}

impl Stateful for HermesState {
    fn new(ctx: &Context) -> HermesState {
        HermesState {
            hermes: runtime::host::hermes::State::new(ctx),
            wasi: runtime::host::wasi::State::new(ctx),
            ctx: ctx.clone(),
        }
    }
}

#[allow(dead_code)]
/// Link a component to the Hermes runtime.
pub(crate) fn link_runtime(engine: &Engine) -> anyhow::Result<Linker<HermesState>> {
    let mut linker = Linker::new(engine);
    Hermes::add_to_linker(&mut linker, |state: &mut HermesState| state)?;

    Ok(linker)
}

/// Example of how to call the autogenerated entry points
#[allow(dead_code)]
fn example() -> anyhow::Result<()> {
    // Configure an `Engine` and compile the `Component` that is being run for
    // the application.
    let mut config = Config::new();
    config.wasm_component_model(true);
    let engine = Engine::new(&config)?;
    let component = Component::from_file(&engine, "./your-component.wasm")?;

    // Instantiation of bindings always happens through a `Linker`.
    // Configuration of the linker is done through a generated `add_to_linker`
    // method on the bindings structure.
    //
    // Note that the closure provided here is a projection from `T` in
    // `Store<T>` to `&mut U` where `U` implements the `HelloWorldImports`
    // trait. In this case the `T`, `MyState`, is stored directly in the
    // structure so no projection is necessary here.
    let linker = link_runtime(&engine)?;
    let instance_pre = linker.instantiate_pre(&component)?;

    // As with the core wasm API of Wasmtime instantiation occurs within a
    // `Store`. The bindings structure contains an `instantiate` method which
    // takes the store, component, and linker. This returns the `bindings`
    // structure which is an instance of `HelloWorld` and supports typed access
    // to the exports of the component.
    let mut store = Store::new(
        &engine,
        HermesState::new(&Context::new("my-app".to_string())),
    );

    //
    let (bindings, _) = Hermes::instantiate_pre(&mut store, &instance_pre)?;

    // Show how we call the events in our API.
    let _result = bindings.interface5.call_init(&mut store)?;

    // HTTP API to be rewritten, but this is how its called.
    // let arg1 = ??;
    // let arg2 = ??;
    // let result = bindings.interface0.call_handle(&mut store, arg1, arg2)?;

    // Example of calling on_block.
    let arg0 = CardanoBlockchainId::Mainnet;
    let arg1 = CardanoBlock::new();
    let arg2 = BlockSrc::TIP;
    bindings
        .hermes_cardano_event_on_block()
        .call_on_cardano_block(&mut store, arg0, &arg1, arg2)?;

    // Example of calling on_txn.
    let arg0 = CardanoBlockchainId::Mainnet;
    let arg1: u64 = 123_456;
    let arg2: u32 = 12;
    let arg3 = CardanoTxn::new();

    bindings
        .hermes_cardano_event_on_txn()
        .call_on_cardano_txn(&mut store, arg0, arg1, arg2, &arg3)?;

    // Example of calling on_rollback.
    let arg0 = CardanoBlockchainId::Mainnet;
    let arg1: u64 = 123_456;
    bindings
        .hermes_cardano_event_on_rollback()
        .call_on_cardano_rollback(&mut store, arg0, arg1)?;

    // Example of calling on_cron.
    let arg0 = CronTagged {
        when: "* * * * *".to_string(),
        tag: "tag".to_string(),
    };
    let arg1 = false;
    let _result = bindings.interface4.call_on_cron(&mut store, &arg0, arg1)?;

    // Example of calling kv_update
    let arg0 = "key";
    let arg1 = hermes::kv_store::api::KvValues::KvString("value".to_string());
    bindings
        .interface6
        .call_kv_update(&mut store, arg0, &arg1)?;

    Ok(())
}
