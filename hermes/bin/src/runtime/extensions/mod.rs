//! Hermes runtime extensions
//!
#![allow(clippy::indexing_slicing)]

use wasmtime::{
    component::{Component, Linker},
    Config, Engine, Store,
};

use self::{
    bindings::{
        hermes::{
            cardano::api::{CardanoBlockchainId, CardanoTxn},
            cron::api::CronTagged,
            kv_store::api::KvValues,
        },
        Hermes,
    },
    event::{HermesEvent, HermesEventPayload},
};
use super::host::hermes::cardano::on_block::CardanoOnBlockEventPayload;
use crate::{runtime, wasm::context::Context};
pub(crate) mod event;

pub(crate) mod bindings;

/// All Hermes runtime extensions states need to implement this.
pub(crate) trait Stateful {
    /// Initial state for the given context
    fn new(ctx: &Context) -> Self;
}

#[allow(dead_code)]
/// State for Hermes runtime
pub(crate) struct HermesState {
    /// Hermes custom extensions state
    pub hermes: runtime::host::hermes::State,

    /// WASI standard extensions state
    pub wasi: runtime::host::wasi::State,

    /// The context of the wasm modules using this State.
    pub ctx: Context,
}

impl Stateful for HermesState {
    fn new(ctx: &Context) -> HermesState {
        HermesState {
            hermes: runtime::host::hermes::State::new(ctx),
            wasi: runtime::host::wasi::State::new(ctx),
            ctx: ctx.clone(),
        }
    }
}

#[allow(dead_code)]
/// Link a component to the Hermes runtime.
pub(crate) fn link_runtime(engine: &Engine) -> anyhow::Result<Linker<HermesState>> {
    let mut linker = Linker::new(engine);
    Hermes::add_to_linker(&mut linker, |state: &mut HermesState| state)?;

    Ok(linker)
}

/// Example of how to call the autogenerated entry points
#[allow(dead_code)]
fn example() -> anyhow::Result<()> {
    // Configure an `Engine` and compile the `Component` that is being run for
    // the application.
    let mut config = Config::new();
    config.wasm_component_model(true);
    let engine = Engine::new(&config)?;
    let component = Component::from_file(&engine, "./your-component.wasm")?;

    // Instantiation of bindings always happens through a `Linker`.
    // Configuration of the linker is done through a generated `add_to_linker`
    // method on the bindings structure.
    //
    // Note that the closure provided here is a projection from `T` in
    // `Store<T>` to `&mut U` where `U` implements the `HelloWorldImports`
    // trait. In this case the `T`, `MyState`, is stored directly in the
    // structure so no projection is necessary here.
    let linker = link_runtime(&engine)?;
    let instance_pre = linker.instantiate_pre(&component)?;

    // As with the core wasm API of Wasmtime instantiation occurs within a
    // `Store`. The bindings structure contains an `instantiate` method which
    // takes the store, component, and linker. This returns the `bindings`
    // structure which is an instance of `HelloWorld` and supports typed access
    // to the exports of the component.
    let mut store = Store::new(
        &engine,
        HermesState::new(&Context::new("my-app".to_string())),
    );

    //
    let (bindings, _) = Hermes::instantiate_pre(&mut store, &instance_pre)?;

    // Show how we call the events in our API.
    let _result = bindings.hermes_init_event().call_init(&mut store)?;

    // HTTP API to be rewritten, but this is how its called.
    // let arg1 = ??;
    // let arg2 = ??;
    // let result = bindings.interface0.call_handle(&mut store, arg1, arg2)?;

    // Example of calling on_block.

    // This event is sent over the event queue.
    let event = HermesEvent::new(
        CardanoOnBlockEventPayload {
            mainnet: true,
            block_data: vec![],
            at_tip: true,
            mithril: true,
        },
        true,
    );

    // A wasm module checks if it implements the event or not, if it does, it executes it.
    // Repeat this for all wasm modules
    if event.payload().event_name() == "on-block"
    // AND the Wasm supports that event
    {
        event.payload().execute(&bindings, &mut store)?;
    }

    // When all wasm modules have executed the event...
    event.notify()?;

    // Example of calling on_txn.
    let arg0 = CardanoBlockchainId::Mainnet;
    let arg1: u64 = 123_456;
    let arg2: u32 = 12;
    let arg3 = CardanoTxn::new();

    bindings
        .hermes_cardano_event_on_txn()
        .call_on_cardano_txn(&mut store, arg0, arg1, arg2, &arg3)?;

    // Example of calling on_rollback.
    let arg0 = CardanoBlockchainId::Mainnet;
    let arg1: u64 = 123_456;
    bindings
        .hermes_cardano_event_on_rollback()
        .call_on_cardano_rollback(&mut store, arg0, arg1)?;

    // Example of calling on_cron.
    let arg0 = CronTagged {
        when: "* * * * *".to_string(),
        tag: "tag".to_string(),
    };
    let arg1 = false;
    let _result = bindings
        .hermes_cron_event()
        .call_on_cron(&mut store, &arg0, arg1)?;

    // Example of calling kv_update
    let arg0 = "key";
    let arg1 = KvValues::KvString("value".to_string());
    bindings
        .hermes_kv_store_event()
        .call_kv_update(&mut store, arg0, &arg1)?;

    Ok(())
}
