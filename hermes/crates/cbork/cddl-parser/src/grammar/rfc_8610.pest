//! CDDL Grammar adapted from RFC8610 Appendix B
//! https://www.rfc-editor.org/rfc/rfc8610#appendix-B

// cspell: words assignt groupname grpent genericparm assigng
// cspell: words genericarg rangeop ctlop grpchoice memberkey bareword hexfloat intfloat
// cspell: words SCHAR BCHAR PCHAR SESC FFFD Characterset Visiable

cddl = ${
    SOI
    ~ S ~ (rule ~ S)+
    ~ EOI
}

// -----------------------------------------------------------------------------
// Rules
rule = ${
    (typename ~ S ~ assignt ~ S ~ type)
    | (groupname ~ S ~ assigng ~ S ~ grpent)
}

typename = { id }
groupname = { id }

assignt = { "=" | "/=" }
assigng = { "=" | "//=" }

genericparm = ${ "<" ~ S ~ id ~ S ~ ("," ~ S ~ id ~ S)* ~ ">" }
genericarg = ${ "<" ~ S ~ type1 ~ S ~ ("," ~ S ~ type1 ~ S)* ~ ">" }

// -----------------------------------------------------------------------------
// Type Declaration
type = ${ type1 ~ (S ~ "/" ~ S ~ type1)* }

type1 = ${ type2 ~ (S ~ (rangeop | ctlop) ~ S ~ type2)? }

type2 = ${
    value
    | typename ~ genericarg?
    | ("(" ~ S ~ type ~ S ~ ")")
    | ("{" ~ S ~ group ~ S ~ "}")
    | ("[" ~ S ~ group ~ S ~ "]")
    | ("~" ~ S ~ typename ~ genericarg?)
    | ("&" ~ S ~ "(" ~ S ~ group ~ S ~ ")")
    | ("&" ~ S ~ groupname ~ genericarg?)
    | ("#" ~ "6" ~ ("." ~ uint)? ~ "(" ~ S ~ type ~ S ~ ")")
    | ("#" ~ ASCII_DIGIT ~ ("." ~ uint)?)
    | "#"
}

rangeop = { "..." | ".." }
ctlop = ${ "." ~ id }

// -----------------------------------------------------------------------------
// Group Elements
group = ${ grpchoice ~ (S ~ "//" ~ S ~ grpchoice)* }

grpchoice = ${ (grpent ~ optcom)* }

grpent = ${
    ((occur ~ S)? ~ (memberkey ~ S)? ~ type)
    | ((occur ~ S)? ~ groupname ~ genericarg?)
    | ((occur ~ S)? ~ "(" ~ S ~ group ~ S ~ ")")
}

memberkey = ${
    (type1 ~ S ~ ("^" ~ S)? ~ "=>")
    | ((value | bareword) ~ S ~ ":")
}

bareword = { id }

/// Optional Comma - Note eligible for producing pairs as this might be useful for linting
optcom = { S ~ ("," ~ S)? }

occur = {
    (uint? ~ "*" ~ uint?)
    | "+"
    | "?"
}

// -----------------------------------------------------------------------------
// Literal Values

/// All Literal Values
value = { number | text | bytes }

/// Literal Numbers - A float if it has fraction or exponent; int otherwise
number = { hexfloat | intfloat }

/// Hex floats of the form -0x123.abc0p+12
hexfloat = ${ "-"? ~ "0x" ~ ASCII_HEX_DIGIT+ ~ ("." ~ ASCII_HEX_DIGIT+)? ~ "p" ~ exponent }

/// Ints or Int floats
intfloat = ${ int ~ ("." ~ fraction)? ~ ("e" ~ exponent)? }

/// Fractional part of a number
fraction = ${ ASCII_DIGIT+ }

/// Exponent for a number
exponent = ${ ("+" | "-") ~ ASCII_DIGIT+ }

/// All integers, singed and unsigned
int = ${ "-"? ~ uint }


/// Unsigned Integers
uint = ${
    (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
    | ("0x" ~ ASCII_HEX_DIGIT+)
    | ("0b" ~ ASCII_BIN_DIGIT+)
    | "0"
}

/// Literal Text
text = ${ "\"" ~ SCHAR* ~ "\"" }

/// Literal Bytes.
bytes = ${ bsqual? ~ "'" ~ BCHAR* ~ "'" }
bsqual = { "h" | "b64" }

// -----------------------------------------------------------------------------
// Simple multiple character sequences

/// identifier, called the `name` in the CDDL spec.
id = ${ NAME_START ~ (("-" | ".")* ~ NAME_END)* }


// -----------------------------------------------------------------------------
// Characters, Whitespace and Comments

S = _{ WHITESPACE* }
WHITESPACE = _{ " " | "\t" | COMMENT | NEWLINE }
COMMENT = _{ ";" ~ (PCHAR | "\t")* ~ NEWLINE }

// Identifier Name Character sets.

/// A name can start with an alphabetic character (including "@", "_", "$")
/// The body of the name can consist of any of the characters from the set
///   {"A" to "Z", "a" to "z", "0" to "9", "_", "-", "@", ".", "$"}
// NAME_BODY = _{ NAME_END | "-" | "." }  -- Unused Rule
NAME_START = _{ ASCII_ALPHA | "@" | "_" | "$" }
/// A name can end with an alphabetic character (including "@", "_", "$") or a digit.
NAME_END = _{ NAME_START | ASCII_DIGIT }

/// All Visible characters.
PCHAR = _{ ASCII_VISIBLE | UNICODE_CHAR }

/// The set of characters valid for a text string.
SCHAR = _{ SCHAR_ASCII_VISIBLE | UNICODE_CHAR | SESC }

/// The set of characters valid for a byte string.
BCHAR = _{ '\u{20}'..'\u{26}' | '\u{28}'..'\u{5B}' | '\u{5D}'..'\u{10FFFD}' | SESC | NEWLINE }

/// Escaping code to allow invalid characters to be used in text or byte strings.
SESC = ${ "\\" ~ (ASCII_VISIBLE | UNICODE_CHAR) }

/// All Visible Ascii characters.
ASCII_VISIBLE = _{ ' '..'~' }

/// Ascii subset valid for text strings.
SCHAR_ASCII_VISIBLE = _{ ' '..'!' | '#'..'[' | ']'..'~' }

/// Ascii subset valid for byte text strings.
BCHAR_ASCII_VISIBLE = _{ ' '..'&' | '('..'[' | ']'..'~' }

/// Valid non ascii unicode Characters
UNICODE_CHAR = _{ '\u{80}'..'\u{10FFFD}' }