VERSION 0.7

#cspell: words rustup readelf nextest testci testdocs rustfmt toolsets USERARCH

rust-base-tmp:
    ARG TARGETPLATFORM
    ARG TARGETOS
    ARG TARGETARCH
    ARG TARGETVARIANT
    ARG USERPLATFORM
    ARG USEROS
    ARG USERARCH
    ARG USERVARIANT

    # This is our base Host toolset, and rustup.
    # The ACTUAL version of rust that will be used, and available targets
    # is controlled by a `rust-toolchain.toml` file when the `SETUP` UDC is run.
    # HOWEVER, It is enforced that the rust version in `rust-toolchain.toml` MUST match this version.
    FROM rust:1.73-alpine3.18

    RUN echo "TARGETPLATFORM = $TARGETPLATFORM"; \
        echo "TARGETOS       = $TARGETOS"; \
        echo "TARGETARCH     = $TARGETARCH"; \
        echo "TARGETVARIANT  = $TARGETVARIANT"; \
        echo "USERPLATFORM   = $USERPLATFORM"; \
        echo "USEROS         = $USEROS"; \
        echo "USERARCH       = $USERARCH"; \
        echo "USERVARIANT    = $USERVARIANT"; 

    WORKDIR /root

    # Install necessary packages 
    # Expand this list as needed, rather than adding more tools in later containers.
     RUN apk add --no-cache \
            musl-dev \
            mold \
            clang \
            ripgrep \
            bash \
            colordiff \
            graphviz

    # Make sure we have the clippy linter.
    RUN rustup component add clippy

    # Install a nightly toolchain which matches.
    RUN rustup toolchain install nightly --component miri --component rust-src --component rustfmt --component clippy

    # Add a target for wasm.
    RUN rustup target add wasm32-unknown-unknown --toolchain nightly

    COPY --dir .cargo .config Cargo.* clippy.toml deny.toml rustfmt.toml bin crates .

    RUN cargo build -p wasi-component-adapter --target wasm32-unknown-unknown --release

builder-tmp:
    BUILD +rust-base-tmp

# Fork the repo `wasmtime` and extract only the `wasi-preview1-component-adapter` crate from it.
fork-wasi-component-adapter:
    LOCALLY

    # The location the Earthfile for the local `wasi` crate.
    ARG wasi_earthfile=crates/wasi-component-adapter/Earthfile
    # The location to store the Earthfile during running the script.
    ARG wasi_tmp_earthfile=crates/Earthfile-tmp
    ARG wit_local_dir=crates/wasi/wit
    # The local directory to place the extracted `wasi` crate.
    ARG wasi_local_dir=crates/wasi-component-adapter
    # The location after the `wasmtime` repo was cloned.
    ARG wasi_git_dir=wasmtime/crates/wasi-preview1-component-adapter

    # First, it needs to move the existing Earthfile to the temporary location.
    # Then remove the existing local one. Clone and extract it from the repo.
    # And finally move the Earthfile back.
    RUN if [ -e $wasi_earthfile ]; then mv $wasi_earthfile $wasi_tmp_earthfile; fi && \
        rm -rf $wasi_local_dir/ || true && \
        rm -rf $wit_local_dir/ || true && \
        git clone --depth 1 https://github.com/bytecodealliance/wasmtime.git && \
        mv $wasi_git_dir $wasi_local_dir && \
        mkdir crates/wasi && \
        mv wasmtime/crates/wasi/wit crates/wasi/wit && \
        rm -rf wasmtime/ && \
        if [ -e $wasi_tmp_earthfile ]; then mv $wasi_tmp_earthfile $wasi_earthfile; fi

# Set up our target toolchains, and copy our files.
builder:
    FROM github.com/input-output-hk/catalyst-ci/earthly/rust:v2.0.3+rust-base

    DO github.com/input-output-hk/catalyst-ci/earthly/rust:v2.0.3+SETUP --toolchain=rust-toolchain.toml

    COPY --dir .cargo .config Cargo.* clippy.toml deny.toml rustfmt.toml bin crates .

# Test rust build container - Use best architecture host tools.
check-hosted:
    FROM +builder

    DO github.com/input-output-hk/catalyst-ci/earthly/rust:v2.0.3+CHECK

# Test which runs check with all supported host tooling.  Needs qemu or rosetta to run.
# Only used to validate tooling is working across host toolsets.
check-all-hosts:    
    BUILD --platform=linux/amd64 --platform=linux/arm64 +check-hosted

build-hosted:
    ARG TARGETPLATFORM

    # Build the service
    FROM +builder
 
    RUN /scripts/std_build.sh

    DO github.com/input-output-hk/catalyst-ci/earthly/rust:v2.0.3+SMOKE_TEST --bin=hermes

    SAVE ARTIFACT target/$TARGETARCH/doc doc
    SAVE ARTIFACT target/$TARGETARCH/release/hermes hermes

# Test which runs check with all supported host tooling.  Needs qemu or rosetta to run.
# Only used to validate tooling is working across host toolsets.
build-all-hosts:    
    BUILD --platform=linux/amd64 --platform=linux/arm64 +build-hosted

## -----------------------------------------------------------------------------
##
## Standard CI targets.
##
## These targets are discovered and executed automatically by CI.

# Run check using the most efficient host tooling
# CI Automated Entry point.
check:
    FROM busybox
    # This is necessary to pick the correct architecture build to suit the native machine.
    # It primarily ensures that Darwin/Arm builds work as expected without needing x86 emulation.
    # All target implementation of this should follow this pattern.
    ARG USERARCH

    IF [ "$USERARCH" == "arm64" ]
        BUILD --platform=linux/arm64 +check-hosted
    ELSE
        BUILD --platform=linux/amd64 +check-hosted
    END

# Run build using the most efficient host tooling
# CI Automated Entry point.
build:
    FROM busybox
    # This is necessary to pick the correct architecture build to suit the native machine.
    # It primarily ensures that Darwin/Arm builds work as expected without needing x86 emulation.
    # All target implementation of this should follow this pattern.
    ARG USERARCH

    IF [ "$USERARCH" == "arm64" ]
        BUILD --platform=linux/arm64 +build-hosted
    ELSE
        BUILD --platform=linux/amd64 +build-hosted
    END


# This step will build any packages we would intend to publish or integration test.
#package:
#    FROM scratch

# Run integration tests on all packages built during the `package` step.
#test:
#    FROM scratch

# Publish packages if all integration tests have passed. (Failure to pass tests will prevent packages being published.)
#publish:
#    FROM scratch

## -----------------------------------------------------------------------------

# This step simulates the full CI run for local purposes only.
local-ci-run:
    BUILD +check
    BUILD +build
    #BUILD +package
    #BUILD +integrate
    #BUILD +publish
