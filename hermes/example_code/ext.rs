// cSpell:disable
mod extensions {
    //! Runtime modules - extensions
    //!
    //! *Note*
    //! Inspect the generated code with:
    //! ```
    //! cargo expand --bin hermes runtime::extensions
    //! ```
    #![allow(clippy::indexing_slicing)]
    use wasmtime::component::bindgen;
    pub struct Hermes {
        interface0: exports::wasi::http::incoming_handler::IncomingHandler,
        interface1: exports::hermes::cardano::event_on_block::EventOnBlock,
        interface2: exports::hermes::cardano::event_on_txn::EventOnTxn,
        interface3: exports::hermes::cardano::event_on_rollback::EventOnRollback,
        interface4: exports::hermes::cron::event::Event,
    }
    const _: () = {
        use wasmtime::component::__internal::anyhow;
        impl Hermes {
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                U: wasi::cli::environment::Host + wasi::io::error::Host
                    + wasi::io::streams::Host + wasi::cli::stdin::Host
                    + wasi::cli::stdout::Host + wasi::cli::stderr::Host
                    + wasi::clocks::monotonic_clock::Host
                    + wasi::clocks::wall_clock::Host + wasi::filesystem::types::Host
                    + wasi::filesystem::preopens::Host + wasi::random::random::Host
                    + wasi::random::insecure::Host + wasi::random::insecure_seed::Host
                    + wasi::http::types::Host + wasi::http::outgoing_handler::Host
                    + hermes::binary::api::Host + hermes::cbor::api::Host
                    + hermes::cardano::api::Host + hermes::cron::api::Host
                    + hermes::crypto::api::Host + hermes::hash::api::Host
                    + hermes::init::event::Host + hermes::json::api::Host
                    + hermes::kv_store::api::Host + hermes::kv_store::event::Host
                    + hermes::localtime::api::Host + hermes::logging::api::Host,
            {
                wasi::cli::environment::add_to_linker(linker, get)?;
                wasi::io::error::add_to_linker(linker, get)?;
                wasi::io::streams::add_to_linker(linker, get)?;
                wasi::cli::stdin::add_to_linker(linker, get)?;
                wasi::cli::stdout::add_to_linker(linker, get)?;
                wasi::cli::stderr::add_to_linker(linker, get)?;
                wasi::clocks::monotonic_clock::add_to_linker(linker, get)?;
                wasi::clocks::wall_clock::add_to_linker(linker, get)?;
                wasi::filesystem::types::add_to_linker(linker, get)?;
                wasi::filesystem::preopens::add_to_linker(linker, get)?;
                wasi::random::random::add_to_linker(linker, get)?;
                wasi::random::insecure::add_to_linker(linker, get)?;
                wasi::random::insecure_seed::add_to_linker(linker, get)?;
                wasi::http::types::add_to_linker(linker, get)?;
                wasi::http::outgoing_handler::add_to_linker(linker, get)?;
                hermes::binary::api::add_to_linker(linker, get)?;
                hermes::cbor::api::add_to_linker(linker, get)?;
                hermes::cardano::api::add_to_linker(linker, get)?;
                hermes::cron::api::add_to_linker(linker, get)?;
                hermes::crypto::api::add_to_linker(linker, get)?;
                hermes::hash::api::add_to_linker(linker, get)?;
                hermes::init::event::add_to_linker(linker, get)?;
                hermes::json::api::add_to_linker(linker, get)?;
                hermes::kv_store::api::add_to_linker(linker, get)?;
                hermes::kv_store::event::add_to_linker(linker, get)?;
                hermes::localtime::api::add_to_linker(linker, get)?;
                hermes::logging::api::add_to_linker(linker, get)?;
                Ok(())
            }
            /// Instantiates the provided `module` using the specified
            /// parameters, wrapping up the result in a structure that
            /// translates between wasm and the host.
            pub fn instantiate<T>(
                mut store: impl wasmtime::AsContextMut<Data = T>,
                component: &wasmtime::component::Component,
                linker: &wasmtime::component::Linker<T>,
            ) -> wasmtime::Result<(Self, wasmtime::component::Instance)> {
                let instance = linker.instantiate(&mut store, component)?;
                Ok((Self::new(store, &instance)?, instance))
            }
            /// Instantiates a pre-instantiated module using the specified
            /// parameters, wrapping up the result in a structure that
            /// translates between wasm and the host.
            pub fn instantiate_pre<T>(
                mut store: impl wasmtime::AsContextMut<Data = T>,
                instance_pre: &wasmtime::component::InstancePre<T>,
            ) -> wasmtime::Result<(Self, wasmtime::component::Instance)> {
                let instance = instance_pre.instantiate(&mut store)?;
                Ok((Self::new(store, &instance)?, instance))
            }
            /// Low-level creation wrapper for wrapping up the exports
            /// of the `instance` provided in this structure of wasm
            /// exports.
            ///
            /// This function will extract exports from the `instance`
            /// defined within `store` and wrap them all up in the
            /// returned structure which can be used to interact with
            /// the wasm module.
            pub fn new(
                mut store: impl wasmtime::AsContextMut,
                instance: &wasmtime::component::Instance,
            ) -> wasmtime::Result<Self> {
                let mut store = store.as_context_mut();
                let mut exports = instance.exports(&mut store);
                let mut __exports = exports.root();
                let interface0 = exports::wasi::http::incoming_handler::IncomingHandler::new(
                    &mut __exports
                        .instance("wasi:http/incoming-handler@0.2.0")
                        .ok_or_else(|| ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!(
                                    "exported instance `wasi:http/incoming-handler@0.2.0` not present",
                                ),
                            );
                            error
                        }))?,
                )?;
                let interface1 = exports::hermes::cardano::event_on_block::EventOnBlock::new(
                    &mut __exports
                        .instance("hermes:cardano/event-on-block")
                        .ok_or_else(|| ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!(
                                    "exported instance `hermes:cardano/event-on-block` not present",
                                ),
                            );
                            error
                        }))?,
                )?;
                let interface2 = exports::hermes::cardano::event_on_txn::EventOnTxn::new(
                    &mut __exports
                        .instance("hermes:cardano/event-on-txn")
                        .ok_or_else(|| ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!(
                                    "exported instance `hermes:cardano/event-on-txn` not present",
                                ),
                            );
                            error
                        }))?,
                )?;
                let interface3 = exports::hermes::cardano::event_on_rollback::EventOnRollback::new(
                    &mut __exports
                        .instance("hermes:cardano/event-on-rollback")
                        .ok_or_else(|| ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!(
                                    "exported instance `hermes:cardano/event-on-rollback` not present",
                                ),
                            );
                            error
                        }))?,
                )?;
                let interface4 = exports::hermes::cron::event::Event::new(
                    &mut __exports
                        .instance("hermes:cron/event")
                        .ok_or_else(|| ::anyhow::__private::must_use({
                            let error = ::anyhow::__private::format_err(
                                format_args!(
                                    "exported instance `hermes:cron/event` not present",
                                ),
                            );
                            error
                        }))?,
                )?;
                Ok(Hermes {
                    interface0,
                    interface1,
                    interface2,
                    interface3,
                    interface4,
                })
            }
            pub fn wasi_http_incoming_handler(
                &self,
            ) -> &exports::wasi::http::incoming_handler::IncomingHandler {
                &self.interface0
            }
            pub fn hermes_cardano_event_on_block(
                &self,
            ) -> &exports::hermes::cardano::event_on_block::EventOnBlock {
                &self.interface1
            }
            pub fn hermes_cardano_event_on_txn(
                &self,
            ) -> &exports::hermes::cardano::event_on_txn::EventOnTxn {
                &self.interface2
            }
            pub fn hermes_cardano_event_on_rollback(
                &self,
            ) -> &exports::hermes::cardano::event_on_rollback::EventOnRollback {
                &self.interface3
            }
            pub fn hermes_cron_event(&self) -> &exports::hermes::cron::event::Event {
                &self.interface4
            }
        }
    };
    pub mod hermes {
        pub mod binary {
            #[allow(clippy::all)]
            pub mod api {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                /// Binary String (bstr) is a list of bytes.
                /// This type is used to indicate the data is an arbitrary array of bytes.
                pub type Bstr = Vec<u8>;
                const _: () = {
                    if !(8 == <Bstr as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Bstr as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Bstr as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Bstr as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// 256 bit value
                pub type B256 = (u64, u64, u64, u64);
                const _: () = {
                    if !(32 == <B256 as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 32 == <B256 as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <B256 as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <B256 as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {}
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:binary/api")?;
                    Ok(())
                }
            }
        }
        pub mod cardano {
            #[allow(clippy::all)]
            pub mod api {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Cbor = super::super::super::hermes::cbor::api::Cbor;
                const _: () = {
                    if !(8 == <Cbor as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Cbor as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Cbor as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Cbor as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Cardano Blocks are CBOR Data
                pub type CardanoBlock = Cbor;
                const _: () = {
                    if !(8
                        == <CardanoBlock as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <CardanoBlock as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4
                        == <CardanoBlock as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <CardanoBlock as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Cardano Transactions are CBOR Data
                pub type CardanoTxn = Cbor;
                const _: () = {
                    if !(8 == <CardanoTxn as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <CardanoTxn as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4
                        == <CardanoTxn as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <CardanoTxn as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// The ID of the blockchain to interact with.
                #[component(enum)]
                pub enum CardanoBlockchainId {
                    #[component(name = "mainnet")]
                    Mainnet,
                    /// Cardano Mainnet
                    #[component(name = "preprod")]
                    Preprod,
                    /// Cardano Preprod Network
                    #[component(name = "preview")]
                    Preview,
                    /// Cardano Preview Network
                    #[component(name = "local-test-blockchain")]
                    LocalTestBlockchain,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for CardanoBlockchainId {
                    #[inline]
                    fn clone(&self) -> CardanoBlockchainId {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for CardanoBlockchainId {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for CardanoBlockchainId {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for CardanoBlockchainId {
                    #[inline]
                    fn eq(&self, other: &CardanoBlockchainId) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for CardanoBlockchainId {}
                #[automatically_derived]
                impl ::core::cmp::Eq for CardanoBlockchainId {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                unsafe impl wasmtime::component::Lower for CardanoBlockchainId {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::Mainnet => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Mainnet)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Preprod => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Preprod)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Preview => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Preview)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::LocalTestBlockchain => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(3u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).LocalTestBlockchain)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::Mainnet => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Preprod => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Preview => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                Ok(())
                            }
                            Self::LocalTestBlockchain => {
                                *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for CardanoBlockchainId {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::Mainnet,
                                1u32 => Self::Preprod,
                                2u32 => Self::Preview,
                                3u32 => Self::LocalTestBlockchain,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::Mainnet,
                                1u8 => Self::Preprod,
                                2u8 => Self::Preview,
                                3u8 => Self::LocalTestBlockchain,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerCardanoBlockchainId {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadCardanoBlockchainId,
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for LowerCardanoBlockchainId {
                        #[inline]
                        fn clone(&self) -> LowerCardanoBlockchainId {
                            let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                            let _: ::core::clone::AssertParamIsClone<
                                LowerPayloadCardanoBlockchainId,
                            >;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for LowerCardanoBlockchainId {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadCardanoBlockchainId {
                        Mainnet: [wasmtime::ValRaw; 0],
                        Preprod: [wasmtime::ValRaw; 0],
                        Preview: [wasmtime::ValRaw; 0],
                        LocalTestBlockchain: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::clone::Clone for LowerPayloadCardanoBlockchainId {
                        #[inline]
                        fn clone(&self) -> LowerPayloadCardanoBlockchainId {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::marker::Copy for LowerPayloadCardanoBlockchainId {}
                    unsafe impl wasmtime::component::ComponentType
                    for CardanoBlockchainId {
                        type Lower = LowerCardanoBlockchainId;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_enum(
                                ty,
                                types,
                                &["mainnet", "preprod", "preview", "local-test-blockchain"],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[None, None, None, None],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for CardanoBlockchainId {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[None, None, None, None];
                    }
                };
                impl core::fmt::Debug for CardanoBlockchainId {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            CardanoBlockchainId::Mainnet => {
                                f.debug_tuple("CardanoBlockchainId::Mainnet").finish()
                            }
                            CardanoBlockchainId::Preprod => {
                                f.debug_tuple("CardanoBlockchainId::Preprod").finish()
                            }
                            CardanoBlockchainId::Preview => {
                                f.debug_tuple("CardanoBlockchainId::Preview").finish()
                            }
                            CardanoBlockchainId::LocalTestBlockchain => {
                                f.debug_tuple("CardanoBlockchainId::LocalTestBlockchain")
                                    .finish()
                            }
                        }
                    }
                }
                const _: () = {
                    if !(1
                        == <CardanoBlockchainId as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <CardanoBlockchainId as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1
                        == <CardanoBlockchainId as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <CardanoBlockchainId as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// The Slot number to interact with
                #[component(variant)]
                pub enum Slot {
                    #[component(name = "genesis")]
                    Genesis,
                    /// The very start of the blockchain.
                    #[component(name = "slot-no")]
                    SlotNo(u64),
                    /// A particular slot number.
                    #[component(name = "tip")]
                    Tip,
                    /// The TIP of the blockchain.
                    #[component(name = "continue")]
                    Continue,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Slot {}
                #[automatically_derived]
                impl ::core::clone::Clone for Slot {
                    #[inline]
                    fn clone(&self) -> Slot {
                        let _: ::core::clone::AssertParamIsClone<u64>;
                        *self
                    }
                }
                unsafe impl wasmtime::component::Lower for Slot {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::Genesis => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Genesis)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::SlotNo(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).SlotNo)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[1usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::Tip => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Tip)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Continue => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(3u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Continue)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::Genesis => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::SlotNo(value) => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::Tip => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Continue => {
                                *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for Slot {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::Genesis,
                                1u32 => {
                                    Self::SlotNo(
                                        <u64 as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[1usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.SlotNo },
                                        )?,
                                    )
                                }
                                2u32 => Self::Tip,
                                3u32 => Self::Continue,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::Genesis,
                                1u8 => {
                                    Self::SlotNo(
                                        <u64 as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[1usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<u64 as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                2u8 => Self::Tip,
                                3u8 => Self::Continue,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerSlot<T1: Copy> {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadSlot<T1>,
                    }
                    #[automatically_derived]
                    impl<T1: ::core::clone::Clone + Copy> ::core::clone::Clone
                    for LowerSlot<T1> {
                        #[inline]
                        fn clone(&self) -> LowerSlot<T1> {
                            LowerSlot {
                                tag: ::core::clone::Clone::clone(&self.tag),
                                payload: ::core::clone::Clone::clone(&self.payload),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<T1: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerSlot<T1> {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadSlot<T1: Copy> {
                        Genesis: [wasmtime::ValRaw; 0],
                        SlotNo: T1,
                        Tip: [wasmtime::ValRaw; 0],
                        Continue: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<
                        T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerPayloadSlot<T1> {
                        #[inline]
                        fn clone(&self) -> LowerPayloadSlot<T1> {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<T1: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerPayloadSlot<T1> {}
                    unsafe impl wasmtime::component::ComponentType for Slot {
                        type Lower = LowerSlot<
                            <u64 as wasmtime::component::ComponentType>::Lower,
                        >;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_variant(
                                ty,
                                types,
                                &[
                                    ("genesis", None),
                                    (
                                        "slot-no",
                                        Some(<u64 as wasmtime::component::ComponentType>::typecheck),
                                    ),
                                    ("tip", None),
                                    ("continue", None),
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[
                                None,
                                Some(<u64 as wasmtime::component::ComponentType>::ABI),
                                None,
                                None,
                            ],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for Slot {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[
                            None,
                            Some(<u64 as wasmtime::component::ComponentType>::ABI),
                            None,
                            None,
                        ];
                    }
                };
                impl core::fmt::Debug for Slot {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            Slot::Genesis => f.debug_tuple("Slot::Genesis").finish(),
                            Slot::SlotNo(e) => {
                                f.debug_tuple("Slot::SlotNo").field(e).finish()
                            }
                            Slot::Tip => f.debug_tuple("Slot::Tip").finish(),
                            Slot::Continue => f.debug_tuple("Slot::Continue").finish(),
                        }
                    }
                }
                const _: () = {
                    if !(16 == <Slot as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 16 == <Slot as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <Slot as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Slot as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Errors that can happen fetching/subscribing to blocks
                #[component(enum)]
                pub enum FetchError {
                    #[component(name = "blockchain-not-available")]
                    BlockchainNotAvailable,
                    /// The blockchain requested is not available.
                    #[component(name = "invalid-slot")]
                    InvalidSlot,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for FetchError {
                    #[inline]
                    fn clone(&self) -> FetchError {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for FetchError {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for FetchError {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for FetchError {
                    #[inline]
                    fn eq(&self, other: &FetchError) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for FetchError {}
                #[automatically_derived]
                impl ::core::cmp::Eq for FetchError {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                unsafe impl wasmtime::component::Lower for FetchError {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::BlockchainNotAvailable => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).BlockchainNotAvailable)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::InvalidSlot => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).InvalidSlot)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::BlockchainNotAvailable => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::InvalidSlot => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for FetchError {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::BlockchainNotAvailable,
                                1u32 => Self::InvalidSlot,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::BlockchainNotAvailable,
                                1u8 => Self::InvalidSlot,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerFetchError {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadFetchError,
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for LowerFetchError {
                        #[inline]
                        fn clone(&self) -> LowerFetchError {
                            let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                            let _: ::core::clone::AssertParamIsClone<
                                LowerPayloadFetchError,
                            >;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for LowerFetchError {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadFetchError {
                        BlockchainNotAvailable: [wasmtime::ValRaw; 0],
                        InvalidSlot: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::clone::Clone for LowerPayloadFetchError {
                        #[inline]
                        fn clone(&self) -> LowerPayloadFetchError {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::marker::Copy for LowerPayloadFetchError {}
                    unsafe impl wasmtime::component::ComponentType for FetchError {
                        type Lower = LowerFetchError;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_enum(
                                ty,
                                types,
                                &["blockchain-not-available", "invalid-slot"],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[None, None],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for FetchError {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[None, None];
                    }
                };
                impl FetchError {
                    pub fn name(&self) -> &'static str {
                        match self {
                            FetchError::BlockchainNotAvailable => {
                                "blockchain-not-available"
                            }
                            FetchError::InvalidSlot => "invalid-slot",
                        }
                    }
                    pub fn message(&self) -> &'static str {
                        match self {
                            FetchError::BlockchainNotAvailable => "",
                            FetchError::InvalidSlot => {
                                "The blockchain requested is not available."
                            }
                        }
                    }
                }
                impl core::fmt::Debug for FetchError {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("FetchError")
                            .field("code", &(*self as i32))
                            .field("name", &self.name())
                            .field("message", &self.message())
                            .finish()
                    }
                }
                impl core::fmt::Display for FetchError {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.write_fmt(
                            format_args!("{0} (error {1})", self.name(), *self as i32),
                        )
                    }
                }
                impl std::error::Error for FetchError {}
                const _: () = {
                    if !(1 == <FetchError as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <FetchError as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1
                        == <FetchError as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <FetchError as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Errors that can occur when posting transactions.
                #[component(enum)]
                pub enum TxnError {
                    #[component(name = "blockchain-not-available")]
                    BlockchainNotAvailable,
                    /// The blockchain requested is not available.
                    #[component(name = "malformed-transaction")]
                    MalformedTransaction,
                    /// The transaction is not well formed, and can not be posted.
                    #[component(name = "post-txn-not-allowed")]
                    PostTxnNotAllowed,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for TxnError {
                    #[inline]
                    fn clone(&self) -> TxnError {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for TxnError {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for TxnError {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for TxnError {
                    #[inline]
                    fn eq(&self, other: &TxnError) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for TxnError {}
                #[automatically_derived]
                impl ::core::cmp::Eq for TxnError {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                unsafe impl wasmtime::component::Lower for TxnError {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::BlockchainNotAvailable => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).BlockchainNotAvailable)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::MalformedTransaction => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).MalformedTransaction)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::PostTxnNotAllowed => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).PostTxnNotAllowed)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::BlockchainNotAvailable => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::MalformedTransaction => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                            Self::PostTxnNotAllowed => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for TxnError {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::BlockchainNotAvailable,
                                1u32 => Self::MalformedTransaction,
                                2u32 => Self::PostTxnNotAllowed,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::BlockchainNotAvailable,
                                1u8 => Self::MalformedTransaction,
                                2u8 => Self::PostTxnNotAllowed,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerTxnError {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadTxnError,
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for LowerTxnError {
                        #[inline]
                        fn clone(&self) -> LowerTxnError {
                            let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                            let _: ::core::clone::AssertParamIsClone<
                                LowerPayloadTxnError,
                            >;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for LowerTxnError {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadTxnError {
                        BlockchainNotAvailable: [wasmtime::ValRaw; 0],
                        MalformedTransaction: [wasmtime::ValRaw; 0],
                        PostTxnNotAllowed: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::clone::Clone for LowerPayloadTxnError {
                        #[inline]
                        fn clone(&self) -> LowerPayloadTxnError {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::marker::Copy for LowerPayloadTxnError {}
                    unsafe impl wasmtime::component::ComponentType for TxnError {
                        type Lower = LowerTxnError;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_enum(
                                ty,
                                types,
                                &[
                                    "blockchain-not-available",
                                    "malformed-transaction",
                                    "post-txn-not-allowed",
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[None, None, None],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for TxnError {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[None, None, None];
                    }
                };
                impl TxnError {
                    pub fn name(&self) -> &'static str {
                        match self {
                            TxnError::BlockchainNotAvailable => {
                                "blockchain-not-available"
                            }
                            TxnError::MalformedTransaction => "malformed-transaction",
                            TxnError::PostTxnNotAllowed => "post-txn-not-allowed",
                        }
                    }
                    pub fn message(&self) -> &'static str {
                        match self {
                            TxnError::BlockchainNotAvailable => "",
                            TxnError::MalformedTransaction => {
                                "The blockchain requested is not available."
                            }
                            TxnError::PostTxnNotAllowed => {
                                "The transaction is not well formed, and can not be posted."
                            }
                        }
                    }
                }
                impl core::fmt::Debug for TxnError {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("TxnError")
                            .field("code", &(*self as i32))
                            .field("name", &self.name())
                            .field("message", &self.message())
                            .finish()
                    }
                }
                impl core::fmt::Display for TxnError {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.write_fmt(
                            format_args!("{0} (error {1})", self.name(), *self as i32),
                        )
                    }
                }
                impl std::error::Error for TxnError {}
                const _: () = {
                    if !(1 == <TxnError as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <TxnError as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1 == <TxnError as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <TxnError as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub struct UnsubscribeOptions {
                    #[doc(hidden)]
                    __inner0: u8,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for UnsubscribeOptions {}
                #[automatically_derived]
                impl ::core::clone::Clone for UnsubscribeOptions {
                    #[inline]
                    fn clone(&self) -> UnsubscribeOptions {
                        let _: ::core::clone::AssertParamIsClone<u8>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for UnsubscribeOptions {
                    #[inline]
                    fn default() -> UnsubscribeOptions {
                        UnsubscribeOptions {
                            __inner0: ::core::default::Default::default(),
                        }
                    }
                }
                impl UnsubscribeOptions {
                    pub const BLOCK: Self = Self { __inner0: 1u8 };
                    pub const TRANSACTION: Self = Self { __inner0: 2u8 };
                    pub const ROLLBACK: Self = Self { __inner0: 4u8 };
                    pub const STOP: Self = Self { __inner0: 8u8 };
                    pub fn as_array(&self) -> [u32; 1usize] {
                        [self.__inner0 as u32]
                    }
                    pub fn empty() -> Self {
                        Self::default()
                    }
                    pub fn all() -> Self {
                        use std::ops::Not;
                        Self::default().not()
                    }
                    pub fn contains(&self, other: Self) -> bool {
                        *self & other == other
                    }
                    pub fn intersects(&self, other: Self) -> bool {
                        *self & other != Self::empty()
                    }
                }
                impl std::cmp::PartialEq for UnsubscribeOptions {
                    fn eq(&self, rhs: &UnsubscribeOptions) -> bool {
                        (self.__inner0 & 15u8).eq(&(rhs.__inner0 & 15u8))
                    }
                }
                impl std::cmp::Eq for UnsubscribeOptions {}
                impl std::fmt::Debug for UnsubscribeOptions {
                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                        wasmtime::component::__internal::format_flags(
                            &self.as_array(),
                            &["BLOCK", "TRANSACTION", "ROLLBACK", "STOP"],
                            f,
                        )
                    }
                }
                impl std::ops::BitOr for UnsubscribeOptions {
                    type Output = UnsubscribeOptions;
                    fn bitor(self, rhs: UnsubscribeOptions) -> UnsubscribeOptions {
                        Self {
                            __inner0: self.__inner0.bitor(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitOrAssign for UnsubscribeOptions {
                    fn bitor_assign(&mut self, rhs: UnsubscribeOptions) {
                        self.__inner0.bitor_assign(rhs.__inner0)
                    }
                }
                impl std::ops::BitAnd for UnsubscribeOptions {
                    type Output = UnsubscribeOptions;
                    fn bitand(self, rhs: UnsubscribeOptions) -> UnsubscribeOptions {
                        Self {
                            __inner0: self.__inner0.bitand(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitAndAssign for UnsubscribeOptions {
                    fn bitand_assign(&mut self, rhs: UnsubscribeOptions) {
                        self.__inner0.bitand_assign(rhs.__inner0)
                    }
                }
                impl std::ops::BitXor for UnsubscribeOptions {
                    type Output = UnsubscribeOptions;
                    fn bitxor(self, rhs: UnsubscribeOptions) -> UnsubscribeOptions {
                        Self {
                            __inner0: self.__inner0.bitxor(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitXorAssign for UnsubscribeOptions {
                    fn bitxor_assign(&mut self, rhs: UnsubscribeOptions) {
                        self.__inner0.bitxor_assign(rhs.__inner0)
                    }
                }
                impl std::ops::Not for UnsubscribeOptions {
                    type Output = UnsubscribeOptions;
                    fn not(self) -> UnsubscribeOptions {
                        Self {
                            __inner0: self.__inner0.not(),
                        }
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerUnsubscribeOptions<T0: Copy> {
                        __inner0: T0,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<T0: ::core::clone::Clone + Copy> ::core::clone::Clone
                    for LowerUnsubscribeOptions<T0> {
                        #[inline]
                        fn clone(&self) -> LowerUnsubscribeOptions<T0> {
                            LowerUnsubscribeOptions {
                                __inner0: ::core::clone::Clone::clone(&self.__inner0),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<T0: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerUnsubscribeOptions<T0> {}
                    unsafe impl wasmtime::component::ComponentType
                    for UnsubscribeOptions {
                        type Lower = LowerUnsubscribeOptions<
                            <u8 as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[<u8 as wasmtime::component::ComponentType>::ABI],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_flags(
                                ty,
                                types,
                                &["block", "transaction", "rollback", "stop"],
                            )
                        }
                    }
                };
                unsafe impl wasmtime::component::Lower for UnsubscribeOptions {
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        self.__inner0
                            .lower(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).__inner0)
                                        }
                                    }
                                },
                            )?;
                        Ok(())
                    }
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        self.__inner0
                            .store(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                offset,
                            )?;
                        offset += std::mem::size_of_val(&self.__inner0);
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for UnsubscribeOptions {
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        Ok(Self {
                            __inner0: wasmtime::component::Lift::lift(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                &src.__inner0,
                            )?,
                        })
                    }
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let (field, bytes) = bytes.split_at(1usize);
                        let __inner0 = wasmtime::component::Lift::load(
                            cx,
                            wasmtime::component::__internal::InterfaceType::U8,
                            field,
                        )?;
                        Ok(Self { __inner0 })
                    }
                }
                const _: () = {
                    if !(1
                        == <UnsubscribeOptions as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <UnsubscribeOptions as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1
                        == <UnsubscribeOptions as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <UnsubscribeOptions as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {
                    /// Subscribe to the Blockchain block data.
                    ///
                    /// **Parameters**
                    ///
                    /// - `net` : The blockchain network to fetch block from, and subscribe to.
                    /// - `whence`: Where to start fetching blocks from.
                    ///
                    /// **Returns**
                    ///
                    /// - `ok(u64)` : The slot we are synching from now.
                    /// - `error(fetch-error)` : If an error occured.
                    ///
                    /// **Notes**
                    ///
                    /// If the blockchain is not yet syncing, it will start, from the requested slot.
                    /// If the blockchain is not yet syncing, and `whence` == `continue` then the blockchain will
                    /// not be synced from, the calling module will only be subscribed for block events.
                    ///
                    /// If the blockchain is already syncing, the sync will stop and restart, unless `whence` == `continue`.
                    /// When `whence` == `continue` the blockchain will keep syncing from where it is at, and this module
                    /// will be subscribed to block updates.
                    ///
                    /// `whence` == `stop` will prevent the blockchain syncing, and the caller will be unsubscribed.
                    fn subscribe_blocks(
                        &mut self,
                        net: CardanoBlockchainId,
                        whence: Slot,
                    ) -> wasmtime::Result<Result<u64, FetchError>>;
                    /// Unsubscribe from the blockchain events listed.
                    ///
                    /// **Parameters**
                    ///
                    /// - `events` : The events to unsubscribe from (and optionally stop the blockchain follower).
                    ///
                    /// **Notes**
                    ///
                    /// This only unsubscribes from the events.
                    /// The option `stop` MUST be set to actually stop fetching data from the blockchain once started.
                    ///
                    /// `stop` can be set without unsubscribing, and this will interrupt the flow of blockchain data.
                    /// After `stop`,  `subscribe-blocks(?, continue)` would cause blockchain sync to continue from
                    /// the last block received.  This would result in the last block being sent as an event twice,
                    /// once before the `stop` and once after the `continue`.
                    fn unsubscribe(
                        &mut self,
                        events: UnsubscribeOptions,
                    ) -> wasmtime::Result<()>;
                    /// Subscribe to transaction data events, does not alter the blockchain sync in anyway.
                    ///
                    /// **Parameters**
                    ///
                    /// - `net` : The blockchain network to subscribe to txn events from.
                    fn subscribe_txn(
                        &mut self,
                        net: CardanoBlockchainId,
                    ) -> wasmtime::Result<()>;
                    /// Subscribe to blockchain rollback events, does not alter the blockchain sync in anyway.
                    ///
                    /// **Parameters**
                    ///
                    /// - `net` : The blockchain network to subscribe to txn events from.
                    ///
                    /// **Notes**
                    ///
                    /// After a rollback event, the blockchain sync will AUTOMATICALLY start sending block
                    /// data from the rollback point.  No action is required to actually follow the rollback, unless the
                    /// default behavior is not desired.
                    fn subscribe_rollback(
                        &mut self,
                        net: CardanoBlockchainId,
                    ) -> wasmtime::Result<()>;
                    /// Fetch a block from the requested blockchain at the requested slot.
                    ///
                    /// **Parameters**
                    ///
                    /// - `net`    : The blockchain network to get a block from.
                    /// - `whence` : Which block to get.
                    ///
                    /// **Returns**
                    ///
                    /// - `cardano-block` : The block requested.
                    /// - `fetch-error` : An error if the block can not be fetched.
                    ///
                    /// **Notes**
                    ///
                    /// Fetching a block does not require the blockchain to be subscribed, or for blocks to be
                    /// being followed and generating events.
                    /// It also will not alter the automatic fetching of blocks in any way, and happens in parallel
                    /// to automated block fetch.
                    fn fetch_block(
                        &mut self,
                        net: CardanoBlockchainId,
                        whence: Slot,
                    ) -> wasmtime::Result<Result<CardanoBlock, FetchError>>;
                    /// Get transactions from a block.
                    ///
                    /// This can be used to easily extract all transactions from a complete block.
                    ///
                    /// **Parameters**
                    ///
                    /// - `block` : The blockchain data to extract transactions from.
                    ///
                    /// **Returns**
                    ///
                    /// - a list of all transactions in the block, in the order they appear in the block.
                    ///
                    /// **Notes**
                    ///
                    /// This function exists to support `fetch-block`.
                    /// Transactions from subscribed block events, should be processed as transaction events.
                    fn get_txns(
                        &mut self,
                        block: CardanoBlock,
                    ) -> wasmtime::Result<Vec<CardanoTxn>>;
                    /// Post a transactions to the blockchain.
                    ///
                    /// This can be used to post a pre-formed transaction to the required blockchain.
                    ///
                    /// **Parameters**
                    ///
                    /// - `net` : The blockchain to post the transaction to.
                    /// - `txn` : The transaction data, ready to submit.
                    ///
                    /// **Returns**
                    ///
                    /// - An error if the transaction can not be posted.
                    ///
                    /// **Notes**
                    ///
                    /// This is proposed functionality, and is not yet active.
                    /// All calls to this function will return `post-txn-not-allowed` error.
                    fn post_txn(
                        &mut self,
                        net: CardanoBlockchainId,
                        txn: CardanoTxn,
                    ) -> wasmtime::Result<Result<(), TxnError>>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:cardano/api")?;
                    inst.func_wrap(
                        "subscribe-blocks",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (CardanoBlockchainId, Slot)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::subscribe_blocks(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "unsubscribe",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (UnsubscribeOptions,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::unsubscribe(host, arg0);
                            r
                        },
                    )?;
                    inst.func_wrap(
                        "subscribe-txn",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (CardanoBlockchainId,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::subscribe_txn(host, arg0);
                            r
                        },
                    )?;
                    inst.func_wrap(
                        "subscribe-rollback",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (CardanoBlockchainId,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::subscribe_rollback(host, arg0);
                            r
                        },
                    )?;
                    inst.func_wrap(
                        "fetch-block",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (CardanoBlockchainId, Slot)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::fetch_block(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "get-txns",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (CardanoBlock,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::get_txns(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "post-txn",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (CardanoBlockchainId, CardanoTxn)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::post_txn(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod cbor {
            #[allow(clippy::all)]
            pub mod api {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Bstr = super::super::super::hermes::binary::api::Bstr;
                const _: () = {
                    if !(8 == <Bstr as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Bstr as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Bstr as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Bstr as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// CBOR is a binary cbor data type.
                /// This type is used to indicate the binary array MUST be CBOR data.
                pub type Cbor = Bstr;
                const _: () = {
                    if !(8 == <Cbor as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Cbor as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Cbor as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Cbor as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {}
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:cbor/api")?;
                    Ok(())
                }
            }
        }
        pub mod cron {
            #[allow(clippy::all)]
            pub mod api {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Instant = super::super::super::wasi::clocks::monotonic_clock::Instant;
                const _: () = {
                    if !(8 == <Instant as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Instant as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <Instant as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Instant as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// A Tag used to mark a delivered cron event.
                pub type CronEventTag = String;
                const _: () = {
                    if !(8
                        == <CronEventTag as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <CronEventTag as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4
                        == <CronEventTag as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <CronEventTag as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// A cron schedule in crontab format.
                pub type CronSched = String;
                const _: () = {
                    if !(8 == <CronSched as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <CronSched as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <CronSched as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <CronSched as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// A tagged crontab entry
                /// It is valid for multiple crontab entries at the same time to have different tags.
                /// It is valid for crontab entries at different times to have the same tag.
                /// BUT there can only ever be 1 crontab entry at a specified time with a specified tag.
                /// ie, `when` + `tag` is uniquely identifying of every crontab entry.
                /// See: [crontab.5 man page](https://www.man7.org/linux/man-pages/man5/crontab.5.html) for details on cron schedule format.
                #[component(record)]
                pub struct CronTagged {
                    /// The crontab entry in standard cron format.
                    /// The Time is ALWAYS relative to UTC and does not account for local time.
                    /// If Localtime adjustment is required it must be handled by the module.
                    #[component(name = "when")]
                    pub when: CronSched,
                    /// The tag associated with the crontab entry.
                    #[component(name = "tag")]
                    pub tag: CronEventTag,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for CronTagged {
                    #[inline]
                    fn clone(&self) -> CronTagged {
                        CronTagged {
                            when: ::core::clone::Clone::clone(&self.when),
                            tag: ::core::clone::Clone::clone(&self.tag),
                        }
                    }
                }
                unsafe impl wasmtime::component::Lower for CronTagged {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::lower(
                            &self.when,
                            cx,
                            ty.fields[0usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).when)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.tag,
                            cx,
                            ty.fields[1usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            },
                        )?;
                        Ok(())
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::store(
                            &self.when,
                            cx,
                            ty.fields[0usize].ty,
                            <CronSched as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.tag,
                            cx,
                            ty.fields[1usize].ty,
                            <CronEventTag as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for CronTagged {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(Self {
                            when: <CronSched as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[0usize].ty,
                                &src.when,
                            )?,
                            tag: <CronEventTag as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[1usize].ty,
                                &src.tag,
                            )?,
                        })
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let mut offset = 0;
                        Ok(Self {
                            when: <CronSched as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[0usize].ty,
                                &bytes[<CronSched as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<CronSched as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            tag: <CronEventTag as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[1usize].ty,
                                &bytes[<CronEventTag as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<CronEventTag as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                        })
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerCronTagged<T0: Copy, T1: Copy> {
                        when: T0,
                        tag: T1,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::clone::Clone + Copy,
                        T1: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerCronTagged<T0, T1> {
                        #[inline]
                        fn clone(&self) -> LowerCronTagged<T0, T1> {
                            LowerCronTagged {
                                when: ::core::clone::Clone::clone(&self.when),
                                tag: ::core::clone::Clone::clone(&self.tag),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::marker::Copy + Copy,
                        T1: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy for LowerCronTagged<T0, T1> {}
                    unsafe impl wasmtime::component::ComponentType for CronTagged {
                        type Lower = LowerCronTagged<
                            <CronSched as wasmtime::component::ComponentType>::Lower,
                            <CronEventTag as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[
                                <CronSched as wasmtime::component::ComponentType>::ABI,
                                <CronEventTag as wasmtime::component::ComponentType>::ABI,
                            ],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_record(
                                ty,
                                types,
                                &[
                                    (
                                        "when",
                                        <CronSched as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "tag",
                                        <CronEventTag as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ],
                            )
                        }
                    }
                };
                impl core::fmt::Debug for CronTagged {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("CronTagged")
                            .field("when", &self.when)
                            .field("tag", &self.tag)
                            .finish()
                    }
                }
                const _: () = {
                    if !(16
                        == <CronTagged as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 16 == <CronTagged as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4
                        == <CronTagged as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <CronTagged as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// A discreet time entry used to help convert numeric times into crontab entries.
                #[component(variant)]
                pub enum CronComponent {
                    /// Maps to `*` in a cron schedule (ie, match all)
                    #[component(name = "all")]
                    All,
                    /// Match an absolute time/date
                    #[component(name = "at")]
                    At(u8),
                    /// Match an inclusive list of time/date values.
                    #[component(name = "range")]
                    Range((u8, u8)),
                }
                #[automatically_derived]
                impl ::core::marker::Copy for CronComponent {}
                #[automatically_derived]
                impl ::core::clone::Clone for CronComponent {
                    #[inline]
                    fn clone(&self) -> CronComponent {
                        let _: ::core::clone::AssertParamIsClone<u8>;
                        let _: ::core::clone::AssertParamIsClone<(u8, u8)>;
                        *self
                    }
                }
                unsafe impl wasmtime::component::Lower for CronComponent {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::All => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).All)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::At(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).At)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[1usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::Range(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Range)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[2usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::All => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::At(value) => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::Range(value) => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for CronComponent {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::All,
                                1u32 => {
                                    Self::At(
                                        <u8 as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[1usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.At },
                                        )?,
                                    )
                                }
                                2u32 => {
                                    Self::Range(
                                        <(
                                            u8,
                                            u8,
                                        ) as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[2usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.Range },
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::All,
                                1u8 => {
                                    Self::At(
                                        <u8 as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[1usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<u8 as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                2u8 => {
                                    Self::Range(
                                        <(
                                            u8,
                                            u8,
                                        ) as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[2usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<(
                                                u8,
                                                u8,
                                            ) as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerCronComponent<T1: Copy, T2: Copy> {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadCronComponent<T1, T2>,
                    }
                    #[automatically_derived]
                    impl<
                        T1: ::core::clone::Clone + Copy,
                        T2: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerCronComponent<T1, T2> {
                        #[inline]
                        fn clone(&self) -> LowerCronComponent<T1, T2> {
                            LowerCronComponent {
                                tag: ::core::clone::Clone::clone(&self.tag),
                                payload: ::core::clone::Clone::clone(&self.payload),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T1: ::core::marker::Copy + Copy,
                        T2: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy for LowerCronComponent<T1, T2> {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadCronComponent<T1: Copy, T2: Copy> {
                        All: [wasmtime::ValRaw; 0],
                        At: T1,
                        Range: T2,
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<
                        T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerPayloadCronComponent<T1, T2> {
                        #[inline]
                        fn clone(&self) -> LowerPayloadCronComponent<T1, T2> {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<
                        T1: ::core::marker::Copy + Copy,
                        T2: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy for LowerPayloadCronComponent<T1, T2> {}
                    unsafe impl wasmtime::component::ComponentType for CronComponent {
                        type Lower = LowerCronComponent<
                            <u8 as wasmtime::component::ComponentType>::Lower,
                            <(u8, u8) as wasmtime::component::ComponentType>::Lower,
                        >;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_variant(
                                ty,
                                types,
                                &[
                                    ("all", None),
                                    (
                                        "at",
                                        Some(<u8 as wasmtime::component::ComponentType>::typecheck),
                                    ),
                                    (
                                        "range",
                                        Some(
                                            <(u8, u8) as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[
                                None,
                                Some(<u8 as wasmtime::component::ComponentType>::ABI),
                                Some(<(u8, u8) as wasmtime::component::ComponentType>::ABI),
                            ],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for CronComponent {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[
                            None,
                            Some(<u8 as wasmtime::component::ComponentType>::ABI),
                            Some(<(u8, u8) as wasmtime::component::ComponentType>::ABI),
                        ];
                    }
                };
                impl core::fmt::Debug for CronComponent {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            CronComponent::All => {
                                f.debug_tuple("CronComponent::All").finish()
                            }
                            CronComponent::At(e) => {
                                f.debug_tuple("CronComponent::At").field(e).finish()
                            }
                            CronComponent::Range(e) => {
                                f.debug_tuple("CronComponent::Range").field(e).finish()
                            }
                        }
                    }
                }
                const _: () = {
                    if !(3
                        == <CronComponent as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 3 == <CronComponent as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1
                        == <CronComponent as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <CronComponent as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// A list of cron time components
                pub type CronTime = Vec<CronComponent>;
                const _: () = {
                    if !(8 == <CronTime as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <CronTime as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <CronTime as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <CronTime as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {
                    /// # Schedule Recurrent CRON event
                    ///
                    /// Cron events will be delivered to the `on-cron` event handler.
                    ///
                    /// ## Parameters
                    ///
                    /// - `entry`: The crontab entry to add.
                    /// - `when`: When the event triggers.  Standard crontab format.
                    /// - `tag`: A tag which will accompany the triggered event.
                    /// - `retrigger`:
                    /// - `true`: The event will re-trigger every time the crontab entry matches until cancelled.
                    /// - `false`: The event will automatically cancel after it is generated once.
                    ///
                    /// ## Returns
                    ///
                    /// - `true`: Crontab added successfully.  (Or the crontab event already exists)
                    /// - `false`: Crontab failed to be added.
                    ///
                    /// ## Note:
                    ///
                    /// If the crontab entry already exists, the retrigger flag can be changed by calling
                    /// this function.  This could be useful where a retriggering crontab event is desired
                    /// to be stopped, but ONLY after it has triggered once more.
                    fn add(
                        &mut self,
                        entry: CronTagged,
                        retrigger: bool,
                    ) -> wasmtime::Result<bool>;
                    /// # Schedule A Single cron event after a fixed delay.
                    ///
                    /// Allows for easy timed wait events to be delivered without
                    /// requiring datetime calculations or formatting cron entries.
                    ///
                    /// ## Parameters
                    ///
                    /// - `duration`: How many nanoseconds to delay.  The delay will be AT LEAST this long.
                    /// - `tag`: A tag which will accompany the triggered event.
                    ///
                    /// ## Returns
                    ///
                    /// - `true`: Crontab added successfully.
                    /// - `false`: Crontab failed to be added.
                    ///
                    /// ## Note:
                    ///
                    /// This is a convenience function which will automatically calculate the crontab
                    /// entry needed to trigger the event after the requested `duration`.
                    /// It is added as a non-retriggering event.
                    /// Listing the crontabs after this call will list the delay in addition to all other
                    /// crontab entries.
                    fn delay(
                        &mut self,
                        duration: Instant,
                        tag: CronEventTag,
                    ) -> wasmtime::Result<bool>;
                    /// # List currently active cron schedule.
                    ///
                    /// Allows for management of scheduled cron events.
                    ///
                    /// ## Parameters
                    ///
                    /// - `tag`: Optional, the tag to limit the list to.  If `none` then all crons listed.
                    ///
                    /// ## Returns
                    ///
                    /// - A list of tuples containing the scheduled crontabs and their tags, along with the current retrigger flag.
                    /// The list is sorted from most crontab that will trigger soonest to latest.
                    /// Crontabs are only listed once, in the case where a crontab may be scheduled
                    /// may times before a later one.
                    /// - `0` - `cron-tagged` - The Tagged crontab event.
                    /// - `1` - `bool` - The state of the retrigger flag.
                    fn ls(
                        &mut self,
                        tag: Option<CronEventTag>,
                    ) -> wasmtime::Result<Vec<(CronTagged, bool)>>;
                    /// # Remove the requested crontab.
                    ///
                    /// Allows for management of scheduled cron events.
                    ///
                    /// ## Parameters
                    ///
                    /// - `when`: The crontab entry to add.  Standard crontab format.
                    /// - `tag`: A tag which will accompany the triggered event.
                    ///
                    /// ## Returns
                    ///
                    /// - `true`: The requested crontab was deleted and will not trigger.
                    /// - `false`: The requested crontab does not exist.
                    fn rm(&mut self, entry: CronTagged) -> wasmtime::Result<bool>;
                    /// # Make a crontab entry from individual time values.
                    ///
                    /// Crates the properly formatted cron entry
                    /// from numeric cron time components.
                    /// Convenience function to make building cron strings simpler when they are
                    /// calculated from data.
                    ///
                    /// ## Parameters
                    ///
                    /// - `dow` - DayOfWeek (0-7, 0 or 7 = Sunday)
                    /// - `month` - Month of the year (1-12, 1 = January)
                    /// - `day` - Day in the month (1-31)
                    /// - `hour` - Hour in the day (0-23)
                    /// - `minute` - Minute in the hour (0-59)
                    ///
                    /// ## Returns
                    ///
                    /// - A matching `cron-sched` ready for use in the cron functions above.
                    ///
                    /// ## Note:
                    /// No checking is done to determine if the requested date is valid.
                    /// If a particular component is out of its allowable range it will be silently
                    /// clamped within the allowable range of each parameter.
                    /// Redundant entries will be removed.
                    /// - For example specifying a `month` as `3` and `2-4` will
                    /// remove the individual month and only produce the range.
                    fn mkcron(
                        &mut self,
                        dow: CronTime,
                        month: CronTime,
                        day: CronTime,
                        hour: CronTime,
                        minute: CronTime,
                    ) -> wasmtime::Result<CronSched>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:cron/api")?;
                    inst.func_wrap(
                        "add",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (CronTagged, bool)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::add(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "delay",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (Instant, CronEventTag)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::delay(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "ls",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (Option<CronEventTag>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::ls(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "rm",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (CronTagged,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::rm(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "mkcron",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                                arg4,
                            ): (CronTime, CronTime, CronTime, CronTime, CronTime)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::mkcron(host, arg0, arg1, arg2, arg3, arg4);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod crypto {
            #[allow(clippy::all)]
            pub mod api {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Bstr = super::super::super::hermes::binary::api::Bstr;
                const _: () = {
                    if !(8 == <Bstr as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Bstr as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Bstr as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Bstr as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub type B256 = super::super::super::hermes::binary::api::B256;
                const _: () = {
                    if !(32 == <B256 as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 32 == <B256 as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <B256 as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <B256 as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// ed25519-bip32 Private Key
                pub type Ed25519Bip32PrivateKey = B256;
                const _: () = {
                    if !(32
                        == <Ed25519Bip32PrivateKey as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 32 == <Ed25519Bip32PrivateKey as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8
                        == <Ed25519Bip32PrivateKey as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Ed25519Bip32PrivateKey as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// ed25519-bip32 Public Key
                pub type Ed25519Bip32PublicKey = B256;
                const _: () = {
                    if !(32
                        == <Ed25519Bip32PublicKey as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 32 == <Ed25519Bip32PublicKey as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8
                        == <Ed25519Bip32PublicKey as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Ed25519Bip32PublicKey as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// ed25519-bip32 Signature
                pub type Ed25519Bip32Signature = B256;
                const _: () = {
                    if !(32
                        == <Ed25519Bip32Signature as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 32 == <Ed25519Bip32Signature as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8
                        == <Ed25519Bip32Signature as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Ed25519Bip32Signature as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub enum Ed25519Bip32 {}
                pub trait HostEd25519Bip32 {
                    /// Create a new ED25519-BIP32 Crypto resource
                    ///
                    /// **Parameters**
                    ///
                    /// - `private_key` : The key to use, if not supplied one is RANDOMLY generated.
                    fn new(
                        &mut self,
                        private_key: Option<Vec<Ed25519Bip32PrivateKey>>,
                    ) -> wasmtime::Result<wasmtime::component::Resource<Ed25519Bip32>>;
                    /// Get the public key for this private key.
                    fn public_key(
                        &mut self,
                        self_: wasmtime::component::Resource<Ed25519Bip32>,
                    ) -> wasmtime::Result<Ed25519Bip32PublicKey>;
                    /// Sign data with the Private key, and return it.
                    ///
                    /// **Parameters**
                    ///
                    /// - `data` : The data to sign.
                    fn sign_data(
                        &mut self,
                        self_: wasmtime::component::Resource<Ed25519Bip32>,
                        data: Bstr,
                    ) -> wasmtime::Result<Ed25519Bip32Signature>;
                    /// Check a signature on a set of data.
                    ///
                    /// **Parameters**
                    ///
                    /// - `data` : The data to check.
                    /// - `sig`  : The signature to check.
                    ///
                    /// **Returns**
                    ///
                    /// - `true` : Signature checked OK.
                    /// - `false` : Signature check failed.
                    fn check_sig(
                        &mut self,
                        self_: wasmtime::component::Resource<Ed25519Bip32>,
                        data: Bstr,
                        sig: Ed25519Bip32Signature,
                    ) -> wasmtime::Result<bool>;
                    /// Derive a new private key from the current private key.
                    ///
                    /// Note: uses BIP32 HD key derivation.
                    fn derive(
                        &mut self,
                        self_: wasmtime::component::Resource<Ed25519Bip32>,
                    ) -> wasmtime::Result<wasmtime::component::Resource<Ed25519Bip32>>;
                    /// Create a new RANDOM private key.
                    ///
                    /// Note, this does not need to be used, as the constructor will do this automatically.
                    fn gen_private_key(
                        &mut self,
                    ) -> wasmtime::Result<Ed25519Bip32PrivateKey>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<Ed25519Bip32>,
                    ) -> wasmtime::Result<()>;
                }
                pub trait Host: HostEd25519Bip32 {}
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:crypto/api")?;
                    inst.resource(
                        "ed25519-bip32",
                        wasmtime::component::ResourceType::host::<Ed25519Bip32>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostEd25519Bip32::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.func_wrap(
                        "[constructor]ed25519-bip32",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (Option<Vec<Ed25519Bip32PrivateKey>>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostEd25519Bip32::new(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]ed25519-bip32.public-key",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Ed25519Bip32>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostEd25519Bip32::public_key(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]ed25519-bip32.sign-data",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<Ed25519Bip32>, Bstr)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostEd25519Bip32::sign_data(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]ed25519-bip32.check-sig",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (
                                wasmtime::component::Resource<Ed25519Bip32>,
                                Bstr,
                                Ed25519Bip32Signature,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostEd25519Bip32::check_sig(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]ed25519-bip32.derive",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Ed25519Bip32>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostEd25519Bip32::derive(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[static]ed25519-bip32.gen-private-key",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = HostEd25519Bip32::gen_private_key(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod hash {
            #[allow(clippy::all)]
            pub mod api {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Bstr = super::super::super::hermes::binary::api::Bstr;
                const _: () = {
                    if !(8 == <Bstr as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Bstr as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Bstr as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Bstr as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Errors that can occur during hashing.
                #[component(enum)]
                pub enum Errno {
                    #[component(name = "key-too-big")]
                    KeyTooBig,
                    /// The ley is larger than supported by the hash function.
                    #[component(name = "hash-too-big")]
                    HashTooBig,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Errno {
                    #[inline]
                    fn clone(&self) -> Errno {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Errno {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Errno {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Errno {
                    #[inline]
                    fn eq(&self, other: &Errno) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for Errno {}
                #[automatically_derived]
                impl ::core::cmp::Eq for Errno {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                unsafe impl wasmtime::component::Lower for Errno {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::KeyTooBig => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).KeyTooBig)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::HashTooBig => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HashTooBig)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::KeyTooBig => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::HashTooBig => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for Errno {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::KeyTooBig,
                                1u32 => Self::HashTooBig,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::KeyTooBig,
                                1u8 => Self::HashTooBig,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerErrno {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadErrno,
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for LowerErrno {
                        #[inline]
                        fn clone(&self) -> LowerErrno {
                            let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                            let _: ::core::clone::AssertParamIsClone<LowerPayloadErrno>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for LowerErrno {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadErrno {
                        KeyTooBig: [wasmtime::ValRaw; 0],
                        HashTooBig: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::clone::Clone for LowerPayloadErrno {
                        #[inline]
                        fn clone(&self) -> LowerPayloadErrno {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::marker::Copy for LowerPayloadErrno {}
                    unsafe impl wasmtime::component::ComponentType for Errno {
                        type Lower = LowerErrno;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_enum(
                                ty,
                                types,
                                &["key-too-big", "hash-too-big"],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[None, None],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for Errno {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[None, None];
                    }
                };
                impl Errno {
                    pub fn name(&self) -> &'static str {
                        match self {
                            Errno::KeyTooBig => "key-too-big",
                            Errno::HashTooBig => "hash-too-big",
                        }
                    }
                    pub fn message(&self) -> &'static str {
                        match self {
                            Errno::KeyTooBig => "",
                            Errno::HashTooBig => {
                                "The ley is larger than supported by the hash function."
                            }
                        }
                    }
                }
                impl core::fmt::Debug for Errno {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("Errno")
                            .field("code", &(*self as i32))
                            .field("name", &self.name())
                            .field("message", &self.message())
                            .finish()
                    }
                }
                impl core::fmt::Display for Errno {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.write_fmt(
                            format_args!("{0} (error {1})", self.name(), *self as i32),
                        )
                    }
                }
                impl std::error::Error for Errno {}
                const _: () = {
                    if !(1 == <Errno as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <Errno as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1 == <Errno as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <Errno as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {
                    /// # BLAKE2s Hash Function
                    ///
                    /// Hash a binary buffer with BLAKE2s.
                    ///
                    /// ## Parameters
                    ///
                    /// - `buf`: The binary data buffer to hash.
                    /// - `outlen`: Optional.  The size of the digest.
                    /// If the outlen is not defined, it defaults to 32.
                    /// - `key`: Optional. The key to use with the hash.
                    /// If not defined, the hash is not keyed.
                    /// Should not be > 32 bytes.
                    ///
                    /// ## Returns
                    ///
                    /// - Either a buffer the size requested, with the hash.
                    /// - Or an error:
                    /// - `key_too_big` if `key` is specified and is > 32 bytes.
                    /// - `hash_too_big` if `outlen` is specified and is > 32 bytes.
                    ///
                    /// ## Note:
                    ///
                    /// `key` length is checked before `outlen` so if both sizes are invalid, only
                    /// `key_too_big` will be returned.
                    fn blake2s(
                        &mut self,
                        buf: Bstr,
                        outlen: Option<u8>,
                        key: Option<Bstr>,
                    ) -> wasmtime::Result<Result<Bstr, Errno>>;
                    /// # BLAKE2b Hash Function
                    ///
                    /// Hash a binary buffer with BLAKE2b.
                    ///
                    /// ## Parameters
                    ///
                    /// - `buf`: The binary data buffer to hash.
                    /// - `outlen`: Optional.  The size of the digest.
                    /// If the outlen is not defined, it defaults to 64.
                    /// - `key`: Optional. The key to use with the hash.
                    /// If not defined, the hash is not keyed.
                    /// Should not be > 64 bytes.
                    ///
                    /// ## Returns
                    ///
                    /// - Either a buffer the size requested, with the hash.
                    /// - Or an error:
                    /// - `key_too_big` if `key` is specified and is > 64 bytes.
                    /// - `hash_too_big` if `outlen` is specified and is > 64 bytes.
                    ///
                    /// ## Note:
                    ///
                    /// `key` length is checked before `outlen` so if both sizes are invalid, only
                    /// `key_too_big` will be returned.
                    fn blake2b(
                        &mut self,
                        buf: Bstr,
                        outlen: Option<u8>,
                        key: Option<Bstr>,
                    ) -> wasmtime::Result<Result<Bstr, Errno>>;
                    /// # BLAKE3 Hash Function
                    ///
                    /// Hash a binary buffer with BLAKE3.
                    ///
                    /// ## Parameters
                    ///
                    /// - `buf`: The binary data buffer to hash.
                    /// - `outlen`: Optional.  The size of the digest.
                    /// If the outlen is not defined, it defaults to 32.
                    /// - `key`: Optional. The key to use with the hash.
                    /// If not defined, the hash is not keyed.
                    /// Should not be > 32 bytes.
                    ///
                    /// ## Returns
                    ///
                    /// - Either a buffer the size requested, with the hash.
                    /// - Or an error:
                    /// - `key_too_big` if `key` is specified and is > 32 bytes.
                    /// - `hash_too_big` if `outlen` is specified and is > 32 bytes.
                    ///
                    /// ## Note:
                    ///
                    /// `key` length is checked before `outlen` so if both sizes are invalid, only
                    /// `key_too_big` will be returned.
                    fn blake3(
                        &mut self,
                        buf: Bstr,
                        outlen: Option<u8>,
                        key: Option<Bstr>,
                    ) -> wasmtime::Result<Result<Bstr, Errno>>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:hash/api")?;
                    inst.func_wrap(
                        "blake2s",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1, arg2): (Bstr, Option<u8>, Option<Bstr>)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::blake2s(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "blake2b",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1, arg2): (Bstr, Option<u8>, Option<Bstr>)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::blake2b(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "blake3",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1, arg2): (Bstr, Option<u8>, Option<Bstr>)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::blake3(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod init {
            #[allow(clippy::all)]
            pub mod event {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub trait Host {
                    /// Perform application start up initialization.
                    ///
                    /// This will only ever be called once when the application this module is a part of is started.
                    /// The module must export this interface to use it.
                    ///
                    /// Returns:
                    /// - `true`  - Initialization is successful, the application may commence.
                    /// - `false` - Fatal error during Initialization.  DO NOT START APPLICATION.
                    fn init(&mut self) -> wasmtime::Result<bool>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:init/event")?;
                    inst.func_wrap(
                        "init",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::init(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod json {
            #[allow(clippy::all)]
            pub mod api {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                /// JSON is just a string.
                /// This type is used to indicate the string MUST be properly formatted JSON.
                pub type Json = String;
                const _: () = {
                    if !(8 == <Json as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Json as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Json as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Json as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {}
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:json/api")?;
                    Ok(())
                }
            }
        }
        pub mod kv_store {
            #[allow(clippy::all)]
            pub mod api {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Bstr = super::super::super::hermes::binary::api::Bstr;
                const _: () = {
                    if !(8 == <Bstr as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Bstr as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Bstr as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Bstr as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub type Cbor = super::super::super::hermes::cbor::api::Cbor;
                const _: () = {
                    if !(8 == <Cbor as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Cbor as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Cbor as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Cbor as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub type Json = super::super::super::hermes::json::api::Json;
                const _: () = {
                    if !(8 == <Json as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Json as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Json as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Json as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// A time and date in seconds plus nanoseconds.
                #[component(variant)]
                pub enum KvValues {
                    #[component(name = "kv-string")]
                    KvString(String),
                    /// A String
                    #[component(name = "kv-s64")]
                    KvS64(i64),
                    /// Just use the largest signed integer type supported
                    #[component(name = "kv-u64")]
                    KvU64(u64),
                    /// Just use the largest integer type supported
                    #[component(name = "kv-f64")]
                    KvF64(f64),
                    /// Just use the largest float type supported
                    #[component(name = "kv-bstr")]
                    KvBstr(Bstr),
                    /// A byte string
                    #[component(name = "kv-cbor")]
                    KvCbor(Cbor),
                    /// CBOR data
                    #[component(name = "kv-json")]
                    KvJson(Json),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for KvValues {
                    #[inline]
                    fn clone(&self) -> KvValues {
                        match self {
                            KvValues::KvString(__self_0) => {
                                KvValues::KvString(::core::clone::Clone::clone(__self_0))
                            }
                            KvValues::KvS64(__self_0) => {
                                KvValues::KvS64(::core::clone::Clone::clone(__self_0))
                            }
                            KvValues::KvU64(__self_0) => {
                                KvValues::KvU64(::core::clone::Clone::clone(__self_0))
                            }
                            KvValues::KvF64(__self_0) => {
                                KvValues::KvF64(::core::clone::Clone::clone(__self_0))
                            }
                            KvValues::KvBstr(__self_0) => {
                                KvValues::KvBstr(::core::clone::Clone::clone(__self_0))
                            }
                            KvValues::KvCbor(__self_0) => {
                                KvValues::KvCbor(::core::clone::Clone::clone(__self_0))
                            }
                            KvValues::KvJson(__self_0) => {
                                KvValues::KvJson(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lower for KvValues {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::KvString(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).KvString)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[0usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::KvS64(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).KvS64)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[1usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::KvU64(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).KvU64)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[2usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::KvF64(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(3u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).KvF64)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[3usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::KvBstr(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(4u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).KvBstr)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[4usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::KvCbor(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(5u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).KvCbor)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[5usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::KvJson(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(6u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).KvJson)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[6usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::KvString(value) => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::KvS64(value) => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::KvU64(value) => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::KvF64(value) => {
                                *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::KvBstr(value) => {
                                *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::KvCbor(value) => {
                                *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::KvJson(value) => {
                                *cx.get::<1usize>(offset) = 6u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[6usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for KvValues {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => {
                                    Self::KvString(
                                        <String as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[0usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.KvString },
                                        )?,
                                    )
                                }
                                1u32 => {
                                    Self::KvS64(
                                        <i64 as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[1usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.KvS64 },
                                        )?,
                                    )
                                }
                                2u32 => {
                                    Self::KvU64(
                                        <u64 as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[2usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.KvU64 },
                                        )?,
                                    )
                                }
                                3u32 => {
                                    Self::KvF64(
                                        <f64 as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[3usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.KvF64 },
                                        )?,
                                    )
                                }
                                4u32 => {
                                    Self::KvBstr(
                                        <Bstr as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[4usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.KvBstr },
                                        )?,
                                    )
                                }
                                5u32 => {
                                    Self::KvCbor(
                                        <Cbor as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[5usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.KvCbor },
                                        )?,
                                    )
                                }
                                6u32 => {
                                    Self::KvJson(
                                        <Json as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[6usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.KvJson },
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => {
                                    Self::KvString(
                                        <String as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[0usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                1u8 => {
                                    Self::KvS64(
                                        <i64 as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[1usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<i64 as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                2u8 => {
                                    Self::KvU64(
                                        <u64 as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[2usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<u64 as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                3u8 => {
                                    Self::KvF64(
                                        <f64 as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[3usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<f64 as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                4u8 => {
                                    Self::KvBstr(
                                        <Bstr as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[4usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Bstr as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                5u8 => {
                                    Self::KvCbor(
                                        <Cbor as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[5usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Cbor as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                6u8 => {
                                    Self::KvJson(
                                        <Json as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[6usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Json as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerKvValues<
                        T0: Copy,
                        T1: Copy,
                        T2: Copy,
                        T3: Copy,
                        T4: Copy,
                        T5: Copy,
                        T6: Copy,
                    > {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadKvValues<T0, T1, T2, T3, T4, T5, T6>,
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::clone::Clone + Copy,
                        T1: ::core::clone::Clone + Copy,
                        T2: ::core::clone::Clone + Copy,
                        T3: ::core::clone::Clone + Copy,
                        T4: ::core::clone::Clone + Copy,
                        T5: ::core::clone::Clone + Copy,
                        T6: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone
                    for LowerKvValues<T0, T1, T2, T3, T4, T5, T6> {
                        #[inline]
                        fn clone(&self) -> LowerKvValues<T0, T1, T2, T3, T4, T5, T6> {
                            LowerKvValues {
                                tag: ::core::clone::Clone::clone(&self.tag),
                                payload: ::core::clone::Clone::clone(&self.payload),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::marker::Copy + Copy,
                        T1: ::core::marker::Copy + Copy,
                        T2: ::core::marker::Copy + Copy,
                        T3: ::core::marker::Copy + Copy,
                        T4: ::core::marker::Copy + Copy,
                        T5: ::core::marker::Copy + Copy,
                        T6: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy
                    for LowerKvValues<T0, T1, T2, T3, T4, T5, T6> {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadKvValues<
                        T0: Copy,
                        T1: Copy,
                        T2: Copy,
                        T3: Copy,
                        T4: Copy,
                        T5: Copy,
                        T6: Copy,
                    > {
                        KvString: T0,
                        KvS64: T1,
                        KvU64: T2,
                        KvF64: T3,
                        KvBstr: T4,
                        KvCbor: T5,
                        KvJson: T6,
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<
                        T0: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T3: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T4: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T5: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T6: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    > ::core::clone::Clone
                    for LowerPayloadKvValues<T0, T1, T2, T3, T4, T5, T6> {
                        #[inline]
                        fn clone(
                            &self,
                        ) -> LowerPayloadKvValues<T0, T1, T2, T3, T4, T5, T6> {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<
                        T0: ::core::marker::Copy + Copy,
                        T1: ::core::marker::Copy + Copy,
                        T2: ::core::marker::Copy + Copy,
                        T3: ::core::marker::Copy + Copy,
                        T4: ::core::marker::Copy + Copy,
                        T5: ::core::marker::Copy + Copy,
                        T6: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy
                    for LowerPayloadKvValues<T0, T1, T2, T3, T4, T5, T6> {}
                    unsafe impl wasmtime::component::ComponentType for KvValues {
                        type Lower = LowerKvValues<
                            <String as wasmtime::component::ComponentType>::Lower,
                            <i64 as wasmtime::component::ComponentType>::Lower,
                            <u64 as wasmtime::component::ComponentType>::Lower,
                            <f64 as wasmtime::component::ComponentType>::Lower,
                            <Bstr as wasmtime::component::ComponentType>::Lower,
                            <Cbor as wasmtime::component::ComponentType>::Lower,
                            <Json as wasmtime::component::ComponentType>::Lower,
                        >;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_variant(
                                ty,
                                types,
                                &[
                                    (
                                        "kv-string",
                                        Some(
                                            <String as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "kv-s64",
                                        Some(<i64 as wasmtime::component::ComponentType>::typecheck),
                                    ),
                                    (
                                        "kv-u64",
                                        Some(<u64 as wasmtime::component::ComponentType>::typecheck),
                                    ),
                                    (
                                        "kv-f64",
                                        Some(<f64 as wasmtime::component::ComponentType>::typecheck),
                                    ),
                                    (
                                        "kv-bstr",
                                        Some(
                                            <Bstr as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "kv-cbor",
                                        Some(
                                            <Cbor as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "kv-json",
                                        Some(
                                            <Json as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[
                                Some(<String as wasmtime::component::ComponentType>::ABI),
                                Some(<i64 as wasmtime::component::ComponentType>::ABI),
                                Some(<u64 as wasmtime::component::ComponentType>::ABI),
                                Some(<f64 as wasmtime::component::ComponentType>::ABI),
                                Some(<Bstr as wasmtime::component::ComponentType>::ABI),
                                Some(<Cbor as wasmtime::component::ComponentType>::ABI),
                                Some(<Json as wasmtime::component::ComponentType>::ABI),
                            ],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for KvValues {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<i64 as wasmtime::component::ComponentType>::ABI),
                            Some(<u64 as wasmtime::component::ComponentType>::ABI),
                            Some(<f64 as wasmtime::component::ComponentType>::ABI),
                            Some(<Bstr as wasmtime::component::ComponentType>::ABI),
                            Some(<Cbor as wasmtime::component::ComponentType>::ABI),
                            Some(<Json as wasmtime::component::ComponentType>::ABI),
                        ];
                    }
                };
                impl core::fmt::Debug for KvValues {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            KvValues::KvString(e) => {
                                f.debug_tuple("KvValues::KvString").field(e).finish()
                            }
                            KvValues::KvS64(e) => {
                                f.debug_tuple("KvValues::KvS64").field(e).finish()
                            }
                            KvValues::KvU64(e) => {
                                f.debug_tuple("KvValues::KvU64").field(e).finish()
                            }
                            KvValues::KvF64(e) => {
                                f.debug_tuple("KvValues::KvF64").field(e).finish()
                            }
                            KvValues::KvBstr(e) => {
                                f.debug_tuple("KvValues::KvBstr").field(e).finish()
                            }
                            KvValues::KvCbor(e) => {
                                f.debug_tuple("KvValues::KvCbor").field(e).finish()
                            }
                            KvValues::KvJson(e) => {
                                f.debug_tuple("KvValues::KvJson").field(e).finish()
                            }
                        }
                    }
                }
                const _: () = {
                    if !(16 == <KvValues as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 16 == <KvValues as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <KvValues as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <KvValues as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {
                    /// Set a value in the local key-value store
                    /// Setting None will cause the Key to be deleted from the KV store.
                    fn kv_set(
                        &mut self,
                        key: String,
                        value: Option<KvValues>,
                    ) -> wasmtime::Result<()>;
                    /// Get a value from the local key-value store
                    /// Returns the default if not set.
                    fn kv_get_default(
                        &mut self,
                        key: String,
                        default: Option<KvValues>,
                    ) -> wasmtime::Result<Option<KvValues>>;
                    /// Get a value from the local key-value store
                    /// Returns None if the Key does not exist in the KV Store.
                    /// This is a convenience function, and is equivalent to `kv-get-default(key, none)`
                    fn kv_get(
                        &mut self,
                        key: String,
                    ) -> wasmtime::Result<Option<KvValues>>;
                    /// Get a value, and then set it (Atomic)
                    /// Setting None will cause the Key to be deleted from the KV store.
                    fn kv_get_set(
                        &mut self,
                        key: String,
                        value: Option<KvValues>,
                    ) -> wasmtime::Result<Option<KvValues>>;
                    /// Get a value, and then add to it (Atomic)
                    /// Adding to a string will concatenate the string.
                    /// String concatenation will only occur up to the maximum possible size of a string value.\
                    /// Concatenation beyond the maximum size will result in truncation.
                    /// Adding to a numeric will have the expected behavior (rounded to nearest if necessary).
                    /// The original type does not change, so: `float64 + u64 = float64`.  `s64 + float64 = s64`
                    /// If the value overflows or under-flows it will saturate at the limit.
                    /// This behavior allows us to decrement values by using the signed version, so `u64(10) + s64(-5) = u64(5))`
                    /// If a string is added to a numeric, nothing happens.
                    /// If a numeric is added to a string, it is converted to a string first, and then concatenated
                    /// Note: There will be no spaces added.  So "My string" + u32(77) = "My string77"
                    fn kv_add(
                        &mut self,
                        key: String,
                        value: Option<KvValues>,
                    ) -> wasmtime::Result<Option<KvValues>>;
                    /// Check if the Key equals a test value (exact match) and if it does, store the new value.
                    /// In all cases, the current value is returned.
                    /// If the types are NOT the same, the comparison will fail, even if the values are equivalent.
                    /// For example: `u64(7) != s64(7)`, `float64(-1) != s64(-1)`.
                    fn kv_cas(
                        &mut self,
                        key: String,
                        test: Option<KvValues>,
                        value: Option<KvValues>,
                    ) -> wasmtime::Result<Option<KvValues>>;
                    /// Subscribe to any updates made to a particular Key.
                    /// After this call, this module will receive Key Update events when a key is written.
                    /// It returns the current value of the Key and None if it is not set.
                    fn kv_subscribe(
                        &mut self,
                        key: String,
                    ) -> wasmtime::Result<Option<KvValues>>;
                    /// Unsubscribe to any updates made to a particular Key.
                    /// After this call, this module will no longer receive Key Update events when a key is written.
                    /// It returns the current value of the Key and None if it is not set.
                    fn kv_unsubscribe(
                        &mut self,
                        key: String,
                    ) -> wasmtime::Result<Option<KvValues>>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:kv-store/api")?;
                    inst.func_wrap(
                        "kv-set",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (String, Option<KvValues>)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::kv_set(host, arg0, arg1);
                            r
                        },
                    )?;
                    inst.func_wrap(
                        "kv-get-default",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (String, Option<KvValues>)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::kv_get_default(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "kv-get",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (String,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::kv_get(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "kv-get-set",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (String, Option<KvValues>)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::kv_get_set(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "kv-add",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (String, Option<KvValues>)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::kv_add(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "kv-cas",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (String, Option<KvValues>, Option<KvValues>)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::kv_cas(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "kv-subscribe",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (String,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::kv_subscribe(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "kv-unsubscribe",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (String,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::kv_unsubscribe(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
            #[allow(clippy::all)]
            pub mod event {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type KvValues = super::super::super::hermes::kv_store::api::KvValues;
                const _: () = {
                    if !(16 == <KvValues as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 16 == <KvValues as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <KvValues as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <KvValues as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {
                    /// A Subscribed key has updated.
                    ///
                    /// This will only ever be called if the module has subscribed to updates using
                    /// `kv-subscribe`
                    ///
                    /// Returns:
                    /// Nothing.
                    fn kv_update(
                        &mut self,
                        key: String,
                        value: KvValues,
                    ) -> wasmtime::Result<()>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:kv-store/event")?;
                    inst.func_wrap(
                        "kv-update",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (String, KvValues)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::kv_update(host, arg0, arg1);
                            r
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod localtime {
            #[allow(clippy::all)]
            pub mod api {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
                const _: () = {
                    if !(16 == <Datetime as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 16 == <Datetime as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <Datetime as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Datetime as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// The timezone we are localized for.
                pub type Timezone = String;
                const _: () = {
                    if !(8 == <Timezone as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Timezone as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Timezone as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Timezone as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Time in localtime format.
                #[component(record)]
                pub struct Localtime {
                    #[component(name = "year")]
                    pub year: u64,
                    /// Year
                    #[component(name = "month")]
                    pub month: u8,
                    /// Month (0-11)
                    #[component(name = "dow")]
                    pub dow: u8,
                    /// Day of week (0-6)
                    #[component(name = "day")]
                    pub day: u8,
                    /// Day (1-31)
                    #[component(name = "hh")]
                    pub hh: u8,
                    /// Hour (0-23)
                    #[component(name = "mm")]
                    pub mm: u8,
                    /// Minute (0-59)
                    #[component(name = "ss")]
                    pub ss: u8,
                    /// Second (0-59)
                    #[component(name = "ns")]
                    pub ns: u32,
                    /// Nanoseconds
                    #[component(name = "tz")]
                    pub tz: Timezone,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Localtime {
                    #[inline]
                    fn clone(&self) -> Localtime {
                        Localtime {
                            year: ::core::clone::Clone::clone(&self.year),
                            month: ::core::clone::Clone::clone(&self.month),
                            dow: ::core::clone::Clone::clone(&self.dow),
                            day: ::core::clone::Clone::clone(&self.day),
                            hh: ::core::clone::Clone::clone(&self.hh),
                            mm: ::core::clone::Clone::clone(&self.mm),
                            ss: ::core::clone::Clone::clone(&self.ss),
                            ns: ::core::clone::Clone::clone(&self.ns),
                            tz: ::core::clone::Clone::clone(&self.tz),
                        }
                    }
                }
                unsafe impl wasmtime::component::Lower for Localtime {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::lower(
                            &self.year,
                            cx,
                            ty.fields[0usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).year)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.month,
                            cx,
                            ty.fields[1usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).month)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.dow,
                            cx,
                            ty.fields[2usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).dow)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.day,
                            cx,
                            ty.fields[3usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).day)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.hh,
                            cx,
                            ty.fields[4usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).hh)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.mm,
                            cx,
                            ty.fields[5usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).mm)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.ss,
                            cx,
                            ty.fields[6usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).ss)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.ns,
                            cx,
                            ty.fields[7usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).ns)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.tz,
                            cx,
                            ty.fields[8usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tz)
                                    }
                                }
                            },
                        )?;
                        Ok(())
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::store(
                            &self.year,
                            cx,
                            ty.fields[0usize].ty,
                            <u64 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.month,
                            cx,
                            ty.fields[1usize].ty,
                            <u8 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.dow,
                            cx,
                            ty.fields[2usize].ty,
                            <u8 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.day,
                            cx,
                            ty.fields[3usize].ty,
                            <u8 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.hh,
                            cx,
                            ty.fields[4usize].ty,
                            <u8 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.mm,
                            cx,
                            ty.fields[5usize].ty,
                            <u8 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.ss,
                            cx,
                            ty.fields[6usize].ty,
                            <u8 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.ns,
                            cx,
                            ty.fields[7usize].ty,
                            <u32 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.tz,
                            cx,
                            ty.fields[8usize].ty,
                            <Timezone as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for Localtime {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(Self {
                            year: <u64 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[0usize].ty,
                                &src.year,
                            )?,
                            month: <u8 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[1usize].ty,
                                &src.month,
                            )?,
                            dow: <u8 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[2usize].ty,
                                &src.dow,
                            )?,
                            day: <u8 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[3usize].ty,
                                &src.day,
                            )?,
                            hh: <u8 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[4usize].ty,
                                &src.hh,
                            )?,
                            mm: <u8 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[5usize].ty,
                                &src.mm,
                            )?,
                            ss: <u8 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[6usize].ty,
                                &src.ss,
                            )?,
                            ns: <u32 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[7usize].ty,
                                &src.ns,
                            )?,
                            tz: <Timezone as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[8usize].ty,
                                &src.tz,
                            )?,
                        })
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let mut offset = 0;
                        Ok(Self {
                            year: <u64 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[0usize].ty,
                                &bytes[<u64 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u64 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            month: <u8 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[1usize].ty,
                                &bytes[<u8 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u8 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            dow: <u8 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[2usize].ty,
                                &bytes[<u8 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u8 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            day: <u8 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[3usize].ty,
                                &bytes[<u8 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u8 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            hh: <u8 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[4usize].ty,
                                &bytes[<u8 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u8 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            mm: <u8 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[5usize].ty,
                                &bytes[<u8 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u8 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            ss: <u8 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[6usize].ty,
                                &bytes[<u8 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u8 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            ns: <u32 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[7usize].ty,
                                &bytes[<u32 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u32 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            tz: <Timezone as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[8usize].ty,
                                &bytes[<Timezone as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<Timezone as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                        })
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerLocaltime<
                        T0: Copy,
                        T1: Copy,
                        T2: Copy,
                        T3: Copy,
                        T4: Copy,
                        T5: Copy,
                        T6: Copy,
                        T7: Copy,
                        T8: Copy,
                    > {
                        year: T0,
                        month: T1,
                        dow: T2,
                        day: T3,
                        hh: T4,
                        mm: T5,
                        ss: T6,
                        ns: T7,
                        tz: T8,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::clone::Clone + Copy,
                        T1: ::core::clone::Clone + Copy,
                        T2: ::core::clone::Clone + Copy,
                        T3: ::core::clone::Clone + Copy,
                        T4: ::core::clone::Clone + Copy,
                        T5: ::core::clone::Clone + Copy,
                        T6: ::core::clone::Clone + Copy,
                        T7: ::core::clone::Clone + Copy,
                        T8: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone
                    for LowerLocaltime<T0, T1, T2, T3, T4, T5, T6, T7, T8> {
                        #[inline]
                        fn clone(
                            &self,
                        ) -> LowerLocaltime<T0, T1, T2, T3, T4, T5, T6, T7, T8> {
                            LowerLocaltime {
                                year: ::core::clone::Clone::clone(&self.year),
                                month: ::core::clone::Clone::clone(&self.month),
                                dow: ::core::clone::Clone::clone(&self.dow),
                                day: ::core::clone::Clone::clone(&self.day),
                                hh: ::core::clone::Clone::clone(&self.hh),
                                mm: ::core::clone::Clone::clone(&self.mm),
                                ss: ::core::clone::Clone::clone(&self.ss),
                                ns: ::core::clone::Clone::clone(&self.ns),
                                tz: ::core::clone::Clone::clone(&self.tz),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::marker::Copy + Copy,
                        T1: ::core::marker::Copy + Copy,
                        T2: ::core::marker::Copy + Copy,
                        T3: ::core::marker::Copy + Copy,
                        T4: ::core::marker::Copy + Copy,
                        T5: ::core::marker::Copy + Copy,
                        T6: ::core::marker::Copy + Copy,
                        T7: ::core::marker::Copy + Copy,
                        T8: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy
                    for LowerLocaltime<T0, T1, T2, T3, T4, T5, T6, T7, T8> {}
                    unsafe impl wasmtime::component::ComponentType for Localtime {
                        type Lower = LowerLocaltime<
                            <u64 as wasmtime::component::ComponentType>::Lower,
                            <u8 as wasmtime::component::ComponentType>::Lower,
                            <u8 as wasmtime::component::ComponentType>::Lower,
                            <u8 as wasmtime::component::ComponentType>::Lower,
                            <u8 as wasmtime::component::ComponentType>::Lower,
                            <u8 as wasmtime::component::ComponentType>::Lower,
                            <u8 as wasmtime::component::ComponentType>::Lower,
                            <u32 as wasmtime::component::ComponentType>::Lower,
                            <Timezone as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[
                                <u64 as wasmtime::component::ComponentType>::ABI,
                                <u8 as wasmtime::component::ComponentType>::ABI,
                                <u8 as wasmtime::component::ComponentType>::ABI,
                                <u8 as wasmtime::component::ComponentType>::ABI,
                                <u8 as wasmtime::component::ComponentType>::ABI,
                                <u8 as wasmtime::component::ComponentType>::ABI,
                                <u8 as wasmtime::component::ComponentType>::ABI,
                                <u32 as wasmtime::component::ComponentType>::ABI,
                                <Timezone as wasmtime::component::ComponentType>::ABI,
                            ],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_record(
                                ty,
                                types,
                                &[
                                    (
                                        "year",
                                        <u64 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "month",
                                        <u8 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "dow",
                                        <u8 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "day",
                                        <u8 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "hh",
                                        <u8 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "mm",
                                        <u8 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "ss",
                                        <u8 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "ns",
                                        <u32 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "tz",
                                        <Timezone as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ],
                            )
                        }
                    }
                };
                impl core::fmt::Debug for Localtime {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("Localtime")
                            .field("year", &self.year)
                            .field("month", &self.month)
                            .field("dow", &self.dow)
                            .field("day", &self.day)
                            .field("hh", &self.hh)
                            .field("mm", &self.mm)
                            .field("ss", &self.ss)
                            .field("ns", &self.ns)
                            .field("tz", &self.tz)
                            .finish()
                    }
                }
                const _: () = {
                    if !(32 == <Localtime as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 32 == <Localtime as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <Localtime as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Localtime as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Errors that can occur converting times
                #[component(enum)]
                pub enum Errno {
                    #[component(name = "invalid-localtime")]
                    InvalidLocaltime,
                    #[component(name = "unknown-timezone")]
                    UnknownTimezone,
                    #[component(name = "year-out-of-range")]
                    YearOutOfRange,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Errno {
                    #[inline]
                    fn clone(&self) -> Errno {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Errno {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Errno {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Errno {
                    #[inline]
                    fn eq(&self, other: &Errno) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for Errno {}
                #[automatically_derived]
                impl ::core::cmp::Eq for Errno {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                unsafe impl wasmtime::component::Lower for Errno {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::InvalidLocaltime => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).InvalidLocaltime)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::UnknownTimezone => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).UnknownTimezone)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::YearOutOfRange => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).YearOutOfRange)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::InvalidLocaltime => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::UnknownTimezone => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                            Self::YearOutOfRange => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for Errno {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::InvalidLocaltime,
                                1u32 => Self::UnknownTimezone,
                                2u32 => Self::YearOutOfRange,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::InvalidLocaltime,
                                1u8 => Self::UnknownTimezone,
                                2u8 => Self::YearOutOfRange,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerErrno {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadErrno,
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for LowerErrno {
                        #[inline]
                        fn clone(&self) -> LowerErrno {
                            let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                            let _: ::core::clone::AssertParamIsClone<LowerPayloadErrno>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for LowerErrno {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadErrno {
                        InvalidLocaltime: [wasmtime::ValRaw; 0],
                        UnknownTimezone: [wasmtime::ValRaw; 0],
                        YearOutOfRange: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::clone::Clone for LowerPayloadErrno {
                        #[inline]
                        fn clone(&self) -> LowerPayloadErrno {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::marker::Copy for LowerPayloadErrno {}
                    unsafe impl wasmtime::component::ComponentType for Errno {
                        type Lower = LowerErrno;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_enum(
                                ty,
                                types,
                                &[
                                    "invalid-localtime",
                                    "unknown-timezone",
                                    "year-out-of-range",
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[None, None, None],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for Errno {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[None, None, None];
                    }
                };
                impl Errno {
                    pub fn name(&self) -> &'static str {
                        match self {
                            Errno::InvalidLocaltime => "invalid-localtime",
                            Errno::UnknownTimezone => "unknown-timezone",
                            Errno::YearOutOfRange => "year-out-of-range",
                        }
                    }
                    pub fn message(&self) -> &'static str {
                        match self {
                            Errno::InvalidLocaltime => "",
                            Errno::UnknownTimezone => "",
                            Errno::YearOutOfRange => "",
                        }
                    }
                }
                impl core::fmt::Debug for Errno {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("Errno")
                            .field("code", &(*self as i32))
                            .field("name", &self.name())
                            .field("message", &self.message())
                            .finish()
                    }
                }
                impl core::fmt::Display for Errno {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.write_fmt(
                            format_args!("{0} (error {1})", self.name(), *self as i32),
                        )
                    }
                }
                impl std::error::Error for Errno {}
                const _: () = {
                    if !(1 == <Errno as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <Errno as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1 == <Errno as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <Errno as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {
                    /// Get localtime from a datetime or now.
                    ///
                    /// **Parameters**
                    ///
                    /// `when` : The datetime we want to convert (Optional, if not set it will convert `now`).
                    /// `tz` : The timezone to use. (Optional, if not set uses the local machines configured local timezone.)
                    ///
                    /// **Returns**
                    ///
                    /// `localtime` : the converted time.
                    /// `errno`     : An error indicating why conversion failed.
                    fn get_localtime(
                        &mut self,
                        when: Option<Datetime>,
                        tz: Option<Timezone>,
                    ) -> wasmtime::Result<Result<Localtime, Errno>>;
                    /// Get a new localtime from a localtime, by recalculating time for a new timezone.
                    ///
                    /// **Parameters**
                    ///
                    /// `time` : The localtime to convert.
                    /// `tz` : The timezone to use. (Optional, if not set uses the local machines configured local timezone.)
                    ///
                    /// **Returns**
                    ///
                    /// `localtime` : the converted time.
                    /// `errno`     : An error indicating why conversion failed.
                    fn alt_localtime(
                        &mut self,
                        time: Localtime,
                        tz: Option<Timezone>,
                    ) -> wasmtime::Result<Result<Localtime, Errno>>;
                    /// Get a datetime from a localtime.
                    ///
                    /// **Parameters**
                    ///
                    /// `time` : The localtime to convert.
                    ///
                    /// **Returns**
                    ///
                    /// `datetime`  : the converted time.
                    /// `errno`     : An error indicating why conversion failed.
                    fn get_datetime(
                        &mut self,
                        time: Localtime,
                    ) -> wasmtime::Result<Result<Datetime, Errno>>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:localtime/api")?;
                    inst.func_wrap(
                        "get-localtime",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (Option<Datetime>, Option<Timezone>)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::get_localtime(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "alt-localtime",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0, arg1): (Localtime, Option<Timezone>)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::alt_localtime(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "get-datetime",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (Localtime,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::get_datetime(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod logging {
            #[allow(clippy::all)]
            pub mod api {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Json = super::super::super::hermes::json::api::Json;
                const _: () = {
                    if !(8 == <Json as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Json as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Json as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Json as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// The supported logging levels
                #[component(enum)]
                pub enum Level {
                    /// Debug Log Level
                    #[component(name = "debug")]
                    Debug,
                    /// Tracing Log level
                    #[component(name = "trace")]
                    Trace,
                    /// General Informational Log Level
                    #[component(name = "info")]
                    Info,
                    /// Warning about something that might be a problem.
                    #[component(name = "warn")]
                    Warn,
                    /// A very serious error
                    #[component(name = "error")]
                    Error,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Level {
                    #[inline]
                    fn clone(&self) -> Level {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Level {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Level {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Level {
                    #[inline]
                    fn eq(&self, other: &Level) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for Level {}
                #[automatically_derived]
                impl ::core::cmp::Eq for Level {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                unsafe impl wasmtime::component::Lower for Level {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::Debug => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Debug)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Trace => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Trace)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Info => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Info)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Warn => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(3u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Warn)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Error => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(4u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Error)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::Debug => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Trace => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Info => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Warn => {
                                *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Error => {
                                *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for Level {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::Debug,
                                1u32 => Self::Trace,
                                2u32 => Self::Info,
                                3u32 => Self::Warn,
                                4u32 => Self::Error,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::Debug,
                                1u8 => Self::Trace,
                                2u8 => Self::Info,
                                3u8 => Self::Warn,
                                4u8 => Self::Error,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerLevel {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadLevel,
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for LowerLevel {
                        #[inline]
                        fn clone(&self) -> LowerLevel {
                            let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                            let _: ::core::clone::AssertParamIsClone<LowerPayloadLevel>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for LowerLevel {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadLevel {
                        Debug: [wasmtime::ValRaw; 0],
                        Trace: [wasmtime::ValRaw; 0],
                        Info: [wasmtime::ValRaw; 0],
                        Warn: [wasmtime::ValRaw; 0],
                        Error: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::clone::Clone for LowerPayloadLevel {
                        #[inline]
                        fn clone(&self) -> LowerPayloadLevel {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::marker::Copy for LowerPayloadLevel {}
                    unsafe impl wasmtime::component::ComponentType for Level {
                        type Lower = LowerLevel;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_enum(
                                ty,
                                types,
                                &["debug", "trace", "info", "warn", "error"],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[None, None, None, None, None],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for Level {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[None, None, None, None, None];
                    }
                };
                impl core::fmt::Debug for Level {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            Level::Debug => f.debug_tuple("Level::Debug").finish(),
                            Level::Trace => f.debug_tuple("Level::Trace").finish(),
                            Level::Info => f.debug_tuple("Level::Info").finish(),
                            Level::Warn => f.debug_tuple("Level::Warn").finish(),
                            Level::Error => f.debug_tuple("Level::Error").finish(),
                        }
                    }
                }
                const _: () = {
                    if !(1 == <Level as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <Level as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1 == <Level as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <Level as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {
                    /// Generate a Log
                    ///
                    /// The Hermes API will add extra information to the log, such as the instance of the webasm
                    /// module being logged.
                    /// The Webasm module does not need to concern itself with this kind of information, and should
                    /// log as if it is the only instance.
                    /// It also should not log any webasm shared context, except where it is relevant to the log message itself.
                    ///
                    /// **Parameters**
                    ///
                    /// - `level` : The log level this message is for.
                    /// - `file`  : The name of the src file being logged from. (Optional)
                    /// - `fn`    : The function within the file being logged from. (Optional)
                    /// - `line`  : The line of code the log was generated from. (Optional)
                    /// - `col`   : The column of code the log was generated from. (Optional)
                    /// - `ctx`   : The logging context.  (Should have no newlines or formatting).
                    /// - `msg`   : A Single line message to be logged. (Should have no newlines or formatting).
                    /// - `data`  : A Free form json payload that will be logged with the msg.  This must be valid JSON.
                    ///
                    /// *Notes*
                    ///
                    /// The `data` parameter may contain a record of the format:
                    /// ```json
                    /// {
                    /// "bt" : [ <string> , <string> ]
                    /// }
                    /// ```
                    /// The logger will interpret this as a backtrace where each entry in the array is one line of the backtrace.
                    /// The format of the backtrace lines is up to the webasm module generating the log.
                    /// The individual backtrace entries may contain line breaks if the backtrace entry is
                    /// multiline.
                    /// * Multiline backtrace entries should be de-dented, relative to the first line.
                    /// * This is to allow the display to properly format multiline entries.
                    /// This format is designed to keep the broadest flexibility for multiple languages capabilities.
                    /// The backtrace must be sorted with most recent lines of the backtrace occurring first in the array.
                    /// Backtrace must be contained in a single `log` call.  Multiple log calls will be considered independent logs.
                    fn log(
                        &mut self,
                        level: Level,
                        file: Option<String>,
                        fn_: Option<String>,
                        line: Option<u32>,
                        col: Option<u32>,
                        ctx: Option<String>,
                        msg: String,
                        data: Option<Json>,
                    ) -> wasmtime::Result<()>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("hermes:logging/api")?;
                    inst.func_wrap(
                        "log",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                                arg4,
                                arg5,
                                arg6,
                                arg7,
                            ): (
                                Level,
                                Option<String>,
                                Option<String>,
                                Option<u32>,
                                Option<u32>,
                                Option<String>,
                                String,
                                Option<Json>,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::log(
                                host,
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                                arg4,
                                arg5,
                                arg6,
                                arg7,
                            );
                            r
                        },
                    )?;
                    Ok(())
                }
            }
        }
    }
    pub mod wasi {
        pub mod cli {
            #[allow(clippy::all)]
            pub mod environment {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub trait Host {
                    /// Get the POSIX-style environment variables.
                    ///
                    /// Each environment variable is provided as a pair of string variable names
                    /// and string value.
                    ///
                    /// Morally, these are a value import, but until value imports are available
                    /// in the component model, this import function should return the same
                    /// values each time it is called.
                    fn get_environment(
                        &mut self,
                    ) -> wasmtime::Result<Vec<(String, String)>>;
                    /// Get the POSIX-style arguments to the program.
                    fn get_arguments(&mut self) -> wasmtime::Result<Vec<String>>;
                    /// Return a path that programs should use as their initial current working
                    /// directory, interpreting `.` as shorthand for this.
                    fn initial_cwd(&mut self) -> wasmtime::Result<Option<String>>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:cli/environment@0.2.0")?;
                    inst.func_wrap(
                        "get-environment",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::get_environment(host);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "get-arguments",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::get_arguments(host);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "initial-cwd",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::initial_cwd(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
            #[allow(clippy::all)]
            pub mod stdin {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type InputStream = super::super::super::wasi::io::streams::InputStream;
                pub trait Host {
                    fn get_stdin(
                        &mut self,
                    ) -> wasmtime::Result<wasmtime::component::Resource<InputStream>>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:cli/stdin@0.2.0")?;
                    inst.func_wrap(
                        "get-stdin",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::get_stdin(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
            #[allow(clippy::all)]
            pub mod stdout {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
                pub trait Host {
                    fn get_stdout(
                        &mut self,
                    ) -> wasmtime::Result<wasmtime::component::Resource<OutputStream>>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:cli/stdout@0.2.0")?;
                    inst.func_wrap(
                        "get-stdout",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::get_stdout(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
            #[allow(clippy::all)]
            pub mod stderr {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
                pub trait Host {
                    fn get_stderr(
                        &mut self,
                    ) -> wasmtime::Result<wasmtime::component::Resource<OutputStream>>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:cli/stderr@0.2.0")?;
                    inst.func_wrap(
                        "get-stderr",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::get_stderr(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod clocks {
            #[allow(clippy::all)]
            pub mod monotonic_clock {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                /// Hermes does not support `poll`
                /// use wasi:io/poll@0.2.0.{pollable};
                /// An instant in time, in nanoseconds. An instant is relative to an
                /// unspecified initial value, and can only be compared to instances from
                /// the same monotonic-clock.
                pub type Instant = u64;
                const _: () = {
                    if !(8 == <Instant as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Instant as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <Instant as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Instant as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// A duration of time, in nanoseconds.
                pub type Duration = u64;
                const _: () = {
                    if !(8 == <Duration as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Duration as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <Duration as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Duration as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {
                    /// Read the current value of the clock.
                    ///
                    /// The clock is monotonic, therefore calling this function repeatedly will
                    /// produce a sequence of non-decreasing values.
                    fn now(&mut self) -> wasmtime::Result<Instant>;
                    /// Query the resolution of the clock. Returns the duration of time
                    /// corresponding to a clock tick.
                    fn resolution(&mut self) -> wasmtime::Result<Duration>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:clocks/monotonic-clock@0.2.0")?;
                    inst.func_wrap(
                        "now",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::now(host);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "resolution",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::resolution(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
            #[allow(clippy::all)]
            pub mod wall_clock {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                /// A time and date in seconds plus nanoseconds.
                #[component(record)]
                pub struct Datetime {
                    #[component(name = "seconds")]
                    pub seconds: u64,
                    #[component(name = "nanoseconds")]
                    pub nanoseconds: u32,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Datetime {}
                #[automatically_derived]
                impl ::core::clone::Clone for Datetime {
                    #[inline]
                    fn clone(&self) -> Datetime {
                        let _: ::core::clone::AssertParamIsClone<u64>;
                        let _: ::core::clone::AssertParamIsClone<u32>;
                        *self
                    }
                }
                unsafe impl wasmtime::component::Lower for Datetime {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::lower(
                            &self.seconds,
                            cx,
                            ty.fields[0usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).seconds)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.nanoseconds,
                            cx,
                            ty.fields[1usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).nanoseconds)
                                    }
                                }
                            },
                        )?;
                        Ok(())
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::store(
                            &self.seconds,
                            cx,
                            ty.fields[0usize].ty,
                            <u64 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.nanoseconds,
                            cx,
                            ty.fields[1usize].ty,
                            <u32 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for Datetime {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(Self {
                            seconds: <u64 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[0usize].ty,
                                &src.seconds,
                            )?,
                            nanoseconds: <u32 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[1usize].ty,
                                &src.nanoseconds,
                            )?,
                        })
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let mut offset = 0;
                        Ok(Self {
                            seconds: <u64 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[0usize].ty,
                                &bytes[<u64 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u64 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            nanoseconds: <u32 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[1usize].ty,
                                &bytes[<u32 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u32 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                        })
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerDatetime<T0: Copy, T1: Copy> {
                        seconds: T0,
                        nanoseconds: T1,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::clone::Clone + Copy,
                        T1: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerDatetime<T0, T1> {
                        #[inline]
                        fn clone(&self) -> LowerDatetime<T0, T1> {
                            LowerDatetime {
                                seconds: ::core::clone::Clone::clone(&self.seconds),
                                nanoseconds: ::core::clone::Clone::clone(&self.nanoseconds),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::marker::Copy + Copy,
                        T1: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy for LowerDatetime<T0, T1> {}
                    unsafe impl wasmtime::component::ComponentType for Datetime {
                        type Lower = LowerDatetime<
                            <u64 as wasmtime::component::ComponentType>::Lower,
                            <u32 as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[
                                <u64 as wasmtime::component::ComponentType>::ABI,
                                <u32 as wasmtime::component::ComponentType>::ABI,
                            ],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_record(
                                ty,
                                types,
                                &[
                                    (
                                        "seconds",
                                        <u64 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "nanoseconds",
                                        <u32 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ],
                            )
                        }
                    }
                };
                impl core::fmt::Debug for Datetime {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("Datetime")
                            .field("seconds", &self.seconds)
                            .field("nanoseconds", &self.nanoseconds)
                            .finish()
                    }
                }
                const _: () = {
                    if !(16 == <Datetime as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 16 == <Datetime as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <Datetime as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Datetime as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {
                    /// Read the current value of the clock.
                    ///
                    /// This clock is not monotonic, therefore calling this function repeatedly
                    /// will not necessarily produce a sequence of non-decreasing values.
                    ///
                    /// The returned timestamps represent the number of seconds since
                    /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
                    /// also known as [Unix Time].
                    ///
                    /// The nanoseconds field of the output is always less than 1000000000.
                    ///
                    /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
                    /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
                    fn now(&mut self) -> wasmtime::Result<Datetime>;
                    /// Query the resolution of the clock.
                    ///
                    /// The nanoseconds field of the output is always less than 1000000000.
                    fn resolution(&mut self) -> wasmtime::Result<Datetime>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:clocks/wall-clock@0.2.0")?;
                    inst.func_wrap(
                        "now",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::now(host);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "resolution",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::resolution(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod filesystem {
            #[allow(clippy::all)]
            pub mod types {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type InputStream = super::super::super::wasi::io::streams::InputStream;
                pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
                pub type Error = super::super::super::wasi::io::streams::Error;
                pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
                const _: () = {
                    if !(16 == <Datetime as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 16 == <Datetime as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <Datetime as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Datetime as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// File size or length of a region within a file.
                pub type Filesize = u64;
                const _: () = {
                    if !(8 == <Filesize as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Filesize as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <Filesize as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Filesize as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// The type of a filesystem object referenced by a descriptor.
                ///
                /// Note: This was called `filetype` in earlier versions of WASI.
                #[component(enum)]
                pub enum DescriptorType {
                    /// The type of the descriptor or file is unknown or is different from
                    /// any of the other types specified.
                    #[component(name = "unknown")]
                    Unknown,
                    /// The descriptor refers to a block device inode.
                    #[component(name = "block-device")]
                    BlockDevice,
                    /// The descriptor refers to a character device inode.
                    #[component(name = "character-device")]
                    CharacterDevice,
                    /// The descriptor refers to a directory inode.
                    #[component(name = "directory")]
                    Directory,
                    /// The descriptor refers to a named pipe.
                    #[component(name = "fifo")]
                    Fifo,
                    /// The file refers to a symbolic link inode.
                    #[component(name = "symbolic-link")]
                    SymbolicLink,
                    /// The descriptor refers to a regular file inode.
                    #[component(name = "regular-file")]
                    RegularFile,
                    /// The descriptor refers to a socket.
                    #[component(name = "socket")]
                    Socket,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for DescriptorType {
                    #[inline]
                    fn clone(&self) -> DescriptorType {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for DescriptorType {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for DescriptorType {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for DescriptorType {
                    #[inline]
                    fn eq(&self, other: &DescriptorType) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for DescriptorType {}
                #[automatically_derived]
                impl ::core::cmp::Eq for DescriptorType {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                unsafe impl wasmtime::component::Lower for DescriptorType {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::Unknown => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Unknown)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::BlockDevice => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).BlockDevice)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::CharacterDevice => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).CharacterDevice)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Directory => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(3u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Directory)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Fifo => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(4u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Fifo)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::SymbolicLink => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(5u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).SymbolicLink)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::RegularFile => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(6u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).RegularFile)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Socket => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(7u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Socket)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::Unknown => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::BlockDevice => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                            Self::CharacterDevice => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Directory => {
                                *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Fifo => {
                                *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                                Ok(())
                            }
                            Self::SymbolicLink => {
                                *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                                Ok(())
                            }
                            Self::RegularFile => {
                                *cx.get::<1usize>(offset) = 6u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Socket => {
                                *cx.get::<1usize>(offset) = 7u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for DescriptorType {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::Unknown,
                                1u32 => Self::BlockDevice,
                                2u32 => Self::CharacterDevice,
                                3u32 => Self::Directory,
                                4u32 => Self::Fifo,
                                5u32 => Self::SymbolicLink,
                                6u32 => Self::RegularFile,
                                7u32 => Self::Socket,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::Unknown,
                                1u8 => Self::BlockDevice,
                                2u8 => Self::CharacterDevice,
                                3u8 => Self::Directory,
                                4u8 => Self::Fifo,
                                5u8 => Self::SymbolicLink,
                                6u8 => Self::RegularFile,
                                7u8 => Self::Socket,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerDescriptorType {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadDescriptorType,
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for LowerDescriptorType {
                        #[inline]
                        fn clone(&self) -> LowerDescriptorType {
                            let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                            let _: ::core::clone::AssertParamIsClone<
                                LowerPayloadDescriptorType,
                            >;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for LowerDescriptorType {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadDescriptorType {
                        Unknown: [wasmtime::ValRaw; 0],
                        BlockDevice: [wasmtime::ValRaw; 0],
                        CharacterDevice: [wasmtime::ValRaw; 0],
                        Directory: [wasmtime::ValRaw; 0],
                        Fifo: [wasmtime::ValRaw; 0],
                        SymbolicLink: [wasmtime::ValRaw; 0],
                        RegularFile: [wasmtime::ValRaw; 0],
                        Socket: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::clone::Clone for LowerPayloadDescriptorType {
                        #[inline]
                        fn clone(&self) -> LowerPayloadDescriptorType {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::marker::Copy for LowerPayloadDescriptorType {}
                    unsafe impl wasmtime::component::ComponentType for DescriptorType {
                        type Lower = LowerDescriptorType;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_enum(
                                ty,
                                types,
                                &[
                                    "unknown",
                                    "block-device",
                                    "character-device",
                                    "directory",
                                    "fifo",
                                    "symbolic-link",
                                    "regular-file",
                                    "socket",
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[None, None, None, None, None, None, None, None],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for DescriptorType {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[None, None, None, None, None, None, None, None];
                    }
                };
                impl core::fmt::Debug for DescriptorType {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            DescriptorType::Unknown => {
                                f.debug_tuple("DescriptorType::Unknown").finish()
                            }
                            DescriptorType::BlockDevice => {
                                f.debug_tuple("DescriptorType::BlockDevice").finish()
                            }
                            DescriptorType::CharacterDevice => {
                                f.debug_tuple("DescriptorType::CharacterDevice").finish()
                            }
                            DescriptorType::Directory => {
                                f.debug_tuple("DescriptorType::Directory").finish()
                            }
                            DescriptorType::Fifo => {
                                f.debug_tuple("DescriptorType::Fifo").finish()
                            }
                            DescriptorType::SymbolicLink => {
                                f.debug_tuple("DescriptorType::SymbolicLink").finish()
                            }
                            DescriptorType::RegularFile => {
                                f.debug_tuple("DescriptorType::RegularFile").finish()
                            }
                            DescriptorType::Socket => {
                                f.debug_tuple("DescriptorType::Socket").finish()
                            }
                        }
                    }
                }
                const _: () = {
                    if !(1
                        == <DescriptorType as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <DescriptorType as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1
                        == <DescriptorType as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <DescriptorType as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub struct DescriptorFlags {
                    #[doc(hidden)]
                    __inner0: u8,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for DescriptorFlags {}
                #[automatically_derived]
                impl ::core::clone::Clone for DescriptorFlags {
                    #[inline]
                    fn clone(&self) -> DescriptorFlags {
                        let _: ::core::clone::AssertParamIsClone<u8>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for DescriptorFlags {
                    #[inline]
                    fn default() -> DescriptorFlags {
                        DescriptorFlags {
                            __inner0: ::core::default::Default::default(),
                        }
                    }
                }
                impl DescriptorFlags {
                    pub const READ: Self = Self { __inner0: 1u8 };
                    pub const WRITE: Self = Self { __inner0: 2u8 };
                    pub const FILE_INTEGRITY_SYNC: Self = Self { __inner0: 4u8 };
                    pub const DATA_INTEGRITY_SYNC: Self = Self { __inner0: 8u8 };
                    pub const REQUESTED_WRITE_SYNC: Self = Self { __inner0: 16u8 };
                    pub const MUTATE_DIRECTORY: Self = Self { __inner0: 32u8 };
                    pub fn as_array(&self) -> [u32; 1usize] {
                        [self.__inner0 as u32]
                    }
                    pub fn empty() -> Self {
                        Self::default()
                    }
                    pub fn all() -> Self {
                        use std::ops::Not;
                        Self::default().not()
                    }
                    pub fn contains(&self, other: Self) -> bool {
                        *self & other == other
                    }
                    pub fn intersects(&self, other: Self) -> bool {
                        *self & other != Self::empty()
                    }
                }
                impl std::cmp::PartialEq for DescriptorFlags {
                    fn eq(&self, rhs: &DescriptorFlags) -> bool {
                        (self.__inner0 & 63u8).eq(&(rhs.__inner0 & 63u8))
                    }
                }
                impl std::cmp::Eq for DescriptorFlags {}
                impl std::fmt::Debug for DescriptorFlags {
                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                        wasmtime::component::__internal::format_flags(
                            &self.as_array(),
                            &[
                                "READ",
                                "WRITE",
                                "FILE_INTEGRITY_SYNC",
                                "DATA_INTEGRITY_SYNC",
                                "REQUESTED_WRITE_SYNC",
                                "MUTATE_DIRECTORY",
                            ],
                            f,
                        )
                    }
                }
                impl std::ops::BitOr for DescriptorFlags {
                    type Output = DescriptorFlags;
                    fn bitor(self, rhs: DescriptorFlags) -> DescriptorFlags {
                        Self {
                            __inner0: self.__inner0.bitor(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitOrAssign for DescriptorFlags {
                    fn bitor_assign(&mut self, rhs: DescriptorFlags) {
                        self.__inner0.bitor_assign(rhs.__inner0)
                    }
                }
                impl std::ops::BitAnd for DescriptorFlags {
                    type Output = DescriptorFlags;
                    fn bitand(self, rhs: DescriptorFlags) -> DescriptorFlags {
                        Self {
                            __inner0: self.__inner0.bitand(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitAndAssign for DescriptorFlags {
                    fn bitand_assign(&mut self, rhs: DescriptorFlags) {
                        self.__inner0.bitand_assign(rhs.__inner0)
                    }
                }
                impl std::ops::BitXor for DescriptorFlags {
                    type Output = DescriptorFlags;
                    fn bitxor(self, rhs: DescriptorFlags) -> DescriptorFlags {
                        Self {
                            __inner0: self.__inner0.bitxor(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitXorAssign for DescriptorFlags {
                    fn bitxor_assign(&mut self, rhs: DescriptorFlags) {
                        self.__inner0.bitxor_assign(rhs.__inner0)
                    }
                }
                impl std::ops::Not for DescriptorFlags {
                    type Output = DescriptorFlags;
                    fn not(self) -> DescriptorFlags {
                        Self {
                            __inner0: self.__inner0.not(),
                        }
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerDescriptorFlags<T0: Copy> {
                        __inner0: T0,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<T0: ::core::clone::Clone + Copy> ::core::clone::Clone
                    for LowerDescriptorFlags<T0> {
                        #[inline]
                        fn clone(&self) -> LowerDescriptorFlags<T0> {
                            LowerDescriptorFlags {
                                __inner0: ::core::clone::Clone::clone(&self.__inner0),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<T0: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerDescriptorFlags<T0> {}
                    unsafe impl wasmtime::component::ComponentType for DescriptorFlags {
                        type Lower = LowerDescriptorFlags<
                            <u8 as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[<u8 as wasmtime::component::ComponentType>::ABI],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_flags(
                                ty,
                                types,
                                &[
                                    "read",
                                    "write",
                                    "file-integrity-sync",
                                    "data-integrity-sync",
                                    "requested-write-sync",
                                    "mutate-directory",
                                ],
                            )
                        }
                    }
                };
                unsafe impl wasmtime::component::Lower for DescriptorFlags {
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        self.__inner0
                            .lower(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).__inner0)
                                        }
                                    }
                                },
                            )?;
                        Ok(())
                    }
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        self.__inner0
                            .store(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                offset,
                            )?;
                        offset += std::mem::size_of_val(&self.__inner0);
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for DescriptorFlags {
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        Ok(Self {
                            __inner0: wasmtime::component::Lift::lift(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                &src.__inner0,
                            )?,
                        })
                    }
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let (field, bytes) = bytes.split_at(1usize);
                        let __inner0 = wasmtime::component::Lift::load(
                            cx,
                            wasmtime::component::__internal::InterfaceType::U8,
                            field,
                        )?;
                        Ok(Self { __inner0 })
                    }
                }
                const _: () = {
                    if !(1
                        == <DescriptorFlags as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <DescriptorFlags as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1
                        == <DescriptorFlags as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <DescriptorFlags as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub struct PathFlags {
                    #[doc(hidden)]
                    __inner0: u8,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PathFlags {}
                #[automatically_derived]
                impl ::core::clone::Clone for PathFlags {
                    #[inline]
                    fn clone(&self) -> PathFlags {
                        let _: ::core::clone::AssertParamIsClone<u8>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for PathFlags {
                    #[inline]
                    fn default() -> PathFlags {
                        PathFlags {
                            __inner0: ::core::default::Default::default(),
                        }
                    }
                }
                impl PathFlags {
                    pub const SYMLINK_FOLLOW: Self = Self { __inner0: 1u8 };
                    pub fn as_array(&self) -> [u32; 1usize] {
                        [self.__inner0 as u32]
                    }
                    pub fn empty() -> Self {
                        Self::default()
                    }
                    pub fn all() -> Self {
                        use std::ops::Not;
                        Self::default().not()
                    }
                    pub fn contains(&self, other: Self) -> bool {
                        *self & other == other
                    }
                    pub fn intersects(&self, other: Self) -> bool {
                        *self & other != Self::empty()
                    }
                }
                impl std::cmp::PartialEq for PathFlags {
                    fn eq(&self, rhs: &PathFlags) -> bool {
                        (self.__inner0 & 1u8).eq(&(rhs.__inner0 & 1u8))
                    }
                }
                impl std::cmp::Eq for PathFlags {}
                impl std::fmt::Debug for PathFlags {
                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                        wasmtime::component::__internal::format_flags(
                            &self.as_array(),
                            &["SYMLINK_FOLLOW"],
                            f,
                        )
                    }
                }
                impl std::ops::BitOr for PathFlags {
                    type Output = PathFlags;
                    fn bitor(self, rhs: PathFlags) -> PathFlags {
                        Self {
                            __inner0: self.__inner0.bitor(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitOrAssign for PathFlags {
                    fn bitor_assign(&mut self, rhs: PathFlags) {
                        self.__inner0.bitor_assign(rhs.__inner0)
                    }
                }
                impl std::ops::BitAnd for PathFlags {
                    type Output = PathFlags;
                    fn bitand(self, rhs: PathFlags) -> PathFlags {
                        Self {
                            __inner0: self.__inner0.bitand(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitAndAssign for PathFlags {
                    fn bitand_assign(&mut self, rhs: PathFlags) {
                        self.__inner0.bitand_assign(rhs.__inner0)
                    }
                }
                impl std::ops::BitXor for PathFlags {
                    type Output = PathFlags;
                    fn bitxor(self, rhs: PathFlags) -> PathFlags {
                        Self {
                            __inner0: self.__inner0.bitxor(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitXorAssign for PathFlags {
                    fn bitxor_assign(&mut self, rhs: PathFlags) {
                        self.__inner0.bitxor_assign(rhs.__inner0)
                    }
                }
                impl std::ops::Not for PathFlags {
                    type Output = PathFlags;
                    fn not(self) -> PathFlags {
                        Self {
                            __inner0: self.__inner0.not(),
                        }
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerPathFlags<T0: Copy> {
                        __inner0: T0,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<T0: ::core::clone::Clone + Copy> ::core::clone::Clone
                    for LowerPathFlags<T0> {
                        #[inline]
                        fn clone(&self) -> LowerPathFlags<T0> {
                            LowerPathFlags {
                                __inner0: ::core::clone::Clone::clone(&self.__inner0),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<T0: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerPathFlags<T0> {}
                    unsafe impl wasmtime::component::ComponentType for PathFlags {
                        type Lower = LowerPathFlags<
                            <u8 as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[<u8 as wasmtime::component::ComponentType>::ABI],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_flags(
                                ty,
                                types,
                                &["symlink-follow"],
                            )
                        }
                    }
                };
                unsafe impl wasmtime::component::Lower for PathFlags {
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        self.__inner0
                            .lower(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).__inner0)
                                        }
                                    }
                                },
                            )?;
                        Ok(())
                    }
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        self.__inner0
                            .store(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                offset,
                            )?;
                        offset += std::mem::size_of_val(&self.__inner0);
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for PathFlags {
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        Ok(Self {
                            __inner0: wasmtime::component::Lift::lift(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                &src.__inner0,
                            )?,
                        })
                    }
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let (field, bytes) = bytes.split_at(1usize);
                        let __inner0 = wasmtime::component::Lift::load(
                            cx,
                            wasmtime::component::__internal::InterfaceType::U8,
                            field,
                        )?;
                        Ok(Self { __inner0 })
                    }
                }
                const _: () = {
                    if !(1 == <PathFlags as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <PathFlags as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1 == <PathFlags as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <PathFlags as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub struct OpenFlags {
                    #[doc(hidden)]
                    __inner0: u8,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for OpenFlags {}
                #[automatically_derived]
                impl ::core::clone::Clone for OpenFlags {
                    #[inline]
                    fn clone(&self) -> OpenFlags {
                        let _: ::core::clone::AssertParamIsClone<u8>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for OpenFlags {
                    #[inline]
                    fn default() -> OpenFlags {
                        OpenFlags {
                            __inner0: ::core::default::Default::default(),
                        }
                    }
                }
                impl OpenFlags {
                    pub const CREATE: Self = Self { __inner0: 1u8 };
                    pub const DIRECTORY: Self = Self { __inner0: 2u8 };
                    pub const EXCLUSIVE: Self = Self { __inner0: 4u8 };
                    pub const TRUNCATE: Self = Self { __inner0: 8u8 };
                    pub fn as_array(&self) -> [u32; 1usize] {
                        [self.__inner0 as u32]
                    }
                    pub fn empty() -> Self {
                        Self::default()
                    }
                    pub fn all() -> Self {
                        use std::ops::Not;
                        Self::default().not()
                    }
                    pub fn contains(&self, other: Self) -> bool {
                        *self & other == other
                    }
                    pub fn intersects(&self, other: Self) -> bool {
                        *self & other != Self::empty()
                    }
                }
                impl std::cmp::PartialEq for OpenFlags {
                    fn eq(&self, rhs: &OpenFlags) -> bool {
                        (self.__inner0 & 15u8).eq(&(rhs.__inner0 & 15u8))
                    }
                }
                impl std::cmp::Eq for OpenFlags {}
                impl std::fmt::Debug for OpenFlags {
                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                        wasmtime::component::__internal::format_flags(
                            &self.as_array(),
                            &["CREATE", "DIRECTORY", "EXCLUSIVE", "TRUNCATE"],
                            f,
                        )
                    }
                }
                impl std::ops::BitOr for OpenFlags {
                    type Output = OpenFlags;
                    fn bitor(self, rhs: OpenFlags) -> OpenFlags {
                        Self {
                            __inner0: self.__inner0.bitor(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitOrAssign for OpenFlags {
                    fn bitor_assign(&mut self, rhs: OpenFlags) {
                        self.__inner0.bitor_assign(rhs.__inner0)
                    }
                }
                impl std::ops::BitAnd for OpenFlags {
                    type Output = OpenFlags;
                    fn bitand(self, rhs: OpenFlags) -> OpenFlags {
                        Self {
                            __inner0: self.__inner0.bitand(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitAndAssign for OpenFlags {
                    fn bitand_assign(&mut self, rhs: OpenFlags) {
                        self.__inner0.bitand_assign(rhs.__inner0)
                    }
                }
                impl std::ops::BitXor for OpenFlags {
                    type Output = OpenFlags;
                    fn bitxor(self, rhs: OpenFlags) -> OpenFlags {
                        Self {
                            __inner0: self.__inner0.bitxor(rhs.__inner0),
                        }
                    }
                }
                impl std::ops::BitXorAssign for OpenFlags {
                    fn bitxor_assign(&mut self, rhs: OpenFlags) {
                        self.__inner0.bitxor_assign(rhs.__inner0)
                    }
                }
                impl std::ops::Not for OpenFlags {
                    type Output = OpenFlags;
                    fn not(self) -> OpenFlags {
                        Self {
                            __inner0: self.__inner0.not(),
                        }
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerOpenFlags<T0: Copy> {
                        __inner0: T0,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<T0: ::core::clone::Clone + Copy> ::core::clone::Clone
                    for LowerOpenFlags<T0> {
                        #[inline]
                        fn clone(&self) -> LowerOpenFlags<T0> {
                            LowerOpenFlags {
                                __inner0: ::core::clone::Clone::clone(&self.__inner0),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<T0: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerOpenFlags<T0> {}
                    unsafe impl wasmtime::component::ComponentType for OpenFlags {
                        type Lower = LowerOpenFlags<
                            <u8 as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[<u8 as wasmtime::component::ComponentType>::ABI],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_flags(
                                ty,
                                types,
                                &["create", "directory", "exclusive", "truncate"],
                            )
                        }
                    }
                };
                unsafe impl wasmtime::component::Lower for OpenFlags {
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        self.__inner0
                            .lower(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).__inner0)
                                        }
                                    }
                                },
                            )?;
                        Ok(())
                    }
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        self.__inner0
                            .store(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                offset,
                            )?;
                        offset += std::mem::size_of_val(&self.__inner0);
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for OpenFlags {
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        Ok(Self {
                            __inner0: wasmtime::component::Lift::lift(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                &src.__inner0,
                            )?,
                        })
                    }
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        _ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let (field, bytes) = bytes.split_at(1usize);
                        let __inner0 = wasmtime::component::Lift::load(
                            cx,
                            wasmtime::component::__internal::InterfaceType::U8,
                            field,
                        )?;
                        Ok(Self { __inner0 })
                    }
                }
                const _: () = {
                    if !(1 == <OpenFlags as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <OpenFlags as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1 == <OpenFlags as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <OpenFlags as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Number of hard links to an inode.
                pub type LinkCount = u64;
                const _: () = {
                    if !(8 == <LinkCount as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <LinkCount as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <LinkCount as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <LinkCount as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// File attributes.
                ///
                /// Note: This was called `filestat` in earlier versions of WASI.
                #[component(record)]
                pub struct DescriptorStat {
                    /// File type.
                    #[component(name = "type")]
                    pub type_: DescriptorType,
                    /// Number of hard links to the file.
                    #[component(name = "link-count")]
                    pub link_count: LinkCount,
                    /// For regular files, the file size in bytes. For symbolic links, the
                    /// length in bytes of the pathname contained in the symbolic link.
                    #[component(name = "size")]
                    pub size: Filesize,
                    /// Last data access timestamp.
                    ///
                    /// If the `option` is none, the platform doesn't maintain an access
                    /// timestamp for this file.
                    #[component(name = "data-access-timestamp")]
                    pub data_access_timestamp: Option<Datetime>,
                    /// Last data modification timestamp.
                    ///
                    /// If the `option` is none, the platform doesn't maintain a
                    /// modification timestamp for this file.
                    #[component(name = "data-modification-timestamp")]
                    pub data_modification_timestamp: Option<Datetime>,
                    /// Last file status-change timestamp.
                    ///
                    /// If the `option` is none, the platform doesn't maintain a
                    /// status-change timestamp for this file.
                    #[component(name = "status-change-timestamp")]
                    pub status_change_timestamp: Option<Datetime>,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for DescriptorStat {}
                #[automatically_derived]
                impl ::core::clone::Clone for DescriptorStat {
                    #[inline]
                    fn clone(&self) -> DescriptorStat {
                        let _: ::core::clone::AssertParamIsClone<DescriptorType>;
                        let _: ::core::clone::AssertParamIsClone<LinkCount>;
                        let _: ::core::clone::AssertParamIsClone<Filesize>;
                        let _: ::core::clone::AssertParamIsClone<Option<Datetime>>;
                        let _: ::core::clone::AssertParamIsClone<Option<Datetime>>;
                        let _: ::core::clone::AssertParamIsClone<Option<Datetime>>;
                        *self
                    }
                }
                unsafe impl wasmtime::component::Lower for DescriptorStat {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::lower(
                            &self.type_,
                            cx,
                            ty.fields[0usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).type_)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.link_count,
                            cx,
                            ty.fields[1usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).link_count)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.size,
                            cx,
                            ty.fields[2usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).size)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.data_access_timestamp,
                            cx,
                            ty.fields[3usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).data_access_timestamp)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.data_modification_timestamp,
                            cx,
                            ty.fields[4usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).data_modification_timestamp)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.status_change_timestamp,
                            cx,
                            ty.fields[5usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).status_change_timestamp)
                                    }
                                }
                            },
                        )?;
                        Ok(())
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::store(
                            &self.type_,
                            cx,
                            ty.fields[0usize].ty,
                            <DescriptorType as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.link_count,
                            cx,
                            ty.fields[1usize].ty,
                            <LinkCount as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.size,
                            cx,
                            ty.fields[2usize].ty,
                            <Filesize as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.data_access_timestamp,
                            cx,
                            ty.fields[3usize].ty,
                            <Option<Datetime> as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.data_modification_timestamp,
                            cx,
                            ty.fields[4usize].ty,
                            <Option<Datetime> as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.status_change_timestamp,
                            cx,
                            ty.fields[5usize].ty,
                            <Option<Datetime> as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for DescriptorStat {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(Self {
                            type_: <DescriptorType as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[0usize].ty,
                                &src.type_,
                            )?,
                            link_count: <LinkCount as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[1usize].ty,
                                &src.link_count,
                            )?,
                            size: <Filesize as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[2usize].ty,
                                &src.size,
                            )?,
                            data_access_timestamp: <Option<
                                Datetime,
                            > as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[3usize].ty,
                                &src.data_access_timestamp,
                            )?,
                            data_modification_timestamp: <Option<
                                Datetime,
                            > as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[4usize].ty,
                                &src.data_modification_timestamp,
                            )?,
                            status_change_timestamp: <Option<
                                Datetime,
                            > as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[5usize].ty,
                                &src.status_change_timestamp,
                            )?,
                        })
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let mut offset = 0;
                        Ok(Self {
                            type_: <DescriptorType as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[0usize].ty,
                                &bytes[<DescriptorType as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<DescriptorType as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            link_count: <LinkCount as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[1usize].ty,
                                &bytes[<LinkCount as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<LinkCount as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            size: <Filesize as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[2usize].ty,
                                &bytes[<Filesize as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<Filesize as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            data_access_timestamp: <Option<
                                Datetime,
                            > as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[3usize].ty,
                                &bytes[<Option<
                                    Datetime,
                                > as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<Option<
                                    Datetime,
                                > as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            data_modification_timestamp: <Option<
                                Datetime,
                            > as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[4usize].ty,
                                &bytes[<Option<
                                    Datetime,
                                > as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<Option<
                                    Datetime,
                                > as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            status_change_timestamp: <Option<
                                Datetime,
                            > as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[5usize].ty,
                                &bytes[<Option<
                                    Datetime,
                                > as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<Option<
                                    Datetime,
                                > as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                        })
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerDescriptorStat<
                        T0: Copy,
                        T1: Copy,
                        T2: Copy,
                        T3: Copy,
                        T4: Copy,
                        T5: Copy,
                    > {
                        type_: T0,
                        link_count: T1,
                        size: T2,
                        data_access_timestamp: T3,
                        data_modification_timestamp: T4,
                        status_change_timestamp: T5,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::clone::Clone + Copy,
                        T1: ::core::clone::Clone + Copy,
                        T2: ::core::clone::Clone + Copy,
                        T3: ::core::clone::Clone + Copy,
                        T4: ::core::clone::Clone + Copy,
                        T5: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone
                    for LowerDescriptorStat<T0, T1, T2, T3, T4, T5> {
                        #[inline]
                        fn clone(&self) -> LowerDescriptorStat<T0, T1, T2, T3, T4, T5> {
                            LowerDescriptorStat {
                                type_: ::core::clone::Clone::clone(&self.type_),
                                link_count: ::core::clone::Clone::clone(&self.link_count),
                                size: ::core::clone::Clone::clone(&self.size),
                                data_access_timestamp: ::core::clone::Clone::clone(
                                    &self.data_access_timestamp,
                                ),
                                data_modification_timestamp: ::core::clone::Clone::clone(
                                    &self.data_modification_timestamp,
                                ),
                                status_change_timestamp: ::core::clone::Clone::clone(
                                    &self.status_change_timestamp,
                                ),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::marker::Copy + Copy,
                        T1: ::core::marker::Copy + Copy,
                        T2: ::core::marker::Copy + Copy,
                        T3: ::core::marker::Copy + Copy,
                        T4: ::core::marker::Copy + Copy,
                        T5: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy
                    for LowerDescriptorStat<T0, T1, T2, T3, T4, T5> {}
                    unsafe impl wasmtime::component::ComponentType for DescriptorStat {
                        type Lower = LowerDescriptorStat<
                            <DescriptorType as wasmtime::component::ComponentType>::Lower,
                            <LinkCount as wasmtime::component::ComponentType>::Lower,
                            <Filesize as wasmtime::component::ComponentType>::Lower,
                            <Option<
                                Datetime,
                            > as wasmtime::component::ComponentType>::Lower,
                            <Option<
                                Datetime,
                            > as wasmtime::component::ComponentType>::Lower,
                            <Option<
                                Datetime,
                            > as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[
                                <DescriptorType as wasmtime::component::ComponentType>::ABI,
                                <LinkCount as wasmtime::component::ComponentType>::ABI,
                                <Filesize as wasmtime::component::ComponentType>::ABI,
                                <Option<
                                    Datetime,
                                > as wasmtime::component::ComponentType>::ABI,
                                <Option<
                                    Datetime,
                                > as wasmtime::component::ComponentType>::ABI,
                                <Option<
                                    Datetime,
                                > as wasmtime::component::ComponentType>::ABI,
                            ],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_record(
                                ty,
                                types,
                                &[
                                    (
                                        "type",
                                        <DescriptorType as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "link-count",
                                        <LinkCount as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "size",
                                        <Filesize as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "data-access-timestamp",
                                        <Option<
                                            Datetime,
                                        > as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "data-modification-timestamp",
                                        <Option<
                                            Datetime,
                                        > as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "status-change-timestamp",
                                        <Option<
                                            Datetime,
                                        > as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ],
                            )
                        }
                    }
                };
                impl core::fmt::Debug for DescriptorStat {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("DescriptorStat")
                            .field("type", &self.type_)
                            .field("link-count", &self.link_count)
                            .field("size", &self.size)
                            .field("data-access-timestamp", &self.data_access_timestamp)
                            .field(
                                "data-modification-timestamp",
                                &self.data_modification_timestamp,
                            )
                            .field(
                                "status-change-timestamp",
                                &self.status_change_timestamp,
                            )
                            .finish()
                    }
                }
                const _: () = {
                    if !(96
                        == <DescriptorStat as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 96 == <DescriptorStat as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8
                        == <DescriptorStat as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <DescriptorStat as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// When setting a timestamp, this gives the value to set it to.
                #[component(variant)]
                pub enum NewTimestamp {
                    /// Leave the timestamp set to its previous value.
                    #[component(name = "no-change")]
                    NoChange,
                    /// Set the timestamp to the current time of the system clock associated
                    /// with the filesystem.
                    #[component(name = "now")]
                    Now,
                    /// Set the timestamp to the given value.
                    #[component(name = "timestamp")]
                    Timestamp(Datetime),
                }
                #[automatically_derived]
                impl ::core::marker::Copy for NewTimestamp {}
                #[automatically_derived]
                impl ::core::clone::Clone for NewTimestamp {
                    #[inline]
                    fn clone(&self) -> NewTimestamp {
                        let _: ::core::clone::AssertParamIsClone<Datetime>;
                        *self
                    }
                }
                unsafe impl wasmtime::component::Lower for NewTimestamp {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::NoChange => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NoChange)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Now => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Now)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Timestamp(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Timestamp)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[2usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::NoChange => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Now => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Timestamp(value) => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for NewTimestamp {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::NoChange,
                                1u32 => Self::Now,
                                2u32 => {
                                    Self::Timestamp(
                                        <Datetime as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[2usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.Timestamp },
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::NoChange,
                                1u8 => Self::Now,
                                2u8 => {
                                    Self::Timestamp(
                                        <Datetime as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[2usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Datetime as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerNewTimestamp<T2: Copy> {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadNewTimestamp<T2>,
                    }
                    #[automatically_derived]
                    impl<T2: ::core::clone::Clone + Copy> ::core::clone::Clone
                    for LowerNewTimestamp<T2> {
                        #[inline]
                        fn clone(&self) -> LowerNewTimestamp<T2> {
                            LowerNewTimestamp {
                                tag: ::core::clone::Clone::clone(&self.tag),
                                payload: ::core::clone::Clone::clone(&self.payload),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<T2: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerNewTimestamp<T2> {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadNewTimestamp<T2: Copy> {
                        NoChange: [wasmtime::ValRaw; 0],
                        Now: [wasmtime::ValRaw; 0],
                        Timestamp: T2,
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<
                        T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerPayloadNewTimestamp<T2> {
                        #[inline]
                        fn clone(&self) -> LowerPayloadNewTimestamp<T2> {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<T2: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerPayloadNewTimestamp<T2> {}
                    unsafe impl wasmtime::component::ComponentType for NewTimestamp {
                        type Lower = LowerNewTimestamp<
                            <Datetime as wasmtime::component::ComponentType>::Lower,
                        >;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_variant(
                                ty,
                                types,
                                &[
                                    ("no-change", None),
                                    ("now", None),
                                    (
                                        "timestamp",
                                        Some(
                                            <Datetime as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[
                                None,
                                None,
                                Some(<Datetime as wasmtime::component::ComponentType>::ABI),
                            ],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for NewTimestamp {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[
                            None,
                            None,
                            Some(<Datetime as wasmtime::component::ComponentType>::ABI),
                        ];
                    }
                };
                impl core::fmt::Debug for NewTimestamp {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            NewTimestamp::NoChange => {
                                f.debug_tuple("NewTimestamp::NoChange").finish()
                            }
                            NewTimestamp::Now => {
                                f.debug_tuple("NewTimestamp::Now").finish()
                            }
                            NewTimestamp::Timestamp(e) => {
                                f.debug_tuple("NewTimestamp::Timestamp").field(e).finish()
                            }
                        }
                    }
                }
                const _: () = {
                    if !(24
                        == <NewTimestamp as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 24 == <NewTimestamp as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8
                        == <NewTimestamp as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <NewTimestamp as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// A directory entry.
                #[component(record)]
                pub struct DirectoryEntry {
                    /// The type of the file referred to by this directory entry.
                    #[component(name = "type")]
                    pub type_: DescriptorType,
                    /// The name of the object.
                    #[component(name = "name")]
                    pub name: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for DirectoryEntry {
                    #[inline]
                    fn clone(&self) -> DirectoryEntry {
                        DirectoryEntry {
                            type_: ::core::clone::Clone::clone(&self.type_),
                            name: ::core::clone::Clone::clone(&self.name),
                        }
                    }
                }
                unsafe impl wasmtime::component::Lower for DirectoryEntry {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::lower(
                            &self.type_,
                            cx,
                            ty.fields[0usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).type_)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.name,
                            cx,
                            ty.fields[1usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).name)
                                    }
                                }
                            },
                        )?;
                        Ok(())
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::store(
                            &self.type_,
                            cx,
                            ty.fields[0usize].ty,
                            <DescriptorType as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.name,
                            cx,
                            ty.fields[1usize].ty,
                            <String as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for DirectoryEntry {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(Self {
                            type_: <DescriptorType as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[0usize].ty,
                                &src.type_,
                            )?,
                            name: <String as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[1usize].ty,
                                &src.name,
                            )?,
                        })
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let mut offset = 0;
                        Ok(Self {
                            type_: <DescriptorType as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[0usize].ty,
                                &bytes[<DescriptorType as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<DescriptorType as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            name: <String as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[1usize].ty,
                                &bytes[<String as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<String as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                        })
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerDirectoryEntry<T0: Copy, T1: Copy> {
                        type_: T0,
                        name: T1,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::clone::Clone + Copy,
                        T1: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerDirectoryEntry<T0, T1> {
                        #[inline]
                        fn clone(&self) -> LowerDirectoryEntry<T0, T1> {
                            LowerDirectoryEntry {
                                type_: ::core::clone::Clone::clone(&self.type_),
                                name: ::core::clone::Clone::clone(&self.name),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::marker::Copy + Copy,
                        T1: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy for LowerDirectoryEntry<T0, T1> {}
                    unsafe impl wasmtime::component::ComponentType for DirectoryEntry {
                        type Lower = LowerDirectoryEntry<
                            <DescriptorType as wasmtime::component::ComponentType>::Lower,
                            <String as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[
                                <DescriptorType as wasmtime::component::ComponentType>::ABI,
                                <String as wasmtime::component::ComponentType>::ABI,
                            ],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_record(
                                ty,
                                types,
                                &[
                                    (
                                        "type",
                                        <DescriptorType as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "name",
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ],
                            )
                        }
                    }
                };
                impl core::fmt::Debug for DirectoryEntry {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("DirectoryEntry")
                            .field("type", &self.type_)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                const _: () = {
                    if !(12
                        == <DirectoryEntry as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 12 == <DirectoryEntry as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4
                        == <DirectoryEntry as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <DirectoryEntry as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Error codes returned by functions, similar to `errno` in POSIX.
                /// Not all of these error codes are returned by the functions provided by this
                /// API; some are used in higher-level library layers, and others are provided
                /// merely for alignment with POSIX.
                #[component(enum)]
                pub enum ErrorCode {
                    /// Permission denied, similar to `EACCES` in POSIX.
                    #[component(name = "access")]
                    Access,
                    /// Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX.
                    #[component(name = "would-block")]
                    WouldBlock,
                    /// Connection already in progress, similar to `EALREADY` in POSIX.
                    #[component(name = "already")]
                    Already,
                    /// Bad descriptor, similar to `EBADF` in POSIX.
                    #[component(name = "bad-descriptor")]
                    BadDescriptor,
                    /// Device or resource busy, similar to `EBUSY` in POSIX.
                    #[component(name = "busy")]
                    Busy,
                    /// Resource deadlock would occur, similar to `EDEADLK` in POSIX.
                    #[component(name = "deadlock")]
                    Deadlock,
                    /// Storage quota exceeded, similar to `EDQUOT` in POSIX.
                    #[component(name = "quota")]
                    Quota,
                    /// File exists, similar to `EEXIST` in POSIX.
                    #[component(name = "exist")]
                    Exist,
                    /// File too large, similar to `EFBIG` in POSIX.
                    #[component(name = "file-too-large")]
                    FileTooLarge,
                    /// Illegal byte sequence, similar to `EILSEQ` in POSIX.
                    #[component(name = "illegal-byte-sequence")]
                    IllegalByteSequence,
                    /// Operation in progress, similar to `EINPROGRESS` in POSIX.
                    #[component(name = "in-progress")]
                    InProgress,
                    /// Interrupted function, similar to `EINTR` in POSIX.
                    #[component(name = "interrupted")]
                    Interrupted,
                    /// Invalid argument, similar to `EINVAL` in POSIX.
                    #[component(name = "invalid")]
                    Invalid,
                    /// I/O error, similar to `EIO` in POSIX.
                    #[component(name = "io")]
                    Io,
                    /// Is a directory, similar to `EISDIR` in POSIX.
                    #[component(name = "is-directory")]
                    IsDirectory,
                    /// Too many levels of symbolic links, similar to `ELOOP` in POSIX.
                    #[component(name = "loop")]
                    Loop,
                    /// Too many links, similar to `EMLINK` in POSIX.
                    #[component(name = "too-many-links")]
                    TooManyLinks,
                    /// Message too large, similar to `EMSGSIZE` in POSIX.
                    #[component(name = "message-size")]
                    MessageSize,
                    /// Filename too long, similar to `ENAMETOOLONG` in POSIX.
                    #[component(name = "name-too-long")]
                    NameTooLong,
                    /// No such device, similar to `ENODEV` in POSIX.
                    #[component(name = "no-device")]
                    NoDevice,
                    /// No such file or directory, similar to `ENOENT` in POSIX.
                    #[component(name = "no-entry")]
                    NoEntry,
                    /// No locks available, similar to `ENOLCK` in POSIX.
                    #[component(name = "no-lock")]
                    NoLock,
                    /// Not enough space, similar to `ENOMEM` in POSIX.
                    #[component(name = "insufficient-memory")]
                    InsufficientMemory,
                    /// No space left on device, similar to `ENOSPC` in POSIX.
                    #[component(name = "insufficient-space")]
                    InsufficientSpace,
                    /// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.
                    #[component(name = "not-directory")]
                    NotDirectory,
                    /// Directory not empty, similar to `ENOTEMPTY` in POSIX.
                    #[component(name = "not-empty")]
                    NotEmpty,
                    /// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.
                    #[component(name = "not-recoverable")]
                    NotRecoverable,
                    /// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.
                    #[component(name = "unsupported")]
                    Unsupported,
                    /// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.
                    #[component(name = "no-tty")]
                    NoTty,
                    /// No such device or address, similar to `ENXIO` in POSIX.
                    #[component(name = "no-such-device")]
                    NoSuchDevice,
                    /// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.
                    #[component(name = "overflow")]
                    Overflow,
                    /// Operation not permitted, similar to `EPERM` in POSIX.
                    #[component(name = "not-permitted")]
                    NotPermitted,
                    /// Broken pipe, similar to `EPIPE` in POSIX.
                    #[component(name = "pipe")]
                    Pipe,
                    /// Read-only file system, similar to `EROFS` in POSIX.
                    #[component(name = "read-only")]
                    ReadOnly,
                    /// Invalid seek, similar to `ESPIPE` in POSIX.
                    #[component(name = "invalid-seek")]
                    InvalidSeek,
                    /// Text file busy, similar to `ETXTBSY` in POSIX.
                    #[component(name = "text-file-busy")]
                    TextFileBusy,
                    /// Cross-device link, similar to `EXDEV` in POSIX.
                    #[component(name = "cross-device")]
                    CrossDevice,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ErrorCode {
                    #[inline]
                    fn clone(&self) -> ErrorCode {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for ErrorCode {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ErrorCode {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ErrorCode {
                    #[inline]
                    fn eq(&self, other: &ErrorCode) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for ErrorCode {}
                #[automatically_derived]
                impl ::core::cmp::Eq for ErrorCode {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                unsafe impl wasmtime::component::Lower for ErrorCode {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::Access => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Access)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::WouldBlock => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).WouldBlock)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Already => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Already)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::BadDescriptor => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(3u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).BadDescriptor)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Busy => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(4u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Busy)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Deadlock => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(5u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Deadlock)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Quota => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(6u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Quota)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Exist => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(7u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Exist)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::FileTooLarge => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(8u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).FileTooLarge)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::IllegalByteSequence => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(9u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).IllegalByteSequence)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::InProgress => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(10u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).InProgress)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Interrupted => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(11u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Interrupted)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Invalid => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(12u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Invalid)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Io => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(13u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Io)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::IsDirectory => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(14u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).IsDirectory)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Loop => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(15u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Loop)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::TooManyLinks => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(16u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).TooManyLinks)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::MessageSize => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(17u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).MessageSize)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::NameTooLong => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(18u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NameTooLong)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::NoDevice => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(19u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NoDevice)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::NoEntry => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(20u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NoEntry)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::NoLock => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(21u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NoLock)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::InsufficientMemory => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(22u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).InsufficientMemory)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::InsufficientSpace => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(23u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).InsufficientSpace)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::NotDirectory => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(24u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NotDirectory)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::NotEmpty => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(25u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NotEmpty)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::NotRecoverable => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(26u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NotRecoverable)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Unsupported => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(27u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Unsupported)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::NoTty => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(28u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NoTty)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::NoSuchDevice => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(29u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NoSuchDevice)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Overflow => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(30u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Overflow)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::NotPermitted => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(31u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NotPermitted)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Pipe => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(32u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Pipe)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::ReadOnly => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(33u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).ReadOnly)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::InvalidSeek => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(34u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).InvalidSeek)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::TextFileBusy => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(35u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).TextFileBusy)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::CrossDevice => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(36u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).CrossDevice)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::Access => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::WouldBlock => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Already => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                Ok(())
                            }
                            Self::BadDescriptor => {
                                *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Busy => {
                                *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Deadlock => {
                                *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Quota => {
                                *cx.get::<1usize>(offset) = 6u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Exist => {
                                *cx.get::<1usize>(offset) = 7u8.to_le_bytes();
                                Ok(())
                            }
                            Self::FileTooLarge => {
                                *cx.get::<1usize>(offset) = 8u8.to_le_bytes();
                                Ok(())
                            }
                            Self::IllegalByteSequence => {
                                *cx.get::<1usize>(offset) = 9u8.to_le_bytes();
                                Ok(())
                            }
                            Self::InProgress => {
                                *cx.get::<1usize>(offset) = 10u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Interrupted => {
                                *cx.get::<1usize>(offset) = 11u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Invalid => {
                                *cx.get::<1usize>(offset) = 12u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Io => {
                                *cx.get::<1usize>(offset) = 13u8.to_le_bytes();
                                Ok(())
                            }
                            Self::IsDirectory => {
                                *cx.get::<1usize>(offset) = 14u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Loop => {
                                *cx.get::<1usize>(offset) = 15u8.to_le_bytes();
                                Ok(())
                            }
                            Self::TooManyLinks => {
                                *cx.get::<1usize>(offset) = 16u8.to_le_bytes();
                                Ok(())
                            }
                            Self::MessageSize => {
                                *cx.get::<1usize>(offset) = 17u8.to_le_bytes();
                                Ok(())
                            }
                            Self::NameTooLong => {
                                *cx.get::<1usize>(offset) = 18u8.to_le_bytes();
                                Ok(())
                            }
                            Self::NoDevice => {
                                *cx.get::<1usize>(offset) = 19u8.to_le_bytes();
                                Ok(())
                            }
                            Self::NoEntry => {
                                *cx.get::<1usize>(offset) = 20u8.to_le_bytes();
                                Ok(())
                            }
                            Self::NoLock => {
                                *cx.get::<1usize>(offset) = 21u8.to_le_bytes();
                                Ok(())
                            }
                            Self::InsufficientMemory => {
                                *cx.get::<1usize>(offset) = 22u8.to_le_bytes();
                                Ok(())
                            }
                            Self::InsufficientSpace => {
                                *cx.get::<1usize>(offset) = 23u8.to_le_bytes();
                                Ok(())
                            }
                            Self::NotDirectory => {
                                *cx.get::<1usize>(offset) = 24u8.to_le_bytes();
                                Ok(())
                            }
                            Self::NotEmpty => {
                                *cx.get::<1usize>(offset) = 25u8.to_le_bytes();
                                Ok(())
                            }
                            Self::NotRecoverable => {
                                *cx.get::<1usize>(offset) = 26u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Unsupported => {
                                *cx.get::<1usize>(offset) = 27u8.to_le_bytes();
                                Ok(())
                            }
                            Self::NoTty => {
                                *cx.get::<1usize>(offset) = 28u8.to_le_bytes();
                                Ok(())
                            }
                            Self::NoSuchDevice => {
                                *cx.get::<1usize>(offset) = 29u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Overflow => {
                                *cx.get::<1usize>(offset) = 30u8.to_le_bytes();
                                Ok(())
                            }
                            Self::NotPermitted => {
                                *cx.get::<1usize>(offset) = 31u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Pipe => {
                                *cx.get::<1usize>(offset) = 32u8.to_le_bytes();
                                Ok(())
                            }
                            Self::ReadOnly => {
                                *cx.get::<1usize>(offset) = 33u8.to_le_bytes();
                                Ok(())
                            }
                            Self::InvalidSeek => {
                                *cx.get::<1usize>(offset) = 34u8.to_le_bytes();
                                Ok(())
                            }
                            Self::TextFileBusy => {
                                *cx.get::<1usize>(offset) = 35u8.to_le_bytes();
                                Ok(())
                            }
                            Self::CrossDevice => {
                                *cx.get::<1usize>(offset) = 36u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for ErrorCode {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::Access,
                                1u32 => Self::WouldBlock,
                                2u32 => Self::Already,
                                3u32 => Self::BadDescriptor,
                                4u32 => Self::Busy,
                                5u32 => Self::Deadlock,
                                6u32 => Self::Quota,
                                7u32 => Self::Exist,
                                8u32 => Self::FileTooLarge,
                                9u32 => Self::IllegalByteSequence,
                                10u32 => Self::InProgress,
                                11u32 => Self::Interrupted,
                                12u32 => Self::Invalid,
                                13u32 => Self::Io,
                                14u32 => Self::IsDirectory,
                                15u32 => Self::Loop,
                                16u32 => Self::TooManyLinks,
                                17u32 => Self::MessageSize,
                                18u32 => Self::NameTooLong,
                                19u32 => Self::NoDevice,
                                20u32 => Self::NoEntry,
                                21u32 => Self::NoLock,
                                22u32 => Self::InsufficientMemory,
                                23u32 => Self::InsufficientSpace,
                                24u32 => Self::NotDirectory,
                                25u32 => Self::NotEmpty,
                                26u32 => Self::NotRecoverable,
                                27u32 => Self::Unsupported,
                                28u32 => Self::NoTty,
                                29u32 => Self::NoSuchDevice,
                                30u32 => Self::Overflow,
                                31u32 => Self::NotPermitted,
                                32u32 => Self::Pipe,
                                33u32 => Self::ReadOnly,
                                34u32 => Self::InvalidSeek,
                                35u32 => Self::TextFileBusy,
                                36u32 => Self::CrossDevice,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::Access,
                                1u8 => Self::WouldBlock,
                                2u8 => Self::Already,
                                3u8 => Self::BadDescriptor,
                                4u8 => Self::Busy,
                                5u8 => Self::Deadlock,
                                6u8 => Self::Quota,
                                7u8 => Self::Exist,
                                8u8 => Self::FileTooLarge,
                                9u8 => Self::IllegalByteSequence,
                                10u8 => Self::InProgress,
                                11u8 => Self::Interrupted,
                                12u8 => Self::Invalid,
                                13u8 => Self::Io,
                                14u8 => Self::IsDirectory,
                                15u8 => Self::Loop,
                                16u8 => Self::TooManyLinks,
                                17u8 => Self::MessageSize,
                                18u8 => Self::NameTooLong,
                                19u8 => Self::NoDevice,
                                20u8 => Self::NoEntry,
                                21u8 => Self::NoLock,
                                22u8 => Self::InsufficientMemory,
                                23u8 => Self::InsufficientSpace,
                                24u8 => Self::NotDirectory,
                                25u8 => Self::NotEmpty,
                                26u8 => Self::NotRecoverable,
                                27u8 => Self::Unsupported,
                                28u8 => Self::NoTty,
                                29u8 => Self::NoSuchDevice,
                                30u8 => Self::Overflow,
                                31u8 => Self::NotPermitted,
                                32u8 => Self::Pipe,
                                33u8 => Self::ReadOnly,
                                34u8 => Self::InvalidSeek,
                                35u8 => Self::TextFileBusy,
                                36u8 => Self::CrossDevice,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerErrorCode {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadErrorCode,
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for LowerErrorCode {
                        #[inline]
                        fn clone(&self) -> LowerErrorCode {
                            let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                            let _: ::core::clone::AssertParamIsClone<
                                LowerPayloadErrorCode,
                            >;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for LowerErrorCode {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadErrorCode {
                        Access: [wasmtime::ValRaw; 0],
                        WouldBlock: [wasmtime::ValRaw; 0],
                        Already: [wasmtime::ValRaw; 0],
                        BadDescriptor: [wasmtime::ValRaw; 0],
                        Busy: [wasmtime::ValRaw; 0],
                        Deadlock: [wasmtime::ValRaw; 0],
                        Quota: [wasmtime::ValRaw; 0],
                        Exist: [wasmtime::ValRaw; 0],
                        FileTooLarge: [wasmtime::ValRaw; 0],
                        IllegalByteSequence: [wasmtime::ValRaw; 0],
                        InProgress: [wasmtime::ValRaw; 0],
                        Interrupted: [wasmtime::ValRaw; 0],
                        Invalid: [wasmtime::ValRaw; 0],
                        Io: [wasmtime::ValRaw; 0],
                        IsDirectory: [wasmtime::ValRaw; 0],
                        Loop: [wasmtime::ValRaw; 0],
                        TooManyLinks: [wasmtime::ValRaw; 0],
                        MessageSize: [wasmtime::ValRaw; 0],
                        NameTooLong: [wasmtime::ValRaw; 0],
                        NoDevice: [wasmtime::ValRaw; 0],
                        NoEntry: [wasmtime::ValRaw; 0],
                        NoLock: [wasmtime::ValRaw; 0],
                        InsufficientMemory: [wasmtime::ValRaw; 0],
                        InsufficientSpace: [wasmtime::ValRaw; 0],
                        NotDirectory: [wasmtime::ValRaw; 0],
                        NotEmpty: [wasmtime::ValRaw; 0],
                        NotRecoverable: [wasmtime::ValRaw; 0],
                        Unsupported: [wasmtime::ValRaw; 0],
                        NoTty: [wasmtime::ValRaw; 0],
                        NoSuchDevice: [wasmtime::ValRaw; 0],
                        Overflow: [wasmtime::ValRaw; 0],
                        NotPermitted: [wasmtime::ValRaw; 0],
                        Pipe: [wasmtime::ValRaw; 0],
                        ReadOnly: [wasmtime::ValRaw; 0],
                        InvalidSeek: [wasmtime::ValRaw; 0],
                        TextFileBusy: [wasmtime::ValRaw; 0],
                        CrossDevice: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::clone::Clone for LowerPayloadErrorCode {
                        #[inline]
                        fn clone(&self) -> LowerPayloadErrorCode {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::marker::Copy for LowerPayloadErrorCode {}
                    unsafe impl wasmtime::component::ComponentType for ErrorCode {
                        type Lower = LowerErrorCode;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_enum(
                                ty,
                                types,
                                &[
                                    "access",
                                    "would-block",
                                    "already",
                                    "bad-descriptor",
                                    "busy",
                                    "deadlock",
                                    "quota",
                                    "exist",
                                    "file-too-large",
                                    "illegal-byte-sequence",
                                    "in-progress",
                                    "interrupted",
                                    "invalid",
                                    "io",
                                    "is-directory",
                                    "loop",
                                    "too-many-links",
                                    "message-size",
                                    "name-too-long",
                                    "no-device",
                                    "no-entry",
                                    "no-lock",
                                    "insufficient-memory",
                                    "insufficient-space",
                                    "not-directory",
                                    "not-empty",
                                    "not-recoverable",
                                    "unsupported",
                                    "no-tty",
                                    "no-such-device",
                                    "overflow",
                                    "not-permitted",
                                    "pipe",
                                    "read-only",
                                    "invalid-seek",
                                    "text-file-busy",
                                    "cross-device",
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                            ],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for ErrorCode {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                        ];
                    }
                };
                impl ErrorCode {
                    pub fn name(&self) -> &'static str {
                        match self {
                            ErrorCode::Access => "access",
                            ErrorCode::WouldBlock => "would-block",
                            ErrorCode::Already => "already",
                            ErrorCode::BadDescriptor => "bad-descriptor",
                            ErrorCode::Busy => "busy",
                            ErrorCode::Deadlock => "deadlock",
                            ErrorCode::Quota => "quota",
                            ErrorCode::Exist => "exist",
                            ErrorCode::FileTooLarge => "file-too-large",
                            ErrorCode::IllegalByteSequence => "illegal-byte-sequence",
                            ErrorCode::InProgress => "in-progress",
                            ErrorCode::Interrupted => "interrupted",
                            ErrorCode::Invalid => "invalid",
                            ErrorCode::Io => "io",
                            ErrorCode::IsDirectory => "is-directory",
                            ErrorCode::Loop => "loop",
                            ErrorCode::TooManyLinks => "too-many-links",
                            ErrorCode::MessageSize => "message-size",
                            ErrorCode::NameTooLong => "name-too-long",
                            ErrorCode::NoDevice => "no-device",
                            ErrorCode::NoEntry => "no-entry",
                            ErrorCode::NoLock => "no-lock",
                            ErrorCode::InsufficientMemory => "insufficient-memory",
                            ErrorCode::InsufficientSpace => "insufficient-space",
                            ErrorCode::NotDirectory => "not-directory",
                            ErrorCode::NotEmpty => "not-empty",
                            ErrorCode::NotRecoverable => "not-recoverable",
                            ErrorCode::Unsupported => "unsupported",
                            ErrorCode::NoTty => "no-tty",
                            ErrorCode::NoSuchDevice => "no-such-device",
                            ErrorCode::Overflow => "overflow",
                            ErrorCode::NotPermitted => "not-permitted",
                            ErrorCode::Pipe => "pipe",
                            ErrorCode::ReadOnly => "read-only",
                            ErrorCode::InvalidSeek => "invalid-seek",
                            ErrorCode::TextFileBusy => "text-file-busy",
                            ErrorCode::CrossDevice => "cross-device",
                        }
                    }
                    pub fn message(&self) -> &'static str {
                        match self {
                            ErrorCode::Access => {
                                "Permission denied, similar to `EACCES` in POSIX."
                            }
                            ErrorCode::WouldBlock => {
                                "Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX."
                            }
                            ErrorCode::Already => {
                                "Connection already in progress, similar to `EALREADY` in POSIX."
                            }
                            ErrorCode::BadDescriptor => {
                                "Bad descriptor, similar to `EBADF` in POSIX."
                            }
                            ErrorCode::Busy => {
                                "Device or resource busy, similar to `EBUSY` in POSIX."
                            }
                            ErrorCode::Deadlock => {
                                "Resource deadlock would occur, similar to `EDEADLK` in POSIX."
                            }
                            ErrorCode::Quota => {
                                "Storage quota exceeded, similar to `EDQUOT` in POSIX."
                            }
                            ErrorCode::Exist => {
                                "File exists, similar to `EEXIST` in POSIX."
                            }
                            ErrorCode::FileTooLarge => {
                                "File too large, similar to `EFBIG` in POSIX."
                            }
                            ErrorCode::IllegalByteSequence => {
                                "Illegal byte sequence, similar to `EILSEQ` in POSIX."
                            }
                            ErrorCode::InProgress => {
                                "Operation in progress, similar to `EINPROGRESS` in POSIX."
                            }
                            ErrorCode::Interrupted => {
                                "Interrupted function, similar to `EINTR` in POSIX."
                            }
                            ErrorCode::Invalid => {
                                "Invalid argument, similar to `EINVAL` in POSIX."
                            }
                            ErrorCode::Io => "I/O error, similar to `EIO` in POSIX.",
                            ErrorCode::IsDirectory => {
                                "Is a directory, similar to `EISDIR` in POSIX."
                            }
                            ErrorCode::Loop => {
                                "Too many levels of symbolic links, similar to `ELOOP` in POSIX."
                            }
                            ErrorCode::TooManyLinks => {
                                "Too many links, similar to `EMLINK` in POSIX."
                            }
                            ErrorCode::MessageSize => {
                                "Message too large, similar to `EMSGSIZE` in POSIX."
                            }
                            ErrorCode::NameTooLong => {
                                "Filename too long, similar to `ENAMETOOLONG` in POSIX."
                            }
                            ErrorCode::NoDevice => {
                                "No such device, similar to `ENODEV` in POSIX."
                            }
                            ErrorCode::NoEntry => {
                                "No such file or directory, similar to `ENOENT` in POSIX."
                            }
                            ErrorCode::NoLock => {
                                "No locks available, similar to `ENOLCK` in POSIX."
                            }
                            ErrorCode::InsufficientMemory => {
                                "Not enough space, similar to `ENOMEM` in POSIX."
                            }
                            ErrorCode::InsufficientSpace => {
                                "No space left on device, similar to `ENOSPC` in POSIX."
                            }
                            ErrorCode::NotDirectory => {
                                "Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX."
                            }
                            ErrorCode::NotEmpty => {
                                "Directory not empty, similar to `ENOTEMPTY` in POSIX."
                            }
                            ErrorCode::NotRecoverable => {
                                "State not recoverable, similar to `ENOTRECOVERABLE` in POSIX."
                            }
                            ErrorCode::Unsupported => {
                                "Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX."
                            }
                            ErrorCode::NoTty => {
                                "Inappropriate I/O control operation, similar to `ENOTTY` in POSIX."
                            }
                            ErrorCode::NoSuchDevice => {
                                "No such device or address, similar to `ENXIO` in POSIX."
                            }
                            ErrorCode::Overflow => {
                                "Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX."
                            }
                            ErrorCode::NotPermitted => {
                                "Operation not permitted, similar to `EPERM` in POSIX."
                            }
                            ErrorCode::Pipe => {
                                "Broken pipe, similar to `EPIPE` in POSIX."
                            }
                            ErrorCode::ReadOnly => {
                                "Read-only file system, similar to `EROFS` in POSIX."
                            }
                            ErrorCode::InvalidSeek => {
                                "Invalid seek, similar to `ESPIPE` in POSIX."
                            }
                            ErrorCode::TextFileBusy => {
                                "Text file busy, similar to `ETXTBSY` in POSIX."
                            }
                            ErrorCode::CrossDevice => {
                                "Cross-device link, similar to `EXDEV` in POSIX."
                            }
                        }
                    }
                }
                impl core::fmt::Debug for ErrorCode {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("ErrorCode")
                            .field("code", &(*self as i32))
                            .field("name", &self.name())
                            .field("message", &self.message())
                            .finish()
                    }
                }
                impl core::fmt::Display for ErrorCode {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.write_fmt(
                            format_args!("{0} (error {1})", self.name(), *self as i32),
                        )
                    }
                }
                impl std::error::Error for ErrorCode {}
                const _: () = {
                    if !(1 == <ErrorCode as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <ErrorCode as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1 == <ErrorCode as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <ErrorCode as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// File or memory access pattern advisory information.
                #[component(enum)]
                pub enum Advice {
                    /// The application has no advice to give on its behavior with respect
                    /// to the specified data.
                    #[component(name = "normal")]
                    Normal,
                    /// The application expects to access the specified data sequentially
                    /// from lower offsets to higher offsets.
                    #[component(name = "sequential")]
                    Sequential,
                    /// The application expects to access the specified data in a random
                    /// order.
                    #[component(name = "random")]
                    Random,
                    /// The application expects to access the specified data in the near
                    /// future.
                    #[component(name = "will-need")]
                    WillNeed,
                    /// The application expects that it will not access the specified data
                    /// in the near future.
                    #[component(name = "dont-need")]
                    DontNeed,
                    /// The application expects to access the specified data once and then
                    /// not reuse it thereafter.
                    #[component(name = "no-reuse")]
                    NoReuse,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Advice {
                    #[inline]
                    fn clone(&self) -> Advice {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Advice {}
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Advice {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Advice {
                    #[inline]
                    fn eq(&self, other: &Advice) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralEq for Advice {}
                #[automatically_derived]
                impl ::core::cmp::Eq for Advice {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {}
                }
                unsafe impl wasmtime::component::Lower for Advice {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::Normal => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Normal)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Sequential => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Sequential)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Random => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Random)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::WillNeed => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(3u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).WillNeed)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::DontNeed => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(4u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).DontNeed)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::NoReuse => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(5u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).NoReuse)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::Normal => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Sequential => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Random => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                Ok(())
                            }
                            Self::WillNeed => {
                                *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                                Ok(())
                            }
                            Self::DontNeed => {
                                *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                                Ok(())
                            }
                            Self::NoReuse => {
                                *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for Advice {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::Normal,
                                1u32 => Self::Sequential,
                                2u32 => Self::Random,
                                3u32 => Self::WillNeed,
                                4u32 => Self::DontNeed,
                                5u32 => Self::NoReuse,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Enum(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::Normal,
                                1u8 => Self::Sequential,
                                2u8 => Self::Random,
                                3u8 => Self::WillNeed,
                                4u8 => Self::DontNeed,
                                5u8 => Self::NoReuse,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerAdvice {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadAdvice,
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for LowerAdvice {
                        #[inline]
                        fn clone(&self) -> LowerAdvice {
                            let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                            let _: ::core::clone::AssertParamIsClone<LowerPayloadAdvice>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for LowerAdvice {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadAdvice {
                        Normal: [wasmtime::ValRaw; 0],
                        Sequential: [wasmtime::ValRaw; 0],
                        Random: [wasmtime::ValRaw; 0],
                        WillNeed: [wasmtime::ValRaw; 0],
                        DontNeed: [wasmtime::ValRaw; 0],
                        NoReuse: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::clone::Clone for LowerPayloadAdvice {
                        #[inline]
                        fn clone(&self) -> LowerPayloadAdvice {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::marker::Copy for LowerPayloadAdvice {}
                    unsafe impl wasmtime::component::ComponentType for Advice {
                        type Lower = LowerAdvice;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_enum(
                                ty,
                                types,
                                &[
                                    "normal",
                                    "sequential",
                                    "random",
                                    "will-need",
                                    "dont-need",
                                    "no-reuse",
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[None, None, None, None, None, None],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for Advice {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[None, None, None, None, None, None];
                    }
                };
                impl core::fmt::Debug for Advice {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            Advice::Normal => f.debug_tuple("Advice::Normal").finish(),
                            Advice::Sequential => {
                                f.debug_tuple("Advice::Sequential").finish()
                            }
                            Advice::Random => f.debug_tuple("Advice::Random").finish(),
                            Advice::WillNeed => {
                                f.debug_tuple("Advice::WillNeed").finish()
                            }
                            Advice::DontNeed => {
                                f.debug_tuple("Advice::DontNeed").finish()
                            }
                            Advice::NoReuse => f.debug_tuple("Advice::NoReuse").finish(),
                        }
                    }
                }
                const _: () = {
                    if !(1 == <Advice as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <Advice as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1 == <Advice as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <Advice as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// A 128-bit hash value, split into parts because wasm doesn't have a
                /// 128-bit integer type.
                #[component(record)]
                pub struct MetadataHashValue {
                    /// 64 bits of a 128-bit hash value.
                    #[component(name = "lower")]
                    pub lower: u64,
                    /// Another 64 bits of a 128-bit hash value.
                    #[component(name = "upper")]
                    pub upper: u64,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for MetadataHashValue {}
                #[automatically_derived]
                impl ::core::clone::Clone for MetadataHashValue {
                    #[inline]
                    fn clone(&self) -> MetadataHashValue {
                        let _: ::core::clone::AssertParamIsClone<u64>;
                        *self
                    }
                }
                unsafe impl wasmtime::component::Lower for MetadataHashValue {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::lower(
                            &self.lower,
                            cx,
                            ty.fields[0usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).lower)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.upper,
                            cx,
                            ty.fields[1usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).upper)
                                    }
                                }
                            },
                        )?;
                        Ok(())
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::store(
                            &self.lower,
                            cx,
                            ty.fields[0usize].ty,
                            <u64 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.upper,
                            cx,
                            ty.fields[1usize].ty,
                            <u64 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for MetadataHashValue {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(Self {
                            lower: <u64 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[0usize].ty,
                                &src.lower,
                            )?,
                            upper: <u64 as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[1usize].ty,
                                &src.upper,
                            )?,
                        })
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let mut offset = 0;
                        Ok(Self {
                            lower: <u64 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[0usize].ty,
                                &bytes[<u64 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u64 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            upper: <u64 as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[1usize].ty,
                                &bytes[<u64 as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<u64 as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                        })
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerMetadataHashValue<T0: Copy, T1: Copy> {
                        lower: T0,
                        upper: T1,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::clone::Clone + Copy,
                        T1: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerMetadataHashValue<T0, T1> {
                        #[inline]
                        fn clone(&self) -> LowerMetadataHashValue<T0, T1> {
                            LowerMetadataHashValue {
                                lower: ::core::clone::Clone::clone(&self.lower),
                                upper: ::core::clone::Clone::clone(&self.upper),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::marker::Copy + Copy,
                        T1: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy for LowerMetadataHashValue<T0, T1> {}
                    unsafe impl wasmtime::component::ComponentType
                    for MetadataHashValue {
                        type Lower = LowerMetadataHashValue<
                            <u64 as wasmtime::component::ComponentType>::Lower,
                            <u64 as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[
                                <u64 as wasmtime::component::ComponentType>::ABI,
                                <u64 as wasmtime::component::ComponentType>::ABI,
                            ],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_record(
                                ty,
                                types,
                                &[
                                    (
                                        "lower",
                                        <u64 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "upper",
                                        <u64 as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ],
                            )
                        }
                    }
                };
                impl core::fmt::Debug for MetadataHashValue {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("MetadataHashValue")
                            .field("lower", &self.lower)
                            .field("upper", &self.upper)
                            .finish()
                    }
                }
                const _: () = {
                    if !(16
                        == <MetadataHashValue as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 16 == <MetadataHashValue as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8
                        == <MetadataHashValue as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <MetadataHashValue as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// A descriptor is a reference to a filesystem object, which may be a file,
                /// directory, named pipe, special file, or other object on which filesystem
                /// calls may be made.
                pub enum Descriptor {}
                pub trait HostDescriptor {
                    /// Return a stream for reading from a file, if available.
                    ///
                    /// May fail with an error-code describing why the file cannot be read.
                    ///
                    /// Multiple read, write, and append streams may be active on the same open
                    /// file and they do not interfere with each other.
                    ///
                    /// Note: This allows using `read-stream`, which is similar to `read` in POSIX.
                    fn read_via_stream(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        offset: Filesize,
                    ) -> wasmtime::Result<
                        Result<wasmtime::component::Resource<InputStream>, ErrorCode>,
                    >;
                    /// Return a stream for writing to a file, if available.
                    ///
                    /// May fail with an error-code describing why the file cannot be written.
                    ///
                    /// Note: This allows using `write-stream`, which is similar to `write` in
                    /// POSIX.
                    fn write_via_stream(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        offset: Filesize,
                    ) -> wasmtime::Result<
                        Result<wasmtime::component::Resource<OutputStream>, ErrorCode>,
                    >;
                    /// Return a stream for appending to a file, if available.
                    ///
                    /// May fail with an error-code describing why the file cannot be appended.
                    ///
                    /// Note: This allows using `write-stream`, which is similar to `write` with
                    /// `O_APPEND` in in POSIX.
                    fn append_via_stream(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                    ) -> wasmtime::Result<
                        Result<wasmtime::component::Resource<OutputStream>, ErrorCode>,
                    >;
                    /// Provide file advisory information on a descriptor.
                    ///
                    /// This is similar to `posix_fadvise` in POSIX.
                    fn advise(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        offset: Filesize,
                        length: Filesize,
                        advice: Advice,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Synchronize the data of a file to disk.
                    ///
                    /// This function succeeds with no effect if the file descriptor is not
                    /// opened for writing.
                    ///
                    /// Note: This is similar to `fdatasync` in POSIX.
                    fn sync_data(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Get flags associated with a descriptor.
                    ///
                    /// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
                    ///
                    /// Note: This returns the value that was the `fs_flags` value returned
                    /// from `fdstat_get` in earlier versions of WASI.
                    fn get_flags(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                    ) -> wasmtime::Result<Result<DescriptorFlags, ErrorCode>>;
                    /// Get the dynamic type of a descriptor.
                    ///
                    /// Note: This returns the same value as the `type` field of the `fd-stat`
                    /// returned by `stat`, `stat-at` and similar.
                    ///
                    /// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
                    /// by `fstat` in POSIX.
                    ///
                    /// Note: This returns the value that was the `fs_filetype` value returned
                    /// from `fdstat_get` in earlier versions of WASI.
                    fn get_type(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                    ) -> wasmtime::Result<Result<DescriptorType, ErrorCode>>;
                    /// Adjust the size of an open file. If this increases the file's size, the
                    /// extra bytes are filled with zeros.
                    ///
                    /// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
                    fn set_size(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        size: Filesize,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Adjust the timestamps of an open file or directory.
                    ///
                    /// Note: This is similar to `futimens` in POSIX.
                    ///
                    /// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
                    fn set_times(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        data_access_timestamp: NewTimestamp,
                        data_modification_timestamp: NewTimestamp,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Read from a descriptor, without using and updating the descriptor's offset.
                    ///
                    /// This function returns a list of bytes containing the data that was
                    /// read, along with a bool which, when true, indicates that the end of the
                    /// file was reached. The returned list will contain up to `length` bytes; it
                    /// may return fewer than requested, if the end of the file is reached or
                    /// if the I/O operation is interrupted.
                    ///
                    /// In the future, this may change to return a `stream<u8, error-code>`.
                    ///
                    /// Note: This is similar to `pread` in POSIX.
                    fn read(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        length: Filesize,
                        offset: Filesize,
                    ) -> wasmtime::Result<Result<(Vec<u8>, bool), ErrorCode>>;
                    /// Write to a descriptor, without using and updating the descriptor's offset.
                    ///
                    /// It is valid to write past the end of a file; the file is extended to the
                    /// extent of the write, with bytes between the previous end and the start of
                    /// the write set to zero.
                    ///
                    /// In the future, this may change to take a `stream<u8, error-code>`.
                    ///
                    /// Note: This is similar to `pwrite` in POSIX.
                    fn write(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        buffer: Vec<u8>,
                        offset: Filesize,
                    ) -> wasmtime::Result<Result<Filesize, ErrorCode>>;
                    /// Read directory entries from a directory.
                    ///
                    /// On filesystems where directories contain entries referring to themselves
                    /// and their parents, often named `.` and `..` respectively, these entries
                    /// are omitted.
                    ///
                    /// This always returns a new stream which starts at the beginning of the
                    /// directory. Multiple streams may be active on the same directory, and they
                    /// do not interfere with each other.
                    fn read_directory(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                    ) -> wasmtime::Result<
                        Result<
                            wasmtime::component::Resource<DirectoryEntryStream>,
                            ErrorCode,
                        >,
                    >;
                    /// Synchronize the data and metadata of a file to disk.
                    ///
                    /// This function succeeds with no effect if the file descriptor is not
                    /// opened for writing.
                    ///
                    /// Note: This is similar to `fsync` in POSIX.
                    fn sync(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Create a directory.
                    ///
                    /// Note: This is similar to `mkdirat` in POSIX.
                    fn create_directory_at(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        path: String,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Return the attributes of an open file or directory.
                    ///
                    /// Note: This is similar to `fstat` in POSIX, except that it does not return
                    /// device and inode information. For testing whether two descriptors refer to
                    /// the same underlying filesystem object, use `is-same-object`. To obtain
                    /// additional data that can be used do determine whether a file has been
                    /// modified, use `metadata-hash`.
                    ///
                    /// Note: This was called `fd_filestat_get` in earlier versions of WASI.
                    fn stat(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                    ) -> wasmtime::Result<Result<DescriptorStat, ErrorCode>>;
                    /// Return the attributes of a file or directory.
                    ///
                    /// Note: This is similar to `fstatat` in POSIX, except that it does not
                    /// return device and inode information. See the `stat` description for a
                    /// discussion of alternatives.
                    ///
                    /// Note: This was called `path_filestat_get` in earlier versions of WASI.
                    fn stat_at(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        path_flags: PathFlags,
                        path: String,
                    ) -> wasmtime::Result<Result<DescriptorStat, ErrorCode>>;
                    /// Adjust the timestamps of a file or directory.
                    ///
                    /// Note: This is similar to `utimensat` in POSIX.
                    ///
                    /// Note: This was called `path_filestat_set_times` in earlier versions of
                    /// WASI.
                    fn set_times_at(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        path_flags: PathFlags,
                        path: String,
                        data_access_timestamp: NewTimestamp,
                        data_modification_timestamp: NewTimestamp,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Create a hard link.
                    ///
                    /// Note: This is similar to `linkat` in POSIX.
                    fn link_at(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        old_path_flags: PathFlags,
                        old_path: String,
                        new_descriptor: wasmtime::component::Resource<Descriptor>,
                        new_path: String,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Open a file or directory.
                    ///
                    /// The returned descriptor is not guaranteed to be the lowest-numbered
                    /// descriptor not currently open/ it is randomized to prevent applications
                    /// from depending on making assumptions about indexes, since this is
                    /// error-prone in multi-threaded contexts. The returned descriptor is
                    /// guaranteed to be less than 2**31.
                    ///
                    /// If `flags` contains `descriptor-flags::mutate-directory`, and the base
                    /// descriptor doesn't have `descriptor-flags::mutate-directory` set,
                    /// `open-at` fails with `error-code::read-only`.
                    ///
                    /// If `flags` contains `write` or `mutate-directory`, or `open-flags`
                    /// contains `truncate` or `create`, and the base descriptor doesn't have
                    /// `descriptor-flags::mutate-directory` set, `open-at` fails with
                    /// `error-code::read-only`.
                    ///
                    /// Note: This is similar to `openat` in POSIX.
                    fn open_at(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        path_flags: PathFlags,
                        path: String,
                        open_flags: OpenFlags,
                        flags: DescriptorFlags,
                    ) -> wasmtime::Result<
                        Result<wasmtime::component::Resource<Descriptor>, ErrorCode>,
                    >;
                    /// Read the contents of a symbolic link.
                    ///
                    /// If the contents contain an absolute or rooted path in the underlying
                    /// filesystem, this function fails with `error-code::not-permitted`.
                    ///
                    /// Note: This is similar to `readlinkat` in POSIX.
                    fn readlink_at(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        path: String,
                    ) -> wasmtime::Result<Result<String, ErrorCode>>;
                    /// Remove a directory.
                    ///
                    /// Return `error-code::not-empty` if the directory is not empty.
                    ///
                    /// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
                    fn remove_directory_at(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        path: String,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Rename a filesystem object.
                    ///
                    /// Note: This is similar to `renameat` in POSIX.
                    fn rename_at(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        old_path: String,
                        new_descriptor: wasmtime::component::Resource<Descriptor>,
                        new_path: String,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Create a symbolic link (also known as a "symlink").
                    ///
                    /// If `old-path` starts with `/`, the function fails with
                    /// `error-code::not-permitted`.
                    ///
                    /// Note: This is similar to `symlinkat` in POSIX.
                    fn symlink_at(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        old_path: String,
                        new_path: String,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Unlink a filesystem object that is not a directory.
                    ///
                    /// Return `error-code::is-directory` if the path refers to a directory.
                    /// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
                    fn unlink_file_at(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        path: String,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    /// Test whether two descriptors refer to the same filesystem object.
                    ///
                    /// In POSIX, this corresponds to testing whether the two descriptors have the
                    /// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
                    /// wasi-filesystem does not expose device and inode numbers, so this function
                    /// may be used instead.
                    fn is_same_object(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        other: wasmtime::component::Resource<Descriptor>,
                    ) -> wasmtime::Result<bool>;
                    /// Return a hash of the metadata associated with a filesystem object referred
                    /// to by a descriptor.
                    ///
                    /// This returns a hash of the last-modification timestamp and file size, and
                    /// may also include the inode number, device number, birth timestamp, and
                    /// other metadata fields that may change when the file is modified or
                    /// replaced. It may also include a secret value chosen by the
                    /// implementation and not otherwise exposed.
                    ///
                    /// Implementations are encourated to provide the following properties:
                    ///
                    /// - If the file is not modified or replaced, the computed hash value should
                    /// usually not change.
                    /// - If the object is modified or replaced, the computed hash value should
                    /// usually change.
                    /// - The inputs to the hash should not be easily computable from the
                    /// computed hash.
                    ///
                    /// However, none of these is required.
                    fn metadata_hash(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                    ) -> wasmtime::Result<Result<MetadataHashValue, ErrorCode>>;
                    /// Return a hash of the metadata associated with a filesystem object referred
                    /// to by a directory descriptor and a relative path.
                    ///
                    /// This performs the same hash computation as `metadata-hash`.
                    fn metadata_hash_at(
                        &mut self,
                        self_: wasmtime::component::Resource<Descriptor>,
                        path_flags: PathFlags,
                        path: String,
                    ) -> wasmtime::Result<Result<MetadataHashValue, ErrorCode>>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<Descriptor>,
                    ) -> wasmtime::Result<()>;
                }
                /// A stream of directory entries.
                pub enum DirectoryEntryStream {}
                pub trait HostDirectoryEntryStream {
                    /// Read a single directory entry from a `directory-entry-stream`.
                    fn read_directory_entry(
                        &mut self,
                        self_: wasmtime::component::Resource<DirectoryEntryStream>,
                    ) -> wasmtime::Result<Result<Option<DirectoryEntry>, ErrorCode>>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<DirectoryEntryStream>,
                    ) -> wasmtime::Result<()>;
                }
                pub trait Host: HostDescriptor + HostDirectoryEntryStream {
                    /// Attempts to extract a filesystem-related `error-code` from the stream
                    /// `error` provided.
                    ///
                    /// Stream operations which return `stream-error::last-operation-failed`
                    /// have a payload with more information about the operation that failed.
                    /// This payload can be passed through to this function to see if there's
                    /// filesystem-related information about the error to return.
                    ///
                    /// Note that this function is fallible because not all stream-related
                    /// errors are filesystem-related errors.
                    fn filesystem_error_code(
                        &mut self,
                        err: wasmtime::component::Resource<Error>,
                    ) -> wasmtime::Result<Option<ErrorCode>>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:filesystem/types@0.2.0")?;
                    inst.resource(
                        "descriptor",
                        wasmtime::component::ResourceType::host::<Descriptor>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostDescriptor::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "directory-entry-stream",
                        wasmtime::component::ResourceType::host::<
                            DirectoryEntryStream,
                        >(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostDirectoryEntryStream::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.read-via-stream",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<Descriptor>, Filesize)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::read_via_stream(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.write-via-stream",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<Descriptor>, Filesize)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::write_via_stream(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.append-via-stream",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Descriptor>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::append_via_stream(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.advise",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                Filesize,
                                Filesize,
                                Advice,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::advise(host, arg0, arg1, arg2, arg3);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.sync-data",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Descriptor>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::sync_data(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.get-flags",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Descriptor>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::get_flags(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.get-type",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Descriptor>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::get_type(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.set-size",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<Descriptor>, Filesize)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::set_size(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.set-times",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                NewTimestamp,
                                NewTimestamp,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::set_times(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.read",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                Filesize,
                                Filesize,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::read(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.write",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                Vec<u8>,
                                Filesize,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::write(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.read-directory",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Descriptor>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::read_directory(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.sync",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Descriptor>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::sync(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.create-directory-at",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<Descriptor>, String)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::create_directory_at(
                                host,
                                arg0,
                                arg1,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.stat",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Descriptor>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::stat(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.stat-at",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                PathFlags,
                                String,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::stat_at(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.set-times-at",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                                arg4,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                PathFlags,
                                String,
                                NewTimestamp,
                                NewTimestamp,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::set_times_at(
                                host,
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                                arg4,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.link-at",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                                arg4,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                PathFlags,
                                String,
                                wasmtime::component::Resource<Descriptor>,
                                String,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::link_at(
                                host,
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                                arg4,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.open-at",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                                arg4,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                PathFlags,
                                String,
                                OpenFlags,
                                DescriptorFlags,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::open_at(
                                host,
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                                arg4,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.readlink-at",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<Descriptor>, String)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::readlink_at(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.remove-directory-at",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<Descriptor>, String)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::remove_directory_at(
                                host,
                                arg0,
                                arg1,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.rename-at",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                String,
                                wasmtime::component::Resource<Descriptor>,
                                String,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::rename_at(
                                host,
                                arg0,
                                arg1,
                                arg2,
                                arg3,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.symlink-at",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                String,
                                String,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::symlink_at(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.unlink-file-at",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<Descriptor>, String)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::unlink_file_at(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.is-same-object",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                wasmtime::component::Resource<Descriptor>,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::is_same_object(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.metadata-hash",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Descriptor>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::metadata_hash(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]descriptor.metadata-hash-at",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (
                                wasmtime::component::Resource<Descriptor>,
                                PathFlags,
                                String,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDescriptor::metadata_hash_at(
                                host,
                                arg0,
                                arg1,
                                arg2,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]directory-entry-stream.read-directory-entry",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                            ): (wasmtime::component::Resource<DirectoryEntryStream>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostDirectoryEntryStream::read_directory_entry(
                                host,
                                arg0,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "filesystem-error-code",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Error>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::filesystem_error_code(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
            #[allow(clippy::all)]
            pub mod preopens {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Descriptor = super::super::super::wasi::filesystem::types::Descriptor;
                pub trait Host {
                    /// Return the set of preopened directories, and their path.
                    fn get_directories(
                        &mut self,
                    ) -> wasmtime::Result<
                        Vec<(wasmtime::component::Resource<Descriptor>, String)>,
                    >;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:filesystem/preopens@0.2.0")?;
                    inst.func_wrap(
                        "get-directories",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::get_directories(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod http {
            #[allow(clippy::all)]
            pub mod types {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Duration = super::super::super::wasi::clocks::monotonic_clock::Duration;
                const _: () = {
                    if !(8 == <Duration as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Duration as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <Duration as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Duration as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub type InputStream = super::super::super::wasi::io::streams::InputStream;
                pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
                pub type IoError = super::super::super::wasi::io::error::Error;
                /// Hermes doews not support `poll`
                /// use wasi:io/poll@0.2.0.{pollable};
                /// This type corresponds to HTTP standard Methods.
                #[component(variant)]
                pub enum Method {
                    #[component(name = "get")]
                    Get,
                    #[component(name = "head")]
                    Head,
                    #[component(name = "post")]
                    Post,
                    #[component(name = "put")]
                    Put,
                    #[component(name = "delete")]
                    Delete,
                    #[component(name = "connect")]
                    Connect,
                    #[component(name = "options")]
                    Options,
                    #[component(name = "trace")]
                    Trace,
                    #[component(name = "patch")]
                    Patch,
                    #[component(name = "other")]
                    Other(String),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Method {
                    #[inline]
                    fn clone(&self) -> Method {
                        match self {
                            Method::Get => Method::Get,
                            Method::Head => Method::Head,
                            Method::Post => Method::Post,
                            Method::Put => Method::Put,
                            Method::Delete => Method::Delete,
                            Method::Connect => Method::Connect,
                            Method::Options => Method::Options,
                            Method::Trace => Method::Trace,
                            Method::Patch => Method::Patch,
                            Method::Other(__self_0) => {
                                Method::Other(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lower for Method {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::Get => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Get)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Head => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Head)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Post => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Post)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Put => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(3u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Put)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Delete => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(4u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Delete)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Connect => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(5u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Connect)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Options => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(6u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Options)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Trace => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(7u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Trace)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Patch => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(8u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Patch)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Other(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(9u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Other)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[9usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::Get => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Head => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Post => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Put => {
                                *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Delete => {
                                *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Connect => {
                                *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Options => {
                                *cx.get::<1usize>(offset) = 6u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Trace => {
                                *cx.get::<1usize>(offset) = 7u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Patch => {
                                *cx.get::<1usize>(offset) = 8u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Other(value) => {
                                *cx.get::<1usize>(offset) = 9u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[9usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for Method {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::Get,
                                1u32 => Self::Head,
                                2u32 => Self::Post,
                                3u32 => Self::Put,
                                4u32 => Self::Delete,
                                5u32 => Self::Connect,
                                6u32 => Self::Options,
                                7u32 => Self::Trace,
                                8u32 => Self::Patch,
                                9u32 => {
                                    Self::Other(
                                        <String as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[9usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.Other },
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::Get,
                                1u8 => Self::Head,
                                2u8 => Self::Post,
                                3u8 => Self::Put,
                                4u8 => Self::Delete,
                                5u8 => Self::Connect,
                                6u8 => Self::Options,
                                7u8 => Self::Trace,
                                8u8 => Self::Patch,
                                9u8 => {
                                    Self::Other(
                                        <String as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[9usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerMethod<T9: Copy> {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadMethod<T9>,
                    }
                    #[automatically_derived]
                    impl<T9: ::core::clone::Clone + Copy> ::core::clone::Clone
                    for LowerMethod<T9> {
                        #[inline]
                        fn clone(&self) -> LowerMethod<T9> {
                            LowerMethod {
                                tag: ::core::clone::Clone::clone(&self.tag),
                                payload: ::core::clone::Clone::clone(&self.payload),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<T9: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerMethod<T9> {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadMethod<T9: Copy> {
                        Get: [wasmtime::ValRaw; 0],
                        Head: [wasmtime::ValRaw; 0],
                        Post: [wasmtime::ValRaw; 0],
                        Put: [wasmtime::ValRaw; 0],
                        Delete: [wasmtime::ValRaw; 0],
                        Connect: [wasmtime::ValRaw; 0],
                        Options: [wasmtime::ValRaw; 0],
                        Trace: [wasmtime::ValRaw; 0],
                        Patch: [wasmtime::ValRaw; 0],
                        Other: T9,
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<
                        T9: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerPayloadMethod<T9> {
                        #[inline]
                        fn clone(&self) -> LowerPayloadMethod<T9> {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<T9: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerPayloadMethod<T9> {}
                    unsafe impl wasmtime::component::ComponentType for Method {
                        type Lower = LowerMethod<
                            <String as wasmtime::component::ComponentType>::Lower,
                        >;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_variant(
                                ty,
                                types,
                                &[
                                    ("get", None),
                                    ("head", None),
                                    ("post", None),
                                    ("put", None),
                                    ("delete", None),
                                    ("connect", None),
                                    ("options", None),
                                    ("trace", None),
                                    ("patch", None),
                                    (
                                        "other",
                                        Some(
                                            <String as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                Some(<String as wasmtime::component::ComponentType>::ABI),
                            ],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for Method {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                        ];
                    }
                };
                impl core::fmt::Debug for Method {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            Method::Get => f.debug_tuple("Method::Get").finish(),
                            Method::Head => f.debug_tuple("Method::Head").finish(),
                            Method::Post => f.debug_tuple("Method::Post").finish(),
                            Method::Put => f.debug_tuple("Method::Put").finish(),
                            Method::Delete => f.debug_tuple("Method::Delete").finish(),
                            Method::Connect => f.debug_tuple("Method::Connect").finish(),
                            Method::Options => f.debug_tuple("Method::Options").finish(),
                            Method::Trace => f.debug_tuple("Method::Trace").finish(),
                            Method::Patch => f.debug_tuple("Method::Patch").finish(),
                            Method::Other(e) => {
                                f.debug_tuple("Method::Other").field(e).finish()
                            }
                        }
                    }
                }
                const _: () = {
                    if !(12 == <Method as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 12 == <Method as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Method as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Method as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// This type corresponds to HTTP standard Related Schemes.
                #[component(variant)]
                pub enum Scheme {
                    #[component(name = "HTTP")]
                    Http,
                    #[component(name = "HTTPS")]
                    Https,
                    #[component(name = "other")]
                    Other(String),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Scheme {
                    #[inline]
                    fn clone(&self) -> Scheme {
                        match self {
                            Scheme::Http => Scheme::Http,
                            Scheme::Https => Scheme::Https,
                            Scheme::Other(__self_0) => {
                                Scheme::Other(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lower for Scheme {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::Http => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Http)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Https => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Https)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Other(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Other)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[2usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::Http => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Https => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Other(value) => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for Scheme {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::Http,
                                1u32 => Self::Https,
                                2u32 => {
                                    Self::Other(
                                        <String as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[2usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.Other },
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::Http,
                                1u8 => Self::Https,
                                2u8 => {
                                    Self::Other(
                                        <String as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[2usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerScheme<T2: Copy> {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadScheme<T2>,
                    }
                    #[automatically_derived]
                    impl<T2: ::core::clone::Clone + Copy> ::core::clone::Clone
                    for LowerScheme<T2> {
                        #[inline]
                        fn clone(&self) -> LowerScheme<T2> {
                            LowerScheme {
                                tag: ::core::clone::Clone::clone(&self.tag),
                                payload: ::core::clone::Clone::clone(&self.payload),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<T2: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerScheme<T2> {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadScheme<T2: Copy> {
                        Http: [wasmtime::ValRaw; 0],
                        Https: [wasmtime::ValRaw; 0],
                        Other: T2,
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<
                        T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerPayloadScheme<T2> {
                        #[inline]
                        fn clone(&self) -> LowerPayloadScheme<T2> {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<T2: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerPayloadScheme<T2> {}
                    unsafe impl wasmtime::component::ComponentType for Scheme {
                        type Lower = LowerScheme<
                            <String as wasmtime::component::ComponentType>::Lower,
                        >;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_variant(
                                ty,
                                types,
                                &[
                                    ("HTTP", None),
                                    ("HTTPS", None),
                                    (
                                        "other",
                                        Some(
                                            <String as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[
                                None,
                                None,
                                Some(<String as wasmtime::component::ComponentType>::ABI),
                            ],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for Scheme {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[
                            None,
                            None,
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                        ];
                    }
                };
                impl core::fmt::Debug for Scheme {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            Scheme::Http => f.debug_tuple("Scheme::Http").finish(),
                            Scheme::Https => f.debug_tuple("Scheme::Https").finish(),
                            Scheme::Other(e) => {
                                f.debug_tuple("Scheme::Other").field(e).finish()
                            }
                        }
                    }
                }
                const _: () = {
                    if !(12 == <Scheme as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 12 == <Scheme as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Scheme as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Scheme as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Defines the case payload type for `DNS-error` above:
                #[component(record)]
                pub struct DnsErrorPayload {
                    #[component(name = "rcode")]
                    pub rcode: Option<String>,
                    #[component(name = "info-code")]
                    pub info_code: Option<u16>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for DnsErrorPayload {
                    #[inline]
                    fn clone(&self) -> DnsErrorPayload {
                        DnsErrorPayload {
                            rcode: ::core::clone::Clone::clone(&self.rcode),
                            info_code: ::core::clone::Clone::clone(&self.info_code),
                        }
                    }
                }
                unsafe impl wasmtime::component::Lower for DnsErrorPayload {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::lower(
                            &self.rcode,
                            cx,
                            ty.fields[0usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).rcode)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.info_code,
                            cx,
                            ty.fields[1usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).info_code)
                                    }
                                }
                            },
                        )?;
                        Ok(())
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::store(
                            &self.rcode,
                            cx,
                            ty.fields[0usize].ty,
                            <Option<String> as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.info_code,
                            cx,
                            ty.fields[1usize].ty,
                            <Option<u16> as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for DnsErrorPayload {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(Self {
                            rcode: <Option<
                                String,
                            > as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[0usize].ty,
                                &src.rcode,
                            )?,
                            info_code: <Option<
                                u16,
                            > as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[1usize].ty,
                                &src.info_code,
                            )?,
                        })
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let mut offset = 0;
                        Ok(Self {
                            rcode: <Option<
                                String,
                            > as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[0usize].ty,
                                &bytes[<Option<
                                    String,
                                > as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<Option<
                                    String,
                                > as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            info_code: <Option<
                                u16,
                            > as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[1usize].ty,
                                &bytes[<Option<
                                    u16,
                                > as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<Option<
                                    u16,
                                > as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                        })
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerDnsErrorPayload<T0: Copy, T1: Copy> {
                        rcode: T0,
                        info_code: T1,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::clone::Clone + Copy,
                        T1: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerDnsErrorPayload<T0, T1> {
                        #[inline]
                        fn clone(&self) -> LowerDnsErrorPayload<T0, T1> {
                            LowerDnsErrorPayload {
                                rcode: ::core::clone::Clone::clone(&self.rcode),
                                info_code: ::core::clone::Clone::clone(&self.info_code),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::marker::Copy + Copy,
                        T1: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy for LowerDnsErrorPayload<T0, T1> {}
                    unsafe impl wasmtime::component::ComponentType for DnsErrorPayload {
                        type Lower = LowerDnsErrorPayload<
                            <Option<
                                String,
                            > as wasmtime::component::ComponentType>::Lower,
                            <Option<u16> as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[
                                <Option<String> as wasmtime::component::ComponentType>::ABI,
                                <Option<u16> as wasmtime::component::ComponentType>::ABI,
                            ],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_record(
                                ty,
                                types,
                                &[
                                    (
                                        "rcode",
                                        <Option<
                                            String,
                                        > as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "info-code",
                                        <Option<
                                            u16,
                                        > as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ],
                            )
                        }
                    }
                };
                impl core::fmt::Debug for DnsErrorPayload {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("DnsErrorPayload")
                            .field("rcode", &self.rcode)
                            .field("info-code", &self.info_code)
                            .finish()
                    }
                }
                const _: () = {
                    if !(16
                        == <DnsErrorPayload as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 16 == <DnsErrorPayload as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4
                        == <DnsErrorPayload as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <DnsErrorPayload as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Defines the case payload type for `TLS-alert-received` above:
                #[component(record)]
                pub struct TlsAlertReceivedPayload {
                    #[component(name = "alert-id")]
                    pub alert_id: Option<u8>,
                    #[component(name = "alert-message")]
                    pub alert_message: Option<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for TlsAlertReceivedPayload {
                    #[inline]
                    fn clone(&self) -> TlsAlertReceivedPayload {
                        TlsAlertReceivedPayload {
                            alert_id: ::core::clone::Clone::clone(&self.alert_id),
                            alert_message: ::core::clone::Clone::clone(
                                &self.alert_message,
                            ),
                        }
                    }
                }
                unsafe impl wasmtime::component::Lower for TlsAlertReceivedPayload {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::lower(
                            &self.alert_id,
                            cx,
                            ty.fields[0usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).alert_id)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.alert_message,
                            cx,
                            ty.fields[1usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).alert_message)
                                    }
                                }
                            },
                        )?;
                        Ok(())
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::store(
                            &self.alert_id,
                            cx,
                            ty.fields[0usize].ty,
                            <Option<u8> as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.alert_message,
                            cx,
                            ty.fields[1usize].ty,
                            <Option<String> as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for TlsAlertReceivedPayload {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(Self {
                            alert_id: <Option<
                                u8,
                            > as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[0usize].ty,
                                &src.alert_id,
                            )?,
                            alert_message: <Option<
                                String,
                            > as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[1usize].ty,
                                &src.alert_message,
                            )?,
                        })
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let mut offset = 0;
                        Ok(Self {
                            alert_id: <Option<
                                u8,
                            > as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[0usize].ty,
                                &bytes[<Option<
                                    u8,
                                > as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<Option<
                                    u8,
                                > as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            alert_message: <Option<
                                String,
                            > as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[1usize].ty,
                                &bytes[<Option<
                                    String,
                                > as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<Option<
                                    String,
                                > as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                        })
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerTlsAlertReceivedPayload<T0: Copy, T1: Copy> {
                        alert_id: T0,
                        alert_message: T1,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::clone::Clone + Copy,
                        T1: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerTlsAlertReceivedPayload<T0, T1> {
                        #[inline]
                        fn clone(&self) -> LowerTlsAlertReceivedPayload<T0, T1> {
                            LowerTlsAlertReceivedPayload {
                                alert_id: ::core::clone::Clone::clone(&self.alert_id),
                                alert_message: ::core::clone::Clone::clone(
                                    &self.alert_message,
                                ),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::marker::Copy + Copy,
                        T1: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy for LowerTlsAlertReceivedPayload<T0, T1> {}
                    unsafe impl wasmtime::component::ComponentType
                    for TlsAlertReceivedPayload {
                        type Lower = LowerTlsAlertReceivedPayload<
                            <Option<u8> as wasmtime::component::ComponentType>::Lower,
                            <Option<String> as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[
                                <Option<u8> as wasmtime::component::ComponentType>::ABI,
                                <Option<String> as wasmtime::component::ComponentType>::ABI,
                            ],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_record(
                                ty,
                                types,
                                &[
                                    (
                                        "alert-id",
                                        <Option<
                                            u8,
                                        > as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "alert-message",
                                        <Option<
                                            String,
                                        > as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ],
                            )
                        }
                    }
                };
                impl core::fmt::Debug for TlsAlertReceivedPayload {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("TlsAlertReceivedPayload")
                            .field("alert-id", &self.alert_id)
                            .field("alert-message", &self.alert_message)
                            .finish()
                    }
                }
                const _: () = {
                    if !(16
                        == <TlsAlertReceivedPayload as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 16 == <TlsAlertReceivedPayload as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4
                        == <TlsAlertReceivedPayload as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <TlsAlertReceivedPayload as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Defines the case payload type for `HTTP-response-{header,trailer}-size` above:
                #[component(record)]
                pub struct FieldSizePayload {
                    #[component(name = "field-name")]
                    pub field_name: Option<String>,
                    #[component(name = "field-size")]
                    pub field_size: Option<u32>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for FieldSizePayload {
                    #[inline]
                    fn clone(&self) -> FieldSizePayload {
                        FieldSizePayload {
                            field_name: ::core::clone::Clone::clone(&self.field_name),
                            field_size: ::core::clone::Clone::clone(&self.field_size),
                        }
                    }
                }
                unsafe impl wasmtime::component::Lower for FieldSizePayload {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::lower(
                            &self.field_name,
                            cx,
                            ty.fields[0usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).field_name)
                                    }
                                }
                            },
                        )?;
                        wasmtime::component::Lower::lower(
                            &self.field_size,
                            cx,
                            ty.fields[1usize].ty,
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).field_size)
                                    }
                                }
                            },
                        )?;
                        Ok(())
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        wasmtime::component::Lower::store(
                            &self.field_name,
                            cx,
                            ty.fields[0usize].ty,
                            <Option<String> as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        wasmtime::component::Lower::store(
                            &self.field_size,
                            cx,
                            ty.fields[1usize].ty,
                            <Option<u32> as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(&mut offset),
                        )?;
                        Ok(())
                    }
                }
                unsafe impl wasmtime::component::Lift for FieldSizePayload {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(Self {
                            field_name: <Option<
                                String,
                            > as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[0usize].ty,
                                &src.field_name,
                            )?,
                            field_size: <Option<
                                u32,
                            > as wasmtime::component::Lift>::lift(
                                cx,
                                ty.fields[1usize].ty,
                                &src.field_size,
                            )?,
                        })
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Record(i) => {
                                &cx.types[i]
                            }
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !((bytes.as_ptr() as usize)
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        let mut offset = 0;
                        Ok(Self {
                            field_name: <Option<
                                String,
                            > as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[0usize].ty,
                                &bytes[<Option<
                                    String,
                                > as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<Option<
                                    String,
                                > as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                            field_size: <Option<
                                u32,
                            > as wasmtime::component::Lift>::load(
                                cx,
                                ty.fields[1usize].ty,
                                &bytes[<Option<
                                    u32,
                                > as wasmtime::component::ComponentType>::ABI
                                    .next_field32_size(
                                        &mut offset,
                                    )..][..<Option<
                                    u32,
                                > as wasmtime::component::ComponentType>::SIZE32],
                            )?,
                        })
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerFieldSizePayload<T0: Copy, T1: Copy> {
                        field_name: T0,
                        field_size: T1,
                        _align: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::clone::Clone + Copy,
                        T1: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerFieldSizePayload<T0, T1> {
                        #[inline]
                        fn clone(&self) -> LowerFieldSizePayload<T0, T1> {
                            LowerFieldSizePayload {
                                field_name: ::core::clone::Clone::clone(&self.field_name),
                                field_size: ::core::clone::Clone::clone(&self.field_size),
                                _align: ::core::clone::Clone::clone(&self._align),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T0: ::core::marker::Copy + Copy,
                        T1: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy for LowerFieldSizePayload<T0, T1> {}
                    unsafe impl wasmtime::component::ComponentType for FieldSizePayload {
                        type Lower = LowerFieldSizePayload<
                            <Option<
                                String,
                            > as wasmtime::component::ComponentType>::Lower,
                            <Option<u32> as wasmtime::component::ComponentType>::Lower,
                        >;
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                            &[
                                <Option<String> as wasmtime::component::ComponentType>::ABI,
                                <Option<u32> as wasmtime::component::ComponentType>::ABI,
                            ],
                        );
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_record(
                                ty,
                                types,
                                &[
                                    (
                                        "field-name",
                                        <Option<
                                            String,
                                        > as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                    (
                                        "field-size",
                                        <Option<
                                            u32,
                                        > as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ],
                            )
                        }
                    }
                };
                impl core::fmt::Debug for FieldSizePayload {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.debug_struct("FieldSizePayload")
                            .field("field-name", &self.field_name)
                            .field("field-size", &self.field_size)
                            .finish()
                    }
                }
                const _: () = {
                    if !(20
                        == <FieldSizePayload as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 20 == <FieldSizePayload as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4
                        == <FieldSizePayload as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <FieldSizePayload as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// These cases are inspired by the IANA HTTP Proxy Error Types:
                /// https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types
                #[component(variant)]
                pub enum ErrorCode {
                    #[component(name = "DNS-timeout")]
                    DnsTimeout,
                    #[component(name = "DNS-error")]
                    DnsError(DnsErrorPayload),
                    #[component(name = "destination-not-found")]
                    DestinationNotFound,
                    #[component(name = "destination-unavailable")]
                    DestinationUnavailable,
                    #[component(name = "destination-IP-prohibited")]
                    DestinationIpProhibited,
                    #[component(name = "destination-IP-unroutable")]
                    DestinationIpUnroutable,
                    #[component(name = "connection-refused")]
                    ConnectionRefused,
                    #[component(name = "connection-terminated")]
                    ConnectionTerminated,
                    #[component(name = "connection-timeout")]
                    ConnectionTimeout,
                    #[component(name = "connection-read-timeout")]
                    ConnectionReadTimeout,
                    #[component(name = "connection-write-timeout")]
                    ConnectionWriteTimeout,
                    #[component(name = "connection-limit-reached")]
                    ConnectionLimitReached,
                    #[component(name = "TLS-protocol-error")]
                    TlsProtocolError,
                    #[component(name = "TLS-certificate-error")]
                    TlsCertificateError,
                    #[component(name = "TLS-alert-received")]
                    TlsAlertReceived(TlsAlertReceivedPayload),
                    #[component(name = "HTTP-request-denied")]
                    HttpRequestDenied,
                    #[component(name = "HTTP-request-length-required")]
                    HttpRequestLengthRequired,
                    #[component(name = "HTTP-request-body-size")]
                    HttpRequestBodySize(Option<u64>),
                    #[component(name = "HTTP-request-method-invalid")]
                    HttpRequestMethodInvalid,
                    #[component(name = "HTTP-request-URI-invalid")]
                    HttpRequestUriInvalid,
                    #[component(name = "HTTP-request-URI-too-long")]
                    HttpRequestUriTooLong,
                    #[component(name = "HTTP-request-header-section-size")]
                    HttpRequestHeaderSectionSize(Option<u32>),
                    #[component(name = "HTTP-request-header-size")]
                    HttpRequestHeaderSize(Option<FieldSizePayload>),
                    #[component(name = "HTTP-request-trailer-section-size")]
                    HttpRequestTrailerSectionSize(Option<u32>),
                    #[component(name = "HTTP-request-trailer-size")]
                    HttpRequestTrailerSize(FieldSizePayload),
                    #[component(name = "HTTP-response-incomplete")]
                    HttpResponseIncomplete,
                    #[component(name = "HTTP-response-header-section-size")]
                    HttpResponseHeaderSectionSize(Option<u32>),
                    #[component(name = "HTTP-response-header-size")]
                    HttpResponseHeaderSize(FieldSizePayload),
                    #[component(name = "HTTP-response-body-size")]
                    HttpResponseBodySize(Option<u64>),
                    #[component(name = "HTTP-response-trailer-section-size")]
                    HttpResponseTrailerSectionSize(Option<u32>),
                    #[component(name = "HTTP-response-trailer-size")]
                    HttpResponseTrailerSize(FieldSizePayload),
                    #[component(name = "HTTP-response-transfer-coding")]
                    HttpResponseTransferCoding(Option<String>),
                    #[component(name = "HTTP-response-content-coding")]
                    HttpResponseContentCoding(Option<String>),
                    #[component(name = "HTTP-response-timeout")]
                    HttpResponseTimeout,
                    #[component(name = "HTTP-upgrade-failed")]
                    HttpUpgradeFailed,
                    #[component(name = "HTTP-protocol-error")]
                    HttpProtocolError,
                    #[component(name = "loop-detected")]
                    LoopDetected,
                    #[component(name = "configuration-error")]
                    ConfigurationError,
                    /// This is a catch-all error for anything that doesn't fit cleanly into a
                    /// more specific case. It also includes an optional string for an
                    /// unstructured description of the error. Users should not depend on the
                    /// string for diagnosing errors, as it's not required to be consistent
                    /// between implementations.
                    #[component(name = "internal-error")]
                    InternalError(Option<String>),
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ErrorCode {
                    #[inline]
                    fn clone(&self) -> ErrorCode {
                        match self {
                            ErrorCode::DnsTimeout => ErrorCode::DnsTimeout,
                            ErrorCode::DnsError(__self_0) => {
                                ErrorCode::DnsError(::core::clone::Clone::clone(__self_0))
                            }
                            ErrorCode::DestinationNotFound => {
                                ErrorCode::DestinationNotFound
                            }
                            ErrorCode::DestinationUnavailable => {
                                ErrorCode::DestinationUnavailable
                            }
                            ErrorCode::DestinationIpProhibited => {
                                ErrorCode::DestinationIpProhibited
                            }
                            ErrorCode::DestinationIpUnroutable => {
                                ErrorCode::DestinationIpUnroutable
                            }
                            ErrorCode::ConnectionRefused => ErrorCode::ConnectionRefused,
                            ErrorCode::ConnectionTerminated => {
                                ErrorCode::ConnectionTerminated
                            }
                            ErrorCode::ConnectionTimeout => ErrorCode::ConnectionTimeout,
                            ErrorCode::ConnectionReadTimeout => {
                                ErrorCode::ConnectionReadTimeout
                            }
                            ErrorCode::ConnectionWriteTimeout => {
                                ErrorCode::ConnectionWriteTimeout
                            }
                            ErrorCode::ConnectionLimitReached => {
                                ErrorCode::ConnectionLimitReached
                            }
                            ErrorCode::TlsProtocolError => ErrorCode::TlsProtocolError,
                            ErrorCode::TlsCertificateError => {
                                ErrorCode::TlsCertificateError
                            }
                            ErrorCode::TlsAlertReceived(__self_0) => {
                                ErrorCode::TlsAlertReceived(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpRequestDenied => ErrorCode::HttpRequestDenied,
                            ErrorCode::HttpRequestLengthRequired => {
                                ErrorCode::HttpRequestLengthRequired
                            }
                            ErrorCode::HttpRequestBodySize(__self_0) => {
                                ErrorCode::HttpRequestBodySize(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpRequestMethodInvalid => {
                                ErrorCode::HttpRequestMethodInvalid
                            }
                            ErrorCode::HttpRequestUriInvalid => {
                                ErrorCode::HttpRequestUriInvalid
                            }
                            ErrorCode::HttpRequestUriTooLong => {
                                ErrorCode::HttpRequestUriTooLong
                            }
                            ErrorCode::HttpRequestHeaderSectionSize(__self_0) => {
                                ErrorCode::HttpRequestHeaderSectionSize(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpRequestHeaderSize(__self_0) => {
                                ErrorCode::HttpRequestHeaderSize(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpRequestTrailerSectionSize(__self_0) => {
                                ErrorCode::HttpRequestTrailerSectionSize(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpRequestTrailerSize(__self_0) => {
                                ErrorCode::HttpRequestTrailerSize(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpResponseIncomplete => {
                                ErrorCode::HttpResponseIncomplete
                            }
                            ErrorCode::HttpResponseHeaderSectionSize(__self_0) => {
                                ErrorCode::HttpResponseHeaderSectionSize(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpResponseHeaderSize(__self_0) => {
                                ErrorCode::HttpResponseHeaderSize(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpResponseBodySize(__self_0) => {
                                ErrorCode::HttpResponseBodySize(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpResponseTrailerSectionSize(__self_0) => {
                                ErrorCode::HttpResponseTrailerSectionSize(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpResponseTrailerSize(__self_0) => {
                                ErrorCode::HttpResponseTrailerSize(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpResponseTransferCoding(__self_0) => {
                                ErrorCode::HttpResponseTransferCoding(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpResponseContentCoding(__self_0) => {
                                ErrorCode::HttpResponseContentCoding(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            ErrorCode::HttpResponseTimeout => {
                                ErrorCode::HttpResponseTimeout
                            }
                            ErrorCode::HttpUpgradeFailed => ErrorCode::HttpUpgradeFailed,
                            ErrorCode::HttpProtocolError => ErrorCode::HttpProtocolError,
                            ErrorCode::LoopDetected => ErrorCode::LoopDetected,
                            ErrorCode::ConfigurationError => {
                                ErrorCode::ConfigurationError
                            }
                            ErrorCode::InternalError(__self_0) => {
                                ErrorCode::InternalError(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lower for ErrorCode {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::DnsTimeout => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).DnsTimeout)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::DnsError(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).DnsError)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[1usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::DestinationNotFound => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).DestinationNotFound)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::DestinationUnavailable => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(3u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).DestinationUnavailable)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::DestinationIpProhibited => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(4u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).DestinationIpProhibited)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::DestinationIpUnroutable => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(5u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).DestinationIpUnroutable)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::ConnectionRefused => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(6u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).ConnectionRefused)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::ConnectionTerminated => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(7u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).ConnectionTerminated)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::ConnectionTimeout => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(8u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).ConnectionTimeout)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::ConnectionReadTimeout => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(9u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).ConnectionReadTimeout)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::ConnectionWriteTimeout => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(10u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).ConnectionWriteTimeout)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::ConnectionLimitReached => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(11u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).ConnectionLimitReached)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::TlsProtocolError => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(12u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).TlsProtocolError)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::TlsCertificateError => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(13u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).TlsCertificateError)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::TlsAlertReceived(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(14u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).TlsAlertReceived)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[14usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpRequestDenied => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(15u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpRequestDenied)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::HttpRequestLengthRequired => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(16u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpRequestLengthRequired)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::HttpRequestBodySize(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(17u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpRequestBodySize)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[17usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpRequestMethodInvalid => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(18u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpRequestMethodInvalid)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::HttpRequestUriInvalid => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(19u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpRequestUriInvalid)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::HttpRequestUriTooLong => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(20u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpRequestUriTooLong)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::HttpRequestHeaderSectionSize(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(21u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpRequestHeaderSectionSize)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[21usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpRequestHeaderSize(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(22u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpRequestHeaderSize)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[22usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpRequestTrailerSectionSize(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(23u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpRequestTrailerSectionSize)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[23usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpRequestTrailerSize(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(24u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpRequestTrailerSize)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[24usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpResponseIncomplete => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(25u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpResponseIncomplete)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::HttpResponseHeaderSectionSize(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(26u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpResponseHeaderSectionSize)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[26usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpResponseHeaderSize(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(27u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpResponseHeaderSize)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[27usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpResponseBodySize(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(28u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpResponseBodySize)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[28usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpResponseTrailerSectionSize(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(29u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpResponseTrailerSectionSize)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[29usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpResponseTrailerSize(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(30u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpResponseTrailerSize)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[30usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpResponseTransferCoding(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(31u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpResponseTransferCoding)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[31usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpResponseContentCoding(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(32u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpResponseContentCoding)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[32usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::HttpResponseTimeout => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(33u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpResponseTimeout)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::HttpUpgradeFailed => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(34u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpUpgradeFailed)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::HttpProtocolError => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(35u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).HttpProtocolError)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::LoopDetected => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(36u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).LoopDetected)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::ConfigurationError => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(37u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).ConfigurationError)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::InternalError(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(38u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).InternalError)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[38usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::DnsTimeout => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::DnsError(value) => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::DestinationNotFound => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                Ok(())
                            }
                            Self::DestinationUnavailable => {
                                *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                                Ok(())
                            }
                            Self::DestinationIpProhibited => {
                                *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                                Ok(())
                            }
                            Self::DestinationIpUnroutable => {
                                *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                                Ok(())
                            }
                            Self::ConnectionRefused => {
                                *cx.get::<1usize>(offset) = 6u8.to_le_bytes();
                                Ok(())
                            }
                            Self::ConnectionTerminated => {
                                *cx.get::<1usize>(offset) = 7u8.to_le_bytes();
                                Ok(())
                            }
                            Self::ConnectionTimeout => {
                                *cx.get::<1usize>(offset) = 8u8.to_le_bytes();
                                Ok(())
                            }
                            Self::ConnectionReadTimeout => {
                                *cx.get::<1usize>(offset) = 9u8.to_le_bytes();
                                Ok(())
                            }
                            Self::ConnectionWriteTimeout => {
                                *cx.get::<1usize>(offset) = 10u8.to_le_bytes();
                                Ok(())
                            }
                            Self::ConnectionLimitReached => {
                                *cx.get::<1usize>(offset) = 11u8.to_le_bytes();
                                Ok(())
                            }
                            Self::TlsProtocolError => {
                                *cx.get::<1usize>(offset) = 12u8.to_le_bytes();
                                Ok(())
                            }
                            Self::TlsCertificateError => {
                                *cx.get::<1usize>(offset) = 13u8.to_le_bytes();
                                Ok(())
                            }
                            Self::TlsAlertReceived(value) => {
                                *cx.get::<1usize>(offset) = 14u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[14usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpRequestDenied => {
                                *cx.get::<1usize>(offset) = 15u8.to_le_bytes();
                                Ok(())
                            }
                            Self::HttpRequestLengthRequired => {
                                *cx.get::<1usize>(offset) = 16u8.to_le_bytes();
                                Ok(())
                            }
                            Self::HttpRequestBodySize(value) => {
                                *cx.get::<1usize>(offset) = 17u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[17usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpRequestMethodInvalid => {
                                *cx.get::<1usize>(offset) = 18u8.to_le_bytes();
                                Ok(())
                            }
                            Self::HttpRequestUriInvalid => {
                                *cx.get::<1usize>(offset) = 19u8.to_le_bytes();
                                Ok(())
                            }
                            Self::HttpRequestUriTooLong => {
                                *cx.get::<1usize>(offset) = 20u8.to_le_bytes();
                                Ok(())
                            }
                            Self::HttpRequestHeaderSectionSize(value) => {
                                *cx.get::<1usize>(offset) = 21u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[21usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpRequestHeaderSize(value) => {
                                *cx.get::<1usize>(offset) = 22u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[22usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpRequestTrailerSectionSize(value) => {
                                *cx.get::<1usize>(offset) = 23u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[23usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpRequestTrailerSize(value) => {
                                *cx.get::<1usize>(offset) = 24u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[24usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpResponseIncomplete => {
                                *cx.get::<1usize>(offset) = 25u8.to_le_bytes();
                                Ok(())
                            }
                            Self::HttpResponseHeaderSectionSize(value) => {
                                *cx.get::<1usize>(offset) = 26u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[26usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpResponseHeaderSize(value) => {
                                *cx.get::<1usize>(offset) = 27u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[27usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpResponseBodySize(value) => {
                                *cx.get::<1usize>(offset) = 28u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[28usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpResponseTrailerSectionSize(value) => {
                                *cx.get::<1usize>(offset) = 29u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[29usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpResponseTrailerSize(value) => {
                                *cx.get::<1usize>(offset) = 30u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[30usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpResponseTransferCoding(value) => {
                                *cx.get::<1usize>(offset) = 31u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[31usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpResponseContentCoding(value) => {
                                *cx.get::<1usize>(offset) = 32u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[32usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::HttpResponseTimeout => {
                                *cx.get::<1usize>(offset) = 33u8.to_le_bytes();
                                Ok(())
                            }
                            Self::HttpUpgradeFailed => {
                                *cx.get::<1usize>(offset) = 34u8.to_le_bytes();
                                Ok(())
                            }
                            Self::HttpProtocolError => {
                                *cx.get::<1usize>(offset) = 35u8.to_le_bytes();
                                Ok(())
                            }
                            Self::LoopDetected => {
                                *cx.get::<1usize>(offset) = 36u8.to_le_bytes();
                                Ok(())
                            }
                            Self::ConfigurationError => {
                                *cx.get::<1usize>(offset) = 37u8.to_le_bytes();
                                Ok(())
                            }
                            Self::InternalError(value) => {
                                *cx.get::<1usize>(offset) = 38u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[38usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for ErrorCode {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::DnsTimeout,
                                1u32 => {
                                    Self::DnsError(
                                        <DnsErrorPayload as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[1usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.DnsError },
                                        )?,
                                    )
                                }
                                2u32 => Self::DestinationNotFound,
                                3u32 => Self::DestinationUnavailable,
                                4u32 => Self::DestinationIpProhibited,
                                5u32 => Self::DestinationIpUnroutable,
                                6u32 => Self::ConnectionRefused,
                                7u32 => Self::ConnectionTerminated,
                                8u32 => Self::ConnectionTimeout,
                                9u32 => Self::ConnectionReadTimeout,
                                10u32 => Self::ConnectionWriteTimeout,
                                11u32 => Self::ConnectionLimitReached,
                                12u32 => Self::TlsProtocolError,
                                13u32 => Self::TlsCertificateError,
                                14u32 => {
                                    Self::TlsAlertReceived(
                                        <TlsAlertReceivedPayload as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[14usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.TlsAlertReceived },
                                        )?,
                                    )
                                }
                                15u32 => Self::HttpRequestDenied,
                                16u32 => Self::HttpRequestLengthRequired,
                                17u32 => {
                                    Self::HttpRequestBodySize(
                                        <Option<
                                            u64,
                                        > as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[17usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpRequestBodySize },
                                        )?,
                                    )
                                }
                                18u32 => Self::HttpRequestMethodInvalid,
                                19u32 => Self::HttpRequestUriInvalid,
                                20u32 => Self::HttpRequestUriTooLong,
                                21u32 => {
                                    Self::HttpRequestHeaderSectionSize(
                                        <Option<
                                            u32,
                                        > as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[21usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpRequestHeaderSectionSize },
                                        )?,
                                    )
                                }
                                22u32 => {
                                    Self::HttpRequestHeaderSize(
                                        <Option<
                                            FieldSizePayload,
                                        > as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[22usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpRequestHeaderSize },
                                        )?,
                                    )
                                }
                                23u32 => {
                                    Self::HttpRequestTrailerSectionSize(
                                        <Option<
                                            u32,
                                        > as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[23usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpRequestTrailerSectionSize },
                                        )?,
                                    )
                                }
                                24u32 => {
                                    Self::HttpRequestTrailerSize(
                                        <FieldSizePayload as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[24usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpRequestTrailerSize },
                                        )?,
                                    )
                                }
                                25u32 => Self::HttpResponseIncomplete,
                                26u32 => {
                                    Self::HttpResponseHeaderSectionSize(
                                        <Option<
                                            u32,
                                        > as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[26usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpResponseHeaderSectionSize },
                                        )?,
                                    )
                                }
                                27u32 => {
                                    Self::HttpResponseHeaderSize(
                                        <FieldSizePayload as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[27usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpResponseHeaderSize },
                                        )?,
                                    )
                                }
                                28u32 => {
                                    Self::HttpResponseBodySize(
                                        <Option<
                                            u64,
                                        > as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[28usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpResponseBodySize },
                                        )?,
                                    )
                                }
                                29u32 => {
                                    Self::HttpResponseTrailerSectionSize(
                                        <Option<
                                            u32,
                                        > as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[29usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpResponseTrailerSectionSize },
                                        )?,
                                    )
                                }
                                30u32 => {
                                    Self::HttpResponseTrailerSize(
                                        <FieldSizePayload as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[30usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpResponseTrailerSize },
                                        )?,
                                    )
                                }
                                31u32 => {
                                    Self::HttpResponseTransferCoding(
                                        <Option<
                                            String,
                                        > as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[31usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpResponseTransferCoding },
                                        )?,
                                    )
                                }
                                32u32 => {
                                    Self::HttpResponseContentCoding(
                                        <Option<
                                            String,
                                        > as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[32usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.HttpResponseContentCoding },
                                        )?,
                                    )
                                }
                                33u32 => Self::HttpResponseTimeout,
                                34u32 => Self::HttpUpgradeFailed,
                                35u32 => Self::HttpProtocolError,
                                36u32 => Self::LoopDetected,
                                37u32 => Self::ConfigurationError,
                                38u32 => {
                                    Self::InternalError(
                                        <Option<
                                            String,
                                        > as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[38usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.InternalError },
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::DnsTimeout,
                                1u8 => {
                                    Self::DnsError(
                                        <DnsErrorPayload as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[1usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<DnsErrorPayload as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                2u8 => Self::DestinationNotFound,
                                3u8 => Self::DestinationUnavailable,
                                4u8 => Self::DestinationIpProhibited,
                                5u8 => Self::DestinationIpUnroutable,
                                6u8 => Self::ConnectionRefused,
                                7u8 => Self::ConnectionTerminated,
                                8u8 => Self::ConnectionTimeout,
                                9u8 => Self::ConnectionReadTimeout,
                                10u8 => Self::ConnectionWriteTimeout,
                                11u8 => Self::ConnectionLimitReached,
                                12u8 => Self::TlsProtocolError,
                                13u8 => Self::TlsCertificateError,
                                14u8 => {
                                    Self::TlsAlertReceived(
                                        <TlsAlertReceivedPayload as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[14usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<TlsAlertReceivedPayload as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                15u8 => Self::HttpRequestDenied,
                                16u8 => Self::HttpRequestLengthRequired,
                                17u8 => {
                                    Self::HttpRequestBodySize(
                                        <Option<
                                            u64,
                                        > as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[17usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Option<
                                                u64,
                                            > as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                18u8 => Self::HttpRequestMethodInvalid,
                                19u8 => Self::HttpRequestUriInvalid,
                                20u8 => Self::HttpRequestUriTooLong,
                                21u8 => {
                                    Self::HttpRequestHeaderSectionSize(
                                        <Option<
                                            u32,
                                        > as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[21usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Option<
                                                u32,
                                            > as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                22u8 => {
                                    Self::HttpRequestHeaderSize(
                                        <Option<
                                            FieldSizePayload,
                                        > as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[22usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Option<
                                                FieldSizePayload,
                                            > as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                23u8 => {
                                    Self::HttpRequestTrailerSectionSize(
                                        <Option<
                                            u32,
                                        > as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[23usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Option<
                                                u32,
                                            > as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                24u8 => {
                                    Self::HttpRequestTrailerSize(
                                        <FieldSizePayload as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[24usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<FieldSizePayload as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                25u8 => Self::HttpResponseIncomplete,
                                26u8 => {
                                    Self::HttpResponseHeaderSectionSize(
                                        <Option<
                                            u32,
                                        > as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[26usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Option<
                                                u32,
                                            > as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                27u8 => {
                                    Self::HttpResponseHeaderSize(
                                        <FieldSizePayload as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[27usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<FieldSizePayload as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                28u8 => {
                                    Self::HttpResponseBodySize(
                                        <Option<
                                            u64,
                                        > as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[28usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Option<
                                                u64,
                                            > as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                29u8 => {
                                    Self::HttpResponseTrailerSectionSize(
                                        <Option<
                                            u32,
                                        > as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[29usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Option<
                                                u32,
                                            > as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                30u8 => {
                                    Self::HttpResponseTrailerSize(
                                        <FieldSizePayload as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[30usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<FieldSizePayload as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                31u8 => {
                                    Self::HttpResponseTransferCoding(
                                        <Option<
                                            String,
                                        > as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[31usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Option<
                                                String,
                                            > as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                32u8 => {
                                    Self::HttpResponseContentCoding(
                                        <Option<
                                            String,
                                        > as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[32usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Option<
                                                String,
                                            > as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                33u8 => Self::HttpResponseTimeout,
                                34u8 => Self::HttpUpgradeFailed,
                                35u8 => Self::HttpProtocolError,
                                36u8 => Self::LoopDetected,
                                37u8 => Self::ConfigurationError,
                                38u8 => {
                                    Self::InternalError(
                                        <Option<
                                            String,
                                        > as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[38usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<Option<
                                                String,
                                            > as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerErrorCode<
                        T1: Copy,
                        T14: Copy,
                        T17: Copy,
                        T21: Copy,
                        T22: Copy,
                        T23: Copy,
                        T24: Copy,
                        T26: Copy,
                        T27: Copy,
                        T28: Copy,
                        T29: Copy,
                        T30: Copy,
                        T31: Copy,
                        T32: Copy,
                        T38: Copy,
                    > {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadErrorCode<
                            T1,
                            T14,
                            T17,
                            T21,
                            T22,
                            T23,
                            T24,
                            T26,
                            T27,
                            T28,
                            T29,
                            T30,
                            T31,
                            T32,
                            T38,
                        >,
                    }
                    #[automatically_derived]
                    impl<
                        T1: ::core::clone::Clone + Copy,
                        T14: ::core::clone::Clone + Copy,
                        T17: ::core::clone::Clone + Copy,
                        T21: ::core::clone::Clone + Copy,
                        T22: ::core::clone::Clone + Copy,
                        T23: ::core::clone::Clone + Copy,
                        T24: ::core::clone::Clone + Copy,
                        T26: ::core::clone::Clone + Copy,
                        T27: ::core::clone::Clone + Copy,
                        T28: ::core::clone::Clone + Copy,
                        T29: ::core::clone::Clone + Copy,
                        T30: ::core::clone::Clone + Copy,
                        T31: ::core::clone::Clone + Copy,
                        T32: ::core::clone::Clone + Copy,
                        T38: ::core::clone::Clone + Copy,
                    > ::core::clone::Clone
                    for LowerErrorCode<
                        T1,
                        T14,
                        T17,
                        T21,
                        T22,
                        T23,
                        T24,
                        T26,
                        T27,
                        T28,
                        T29,
                        T30,
                        T31,
                        T32,
                        T38,
                    > {
                        #[inline]
                        fn clone(
                            &self,
                        ) -> LowerErrorCode<
                            T1,
                            T14,
                            T17,
                            T21,
                            T22,
                            T23,
                            T24,
                            T26,
                            T27,
                            T28,
                            T29,
                            T30,
                            T31,
                            T32,
                            T38,
                        > {
                            LowerErrorCode {
                                tag: ::core::clone::Clone::clone(&self.tag),
                                payload: ::core::clone::Clone::clone(&self.payload),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<
                        T1: ::core::marker::Copy + Copy,
                        T14: ::core::marker::Copy + Copy,
                        T17: ::core::marker::Copy + Copy,
                        T21: ::core::marker::Copy + Copy,
                        T22: ::core::marker::Copy + Copy,
                        T23: ::core::marker::Copy + Copy,
                        T24: ::core::marker::Copy + Copy,
                        T26: ::core::marker::Copy + Copy,
                        T27: ::core::marker::Copy + Copy,
                        T28: ::core::marker::Copy + Copy,
                        T29: ::core::marker::Copy + Copy,
                        T30: ::core::marker::Copy + Copy,
                        T31: ::core::marker::Copy + Copy,
                        T32: ::core::marker::Copy + Copy,
                        T38: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy
                    for LowerErrorCode<
                        T1,
                        T14,
                        T17,
                        T21,
                        T22,
                        T23,
                        T24,
                        T26,
                        T27,
                        T28,
                        T29,
                        T30,
                        T31,
                        T32,
                        T38,
                    > {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadErrorCode<
                        T1: Copy,
                        T14: Copy,
                        T17: Copy,
                        T21: Copy,
                        T22: Copy,
                        T23: Copy,
                        T24: Copy,
                        T26: Copy,
                        T27: Copy,
                        T28: Copy,
                        T29: Copy,
                        T30: Copy,
                        T31: Copy,
                        T32: Copy,
                        T38: Copy,
                    > {
                        DnsTimeout: [wasmtime::ValRaw; 0],
                        DnsError: T1,
                        DestinationNotFound: [wasmtime::ValRaw; 0],
                        DestinationUnavailable: [wasmtime::ValRaw; 0],
                        DestinationIpProhibited: [wasmtime::ValRaw; 0],
                        DestinationIpUnroutable: [wasmtime::ValRaw; 0],
                        ConnectionRefused: [wasmtime::ValRaw; 0],
                        ConnectionTerminated: [wasmtime::ValRaw; 0],
                        ConnectionTimeout: [wasmtime::ValRaw; 0],
                        ConnectionReadTimeout: [wasmtime::ValRaw; 0],
                        ConnectionWriteTimeout: [wasmtime::ValRaw; 0],
                        ConnectionLimitReached: [wasmtime::ValRaw; 0],
                        TlsProtocolError: [wasmtime::ValRaw; 0],
                        TlsCertificateError: [wasmtime::ValRaw; 0],
                        TlsAlertReceived: T14,
                        HttpRequestDenied: [wasmtime::ValRaw; 0],
                        HttpRequestLengthRequired: [wasmtime::ValRaw; 0],
                        HttpRequestBodySize: T17,
                        HttpRequestMethodInvalid: [wasmtime::ValRaw; 0],
                        HttpRequestUriInvalid: [wasmtime::ValRaw; 0],
                        HttpRequestUriTooLong: [wasmtime::ValRaw; 0],
                        HttpRequestHeaderSectionSize: T21,
                        HttpRequestHeaderSize: T22,
                        HttpRequestTrailerSectionSize: T23,
                        HttpRequestTrailerSize: T24,
                        HttpResponseIncomplete: [wasmtime::ValRaw; 0],
                        HttpResponseHeaderSectionSize: T26,
                        HttpResponseHeaderSize: T27,
                        HttpResponseBodySize: T28,
                        HttpResponseTrailerSectionSize: T29,
                        HttpResponseTrailerSize: T30,
                        HttpResponseTransferCoding: T31,
                        HttpResponseContentCoding: T32,
                        HttpResponseTimeout: [wasmtime::ValRaw; 0],
                        HttpUpgradeFailed: [wasmtime::ValRaw; 0],
                        HttpProtocolError: [wasmtime::ValRaw; 0],
                        LoopDetected: [wasmtime::ValRaw; 0],
                        ConfigurationError: [wasmtime::ValRaw; 0],
                        InternalError: T38,
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<
                        T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T14: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T17: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T21: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T22: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T23: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T24: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T26: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T27: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T28: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T29: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T30: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T31: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T32: ::core::marker::Copy + ::core::clone::Clone + Copy,
                        T38: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    > ::core::clone::Clone
                    for LowerPayloadErrorCode<
                        T1,
                        T14,
                        T17,
                        T21,
                        T22,
                        T23,
                        T24,
                        T26,
                        T27,
                        T28,
                        T29,
                        T30,
                        T31,
                        T32,
                        T38,
                    > {
                        #[inline]
                        fn clone(
                            &self,
                        ) -> LowerPayloadErrorCode<
                            T1,
                            T14,
                            T17,
                            T21,
                            T22,
                            T23,
                            T24,
                            T26,
                            T27,
                            T28,
                            T29,
                            T30,
                            T31,
                            T32,
                            T38,
                        > {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<
                        T1: ::core::marker::Copy + Copy,
                        T14: ::core::marker::Copy + Copy,
                        T17: ::core::marker::Copy + Copy,
                        T21: ::core::marker::Copy + Copy,
                        T22: ::core::marker::Copy + Copy,
                        T23: ::core::marker::Copy + Copy,
                        T24: ::core::marker::Copy + Copy,
                        T26: ::core::marker::Copy + Copy,
                        T27: ::core::marker::Copy + Copy,
                        T28: ::core::marker::Copy + Copy,
                        T29: ::core::marker::Copy + Copy,
                        T30: ::core::marker::Copy + Copy,
                        T31: ::core::marker::Copy + Copy,
                        T32: ::core::marker::Copy + Copy,
                        T38: ::core::marker::Copy + Copy,
                    > ::core::marker::Copy
                    for LowerPayloadErrorCode<
                        T1,
                        T14,
                        T17,
                        T21,
                        T22,
                        T23,
                        T24,
                        T26,
                        T27,
                        T28,
                        T29,
                        T30,
                        T31,
                        T32,
                        T38,
                    > {}
                    unsafe impl wasmtime::component::ComponentType for ErrorCode {
                        type Lower = LowerErrorCode<
                            <DnsErrorPayload as wasmtime::component::ComponentType>::Lower,
                            <TlsAlertReceivedPayload as wasmtime::component::ComponentType>::Lower,
                            <Option<u64> as wasmtime::component::ComponentType>::Lower,
                            <Option<u32> as wasmtime::component::ComponentType>::Lower,
                            <Option<
                                FieldSizePayload,
                            > as wasmtime::component::ComponentType>::Lower,
                            <Option<u32> as wasmtime::component::ComponentType>::Lower,
                            <FieldSizePayload as wasmtime::component::ComponentType>::Lower,
                            <Option<u32> as wasmtime::component::ComponentType>::Lower,
                            <FieldSizePayload as wasmtime::component::ComponentType>::Lower,
                            <Option<u64> as wasmtime::component::ComponentType>::Lower,
                            <Option<u32> as wasmtime::component::ComponentType>::Lower,
                            <FieldSizePayload as wasmtime::component::ComponentType>::Lower,
                            <Option<
                                String,
                            > as wasmtime::component::ComponentType>::Lower,
                            <Option<
                                String,
                            > as wasmtime::component::ComponentType>::Lower,
                            <Option<String> as wasmtime::component::ComponentType>::Lower,
                        >;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_variant(
                                ty,
                                types,
                                &[
                                    ("DNS-timeout", None),
                                    (
                                        "DNS-error",
                                        Some(
                                            <DnsErrorPayload as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    ("destination-not-found", None),
                                    ("destination-unavailable", None),
                                    ("destination-IP-prohibited", None),
                                    ("destination-IP-unroutable", None),
                                    ("connection-refused", None),
                                    ("connection-terminated", None),
                                    ("connection-timeout", None),
                                    ("connection-read-timeout", None),
                                    ("connection-write-timeout", None),
                                    ("connection-limit-reached", None),
                                    ("TLS-protocol-error", None),
                                    ("TLS-certificate-error", None),
                                    (
                                        "TLS-alert-received",
                                        Some(
                                            <TlsAlertReceivedPayload as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    ("HTTP-request-denied", None),
                                    ("HTTP-request-length-required", None),
                                    (
                                        "HTTP-request-body-size",
                                        Some(
                                            <Option<
                                                u64,
                                            > as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    ("HTTP-request-method-invalid", None),
                                    ("HTTP-request-URI-invalid", None),
                                    ("HTTP-request-URI-too-long", None),
                                    (
                                        "HTTP-request-header-section-size",
                                        Some(
                                            <Option<
                                                u32,
                                            > as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "HTTP-request-header-size",
                                        Some(
                                            <Option<
                                                FieldSizePayload,
                                            > as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "HTTP-request-trailer-section-size",
                                        Some(
                                            <Option<
                                                u32,
                                            > as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "HTTP-request-trailer-size",
                                        Some(
                                            <FieldSizePayload as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    ("HTTP-response-incomplete", None),
                                    (
                                        "HTTP-response-header-section-size",
                                        Some(
                                            <Option<
                                                u32,
                                            > as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "HTTP-response-header-size",
                                        Some(
                                            <FieldSizePayload as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "HTTP-response-body-size",
                                        Some(
                                            <Option<
                                                u64,
                                            > as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "HTTP-response-trailer-section-size",
                                        Some(
                                            <Option<
                                                u32,
                                            > as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "HTTP-response-trailer-size",
                                        Some(
                                            <FieldSizePayload as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "HTTP-response-transfer-coding",
                                        Some(
                                            <Option<
                                                String,
                                            > as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    (
                                        "HTTP-response-content-coding",
                                        Some(
                                            <Option<
                                                String,
                                            > as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    ("HTTP-response-timeout", None),
                                    ("HTTP-upgrade-failed", None),
                                    ("HTTP-protocol-error", None),
                                    ("loop-detected", None),
                                    ("configuration-error", None),
                                    (
                                        "internal-error",
                                        Some(
                                            <Option<
                                                String,
                                            > as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[
                                None,
                                Some(
                                    <DnsErrorPayload as wasmtime::component::ComponentType>::ABI,
                                ),
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                None,
                                Some(
                                    <TlsAlertReceivedPayload as wasmtime::component::ComponentType>::ABI,
                                ),
                                None,
                                None,
                                Some(
                                    <Option<u64> as wasmtime::component::ComponentType>::ABI,
                                ),
                                None,
                                None,
                                None,
                                Some(
                                    <Option<u32> as wasmtime::component::ComponentType>::ABI,
                                ),
                                Some(
                                    <Option<
                                        FieldSizePayload,
                                    > as wasmtime::component::ComponentType>::ABI,
                                ),
                                Some(
                                    <Option<u32> as wasmtime::component::ComponentType>::ABI,
                                ),
                                Some(
                                    <FieldSizePayload as wasmtime::component::ComponentType>::ABI,
                                ),
                                None,
                                Some(
                                    <Option<u32> as wasmtime::component::ComponentType>::ABI,
                                ),
                                Some(
                                    <FieldSizePayload as wasmtime::component::ComponentType>::ABI,
                                ),
                                Some(
                                    <Option<u64> as wasmtime::component::ComponentType>::ABI,
                                ),
                                Some(
                                    <Option<u32> as wasmtime::component::ComponentType>::ABI,
                                ),
                                Some(
                                    <FieldSizePayload as wasmtime::component::ComponentType>::ABI,
                                ),
                                Some(
                                    <Option<String> as wasmtime::component::ComponentType>::ABI,
                                ),
                                Some(
                                    <Option<String> as wasmtime::component::ComponentType>::ABI,
                                ),
                                None,
                                None,
                                None,
                                None,
                                None,
                                Some(
                                    <Option<String> as wasmtime::component::ComponentType>::ABI,
                                ),
                            ],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for ErrorCode {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[
                            None,
                            Some(
                                <DnsErrorPayload as wasmtime::component::ComponentType>::ABI,
                            ),
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(
                                <TlsAlertReceivedPayload as wasmtime::component::ComponentType>::ABI,
                            ),
                            None,
                            None,
                            Some(
                                <Option<u64> as wasmtime::component::ComponentType>::ABI,
                            ),
                            None,
                            None,
                            None,
                            Some(
                                <Option<u32> as wasmtime::component::ComponentType>::ABI,
                            ),
                            Some(
                                <Option<
                                    FieldSizePayload,
                                > as wasmtime::component::ComponentType>::ABI,
                            ),
                            Some(
                                <Option<u32> as wasmtime::component::ComponentType>::ABI,
                            ),
                            Some(
                                <FieldSizePayload as wasmtime::component::ComponentType>::ABI,
                            ),
                            None,
                            Some(
                                <Option<u32> as wasmtime::component::ComponentType>::ABI,
                            ),
                            Some(
                                <FieldSizePayload as wasmtime::component::ComponentType>::ABI,
                            ),
                            Some(
                                <Option<u64> as wasmtime::component::ComponentType>::ABI,
                            ),
                            Some(
                                <Option<u32> as wasmtime::component::ComponentType>::ABI,
                            ),
                            Some(
                                <FieldSizePayload as wasmtime::component::ComponentType>::ABI,
                            ),
                            Some(
                                <Option<String> as wasmtime::component::ComponentType>::ABI,
                            ),
                            Some(
                                <Option<String> as wasmtime::component::ComponentType>::ABI,
                            ),
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(
                                <Option<String> as wasmtime::component::ComponentType>::ABI,
                            ),
                        ];
                    }
                };
                impl core::fmt::Debug for ErrorCode {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            ErrorCode::DnsTimeout => {
                                f.debug_tuple("ErrorCode::DnsTimeout").finish()
                            }
                            ErrorCode::DnsError(e) => {
                                f.debug_tuple("ErrorCode::DnsError").field(e).finish()
                            }
                            ErrorCode::DestinationNotFound => {
                                f.debug_tuple("ErrorCode::DestinationNotFound").finish()
                            }
                            ErrorCode::DestinationUnavailable => {
                                f.debug_tuple("ErrorCode::DestinationUnavailable").finish()
                            }
                            ErrorCode::DestinationIpProhibited => {
                                f.debug_tuple("ErrorCode::DestinationIpProhibited").finish()
                            }
                            ErrorCode::DestinationIpUnroutable => {
                                f.debug_tuple("ErrorCode::DestinationIpUnroutable").finish()
                            }
                            ErrorCode::ConnectionRefused => {
                                f.debug_tuple("ErrorCode::ConnectionRefused").finish()
                            }
                            ErrorCode::ConnectionTerminated => {
                                f.debug_tuple("ErrorCode::ConnectionTerminated").finish()
                            }
                            ErrorCode::ConnectionTimeout => {
                                f.debug_tuple("ErrorCode::ConnectionTimeout").finish()
                            }
                            ErrorCode::ConnectionReadTimeout => {
                                f.debug_tuple("ErrorCode::ConnectionReadTimeout").finish()
                            }
                            ErrorCode::ConnectionWriteTimeout => {
                                f.debug_tuple("ErrorCode::ConnectionWriteTimeout").finish()
                            }
                            ErrorCode::ConnectionLimitReached => {
                                f.debug_tuple("ErrorCode::ConnectionLimitReached").finish()
                            }
                            ErrorCode::TlsProtocolError => {
                                f.debug_tuple("ErrorCode::TlsProtocolError").finish()
                            }
                            ErrorCode::TlsCertificateError => {
                                f.debug_tuple("ErrorCode::TlsCertificateError").finish()
                            }
                            ErrorCode::TlsAlertReceived(e) => {
                                f.debug_tuple("ErrorCode::TlsAlertReceived")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpRequestDenied => {
                                f.debug_tuple("ErrorCode::HttpRequestDenied").finish()
                            }
                            ErrorCode::HttpRequestLengthRequired => {
                                f.debug_tuple("ErrorCode::HttpRequestLengthRequired")
                                    .finish()
                            }
                            ErrorCode::HttpRequestBodySize(e) => {
                                f.debug_tuple("ErrorCode::HttpRequestBodySize")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpRequestMethodInvalid => {
                                f.debug_tuple("ErrorCode::HttpRequestMethodInvalid")
                                    .finish()
                            }
                            ErrorCode::HttpRequestUriInvalid => {
                                f.debug_tuple("ErrorCode::HttpRequestUriInvalid").finish()
                            }
                            ErrorCode::HttpRequestUriTooLong => {
                                f.debug_tuple("ErrorCode::HttpRequestUriTooLong").finish()
                            }
                            ErrorCode::HttpRequestHeaderSectionSize(e) => {
                                f.debug_tuple("ErrorCode::HttpRequestHeaderSectionSize")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpRequestHeaderSize(e) => {
                                f.debug_tuple("ErrorCode::HttpRequestHeaderSize")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpRequestTrailerSectionSize(e) => {
                                f.debug_tuple("ErrorCode::HttpRequestTrailerSectionSize")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpRequestTrailerSize(e) => {
                                f.debug_tuple("ErrorCode::HttpRequestTrailerSize")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpResponseIncomplete => {
                                f.debug_tuple("ErrorCode::HttpResponseIncomplete").finish()
                            }
                            ErrorCode::HttpResponseHeaderSectionSize(e) => {
                                f.debug_tuple("ErrorCode::HttpResponseHeaderSectionSize")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpResponseHeaderSize(e) => {
                                f.debug_tuple("ErrorCode::HttpResponseHeaderSize")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpResponseBodySize(e) => {
                                f.debug_tuple("ErrorCode::HttpResponseBodySize")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpResponseTrailerSectionSize(e) => {
                                f.debug_tuple("ErrorCode::HttpResponseTrailerSectionSize")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpResponseTrailerSize(e) => {
                                f.debug_tuple("ErrorCode::HttpResponseTrailerSize")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpResponseTransferCoding(e) => {
                                f.debug_tuple("ErrorCode::HttpResponseTransferCoding")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpResponseContentCoding(e) => {
                                f.debug_tuple("ErrorCode::HttpResponseContentCoding")
                                    .field(e)
                                    .finish()
                            }
                            ErrorCode::HttpResponseTimeout => {
                                f.debug_tuple("ErrorCode::HttpResponseTimeout").finish()
                            }
                            ErrorCode::HttpUpgradeFailed => {
                                f.debug_tuple("ErrorCode::HttpUpgradeFailed").finish()
                            }
                            ErrorCode::HttpProtocolError => {
                                f.debug_tuple("ErrorCode::HttpProtocolError").finish()
                            }
                            ErrorCode::LoopDetected => {
                                f.debug_tuple("ErrorCode::LoopDetected").finish()
                            }
                            ErrorCode::ConfigurationError => {
                                f.debug_tuple("ErrorCode::ConfigurationError").finish()
                            }
                            ErrorCode::InternalError(e) => {
                                f.debug_tuple("ErrorCode::InternalError").field(e).finish()
                            }
                        }
                    }
                }
                impl core::fmt::Display for ErrorCode {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.write_fmt(format_args!("{0:?}", self))
                    }
                }
                impl std::error::Error for ErrorCode {}
                const _: () = {
                    if !(32 == <ErrorCode as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 32 == <ErrorCode as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <ErrorCode as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <ErrorCode as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// This type enumerates the different kinds of errors that may occur when
                /// setting or appending to a `fields` resource.
                #[component(variant)]
                pub enum HeaderError {
                    /// This error indicates that a `field-key` or `field-value` was
                    /// syntactically invalid when used with an operation that sets headers in a
                    /// `fields`.
                    #[component(name = "invalid-syntax")]
                    InvalidSyntax,
                    /// This error indicates that a forbidden `field-key` was used when trying
                    /// to set a header in a `fields`.
                    #[component(name = "forbidden")]
                    Forbidden,
                    /// This error indicates that the operation on the `fields` was not
                    /// permitted because the fields are immutable.
                    #[component(name = "immutable")]
                    Immutable,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for HeaderError {}
                #[automatically_derived]
                impl ::core::clone::Clone for HeaderError {
                    #[inline]
                    fn clone(&self) -> HeaderError {
                        *self
                    }
                }
                unsafe impl wasmtime::component::Lower for HeaderError {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::InvalidSyntax => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).InvalidSyntax)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Forbidden => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Forbidden)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                            Self::Immutable => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(2u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Immutable)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::InvalidSyntax => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Forbidden => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                            Self::Immutable => {
                                *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for HeaderError {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => Self::InvalidSyntax,
                                1u32 => Self::Forbidden,
                                2u32 => Self::Immutable,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => Self::InvalidSyntax,
                                1u8 => Self::Forbidden,
                                2u8 => Self::Immutable,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerHeaderError {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadHeaderError,
                    }
                    #[automatically_derived]
                    impl ::core::clone::Clone for LowerHeaderError {
                        #[inline]
                        fn clone(&self) -> LowerHeaderError {
                            let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                            let _: ::core::clone::AssertParamIsClone<
                                LowerPayloadHeaderError,
                            >;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for LowerHeaderError {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadHeaderError {
                        InvalidSyntax: [wasmtime::ValRaw; 0],
                        Forbidden: [wasmtime::ValRaw; 0],
                        Immutable: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::clone::Clone for LowerPayloadHeaderError {
                        #[inline]
                        fn clone(&self) -> LowerPayloadHeaderError {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl ::core::marker::Copy for LowerPayloadHeaderError {}
                    unsafe impl wasmtime::component::ComponentType for HeaderError {
                        type Lower = LowerHeaderError;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_variant(
                                ty,
                                types,
                                &[
                                    ("invalid-syntax", None),
                                    ("forbidden", None),
                                    ("immutable", None),
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[None, None, None],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for HeaderError {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[None, None, None];
                    }
                };
                impl core::fmt::Debug for HeaderError {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            HeaderError::InvalidSyntax => {
                                f.debug_tuple("HeaderError::InvalidSyntax").finish()
                            }
                            HeaderError::Forbidden => {
                                f.debug_tuple("HeaderError::Forbidden").finish()
                            }
                            HeaderError::Immutable => {
                                f.debug_tuple("HeaderError::Immutable").finish()
                            }
                        }
                    }
                }
                impl core::fmt::Display for HeaderError {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.write_fmt(format_args!("{0:?}", self))
                    }
                }
                impl std::error::Error for HeaderError {}
                const _: () = {
                    if !(1
                        == <HeaderError as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <HeaderError as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1
                        == <HeaderError as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <HeaderError as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Field keys are always strings.
                pub type FieldKey = String;
                const _: () = {
                    if !(8 == <FieldKey as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <FieldKey as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <FieldKey as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <FieldKey as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Field values should always be ASCII strings. However, in
                /// reality, HTTP implementations often have to interpret malformed values,
                /// so they are provided as a list of bytes.
                pub type FieldValue = Vec<u8>;
                const _: () = {
                    if !(8 == <FieldValue as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <FieldValue as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4
                        == <FieldValue as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <FieldValue as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// This following block defines the `fields` resource which corresponds to
                /// HTTP standard Fields. Fields are a common representation used for both
                /// Headers and Trailers.
                ///
                /// A `fields` may be mutable or immutable. A `fields` created using the
                /// constructor, `from-list`, or `clone` will be mutable, but a `fields`
                /// resource given by other means (including, but not limited to,
                /// `incoming-request.headers`, `outgoing-request.headers`) might be be
                /// immutable. In an immutable fields, the `set`, `append`, and `delete`
                /// operations will fail with `header-error.immutable`.
                pub enum Fields {}
                pub trait HostFields {
                    /// Construct an empty HTTP Fields.
                    ///
                    /// The resulting `fields` is mutable.
                    fn new(
                        &mut self,
                    ) -> wasmtime::Result<wasmtime::component::Resource<Fields>>;
                    /// Construct an HTTP Fields.
                    ///
                    /// The resulting `fields` is mutable.
                    ///
                    /// The list represents each key-value pair in the Fields. Keys
                    /// which have multiple values are represented by multiple entries in this
                    /// list with the same key.
                    ///
                    /// The tuple is a pair of the field key, represented as a string, and
                    /// Value, represented as a list of bytes. In a valid Fields, all keys
                    /// and values are valid UTF-8 strings. However, values are not always
                    /// well-formed, so they are represented as a raw list of bytes.
                    ///
                    /// An error result will be returned if any header or value was
                    /// syntactically invalid, or if a header was forbidden.
                    fn from_list(
                        &mut self,
                        entries: Vec<(FieldKey, FieldValue)>,
                    ) -> wasmtime::Result<
                        Result<wasmtime::component::Resource<Fields>, HeaderError>,
                    >;
                    /// Get all of the values corresponding to a key. If the key is not present
                    /// in this `fields`, an empty list is returned. However, if the key is
                    /// present but empty, this is represented by a list with one or more
                    /// empty field-values present.
                    fn get(
                        &mut self,
                        self_: wasmtime::component::Resource<Fields>,
                        name: FieldKey,
                    ) -> wasmtime::Result<Vec<FieldValue>>;
                    /// Returns `true` when the key is present in this `fields`. If the key is
                    /// syntactically invalid, `false` is returned.
                    fn has(
                        &mut self,
                        self_: wasmtime::component::Resource<Fields>,
                        name: FieldKey,
                    ) -> wasmtime::Result<bool>;
                    /// Set all of the values for a key. Clears any existing values for that
                    /// key, if they have been set.
                    ///
                    /// Fails with `header-error.immutable` if the `fields` are immutable.
                    fn set(
                        &mut self,
                        self_: wasmtime::component::Resource<Fields>,
                        name: FieldKey,
                        value: Vec<FieldValue>,
                    ) -> wasmtime::Result<Result<(), HeaderError>>;
                    /// Delete all values for a key. Does nothing if no values for the key
                    /// exist.
                    ///
                    /// Fails with `header-error.immutable` if the `fields` are immutable.
                    fn delete(
                        &mut self,
                        self_: wasmtime::component::Resource<Fields>,
                        name: FieldKey,
                    ) -> wasmtime::Result<Result<(), HeaderError>>;
                    /// Append a value for a key. Does not change or delete any existing
                    /// values for that key.
                    ///
                    /// Fails with `header-error.immutable` if the `fields` are immutable.
                    fn append(
                        &mut self,
                        self_: wasmtime::component::Resource<Fields>,
                        name: FieldKey,
                        value: FieldValue,
                    ) -> wasmtime::Result<Result<(), HeaderError>>;
                    /// Retrieve the full set of keys and values in the Fields. Like the
                    /// constructor, the list represents each key-value pair.
                    ///
                    /// The outer list represents each key-value pair in the Fields. Keys
                    /// which have multiple values are represented by multiple entries in this
                    /// list with the same key.
                    fn entries(
                        &mut self,
                        self_: wasmtime::component::Resource<Fields>,
                    ) -> wasmtime::Result<Vec<(FieldKey, FieldValue)>>;
                    /// Make a deep copy of the Fields. Equivelant in behavior to calling the
                    /// `fields` constructor on the return value of `entries`. The resulting
                    /// `fields` is mutable.
                    fn clone(
                        &mut self,
                        self_: wasmtime::component::Resource<Fields>,
                    ) -> wasmtime::Result<wasmtime::component::Resource<Fields>>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<Fields>,
                    ) -> wasmtime::Result<()>;
                }
                /// Headers is an alias for Fields.
                pub type Headers = Fields;
                /// Trailers is an alias for Fields.
                pub type Trailers = Fields;
                /// Represents an incoming HTTP Request.
                pub enum IncomingRequest {}
                pub trait HostIncomingRequest {
                    /// Returns the method of the incoming request.
                    fn method(
                        &mut self,
                        self_: wasmtime::component::Resource<IncomingRequest>,
                    ) -> wasmtime::Result<Method>;
                    /// Returns the path with query parameters from the request, as a string.
                    fn path_with_query(
                        &mut self,
                        self_: wasmtime::component::Resource<IncomingRequest>,
                    ) -> wasmtime::Result<Option<String>>;
                    /// Returns the protocol scheme from the request.
                    fn scheme(
                        &mut self,
                        self_: wasmtime::component::Resource<IncomingRequest>,
                    ) -> wasmtime::Result<Option<Scheme>>;
                    /// Returns the authority from the request, if it was present.
                    fn authority(
                        &mut self,
                        self_: wasmtime::component::Resource<IncomingRequest>,
                    ) -> wasmtime::Result<Option<String>>;
                    /// Get the `headers` associated with the request.
                    ///
                    /// The returned `headers` resource is immutable: `set`, `append`, and
                    /// `delete` operations will fail with `header-error.immutable`.
                    ///
                    /// The `headers` returned are a child resource: it must be dropped before
                    /// the parent `incoming-request` is dropped. Dropping this
                    /// `incoming-request` before all children are dropped will trap.
                    fn headers(
                        &mut self,
                        self_: wasmtime::component::Resource<IncomingRequest>,
                    ) -> wasmtime::Result<wasmtime::component::Resource<Headers>>;
                    /// Gives the `incoming-body` associated with this request. Will only
                    /// return success at most once, and subsequent calls will return error.
                    fn consume(
                        &mut self,
                        self_: wasmtime::component::Resource<IncomingRequest>,
                    ) -> wasmtime::Result<
                        Result<wasmtime::component::Resource<IncomingBody>, ()>,
                    >;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<IncomingRequest>,
                    ) -> wasmtime::Result<()>;
                }
                /// Represents an outgoing HTTP Request.
                pub enum OutgoingRequest {}
                pub trait HostOutgoingRequest {
                    /// Construct a new `outgoing-request` with a default `method` of `GET`, and
                    /// `none` values for `path-with-query`, `scheme`, and `authority`.
                    ///
                    /// * `headers` is the HTTP Headers for the Request.
                    ///
                    /// It is possible to construct, or manipulate with the accessor functions
                    /// below, an `outgoing-request` with an invalid combination of `scheme`
                    /// and `authority`, or `headers` which are not permitted to be sent.
                    /// It is the obligation of the `outgoing-handler.handle` implementation
                    /// to reject invalid constructions of `outgoing-request`.
                    fn new(
                        &mut self,
                        headers: wasmtime::component::Resource<Headers>,
                    ) -> wasmtime::Result<
                        wasmtime::component::Resource<OutgoingRequest>,
                    >;
                    /// Returns the resource corresponding to the outgoing Body for this
                    /// Request.
                    ///
                    /// Returns success on the first call: the `outgoing-body` resource for
                    /// this `outgoing-request` can be retrieved at most once. Subsequent
                    /// calls will return error.
                    fn body(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingRequest>,
                    ) -> wasmtime::Result<
                        Result<wasmtime::component::Resource<OutgoingBody>, ()>,
                    >;
                    /// Get the Method for the Request.
                    fn method(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingRequest>,
                    ) -> wasmtime::Result<Method>;
                    /// Set the Method for the Request. Fails if the string present in a
                    /// `method.other` argument is not a syntactically valid method.
                    fn set_method(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingRequest>,
                        method: Method,
                    ) -> wasmtime::Result<Result<(), ()>>;
                    /// Get the combination of the HTTP Path and Query for the Request.
                    /// When `none`, this represents an empty Path and empty Query.
                    fn path_with_query(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingRequest>,
                    ) -> wasmtime::Result<Option<String>>;
                    /// Set the combination of the HTTP Path and Query for the Request.
                    /// When `none`, this represents an empty Path and empty Query. Fails is the
                    /// string given is not a syntactically valid path and query uri component.
                    fn set_path_with_query(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingRequest>,
                        path_with_query: Option<String>,
                    ) -> wasmtime::Result<Result<(), ()>>;
                    /// Get the HTTP Related Scheme for the Request. When `none`, the
                    /// implementation may choose an appropriate default scheme.
                    fn scheme(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingRequest>,
                    ) -> wasmtime::Result<Option<Scheme>>;
                    /// Set the HTTP Related Scheme for the Request. When `none`, the
                    /// implementation may choose an appropriate default scheme. Fails if the
                    /// string given is not a syntactically valid uri scheme.
                    fn set_scheme(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingRequest>,
                        scheme: Option<Scheme>,
                    ) -> wasmtime::Result<Result<(), ()>>;
                    /// Get the HTTP Authority for the Request. A value of `none` may be used
                    /// with Related Schemes which do not require an Authority. The HTTP and
                    /// HTTPS schemes always require an authority.
                    fn authority(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingRequest>,
                    ) -> wasmtime::Result<Option<String>>;
                    /// Set the HTTP Authority for the Request. A value of `none` may be used
                    /// with Related Schemes which do not require an Authority. The HTTP and
                    /// HTTPS schemes always require an authority. Fails if the string given is
                    /// not a syntactically valid uri authority.
                    fn set_authority(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingRequest>,
                        authority: Option<String>,
                    ) -> wasmtime::Result<Result<(), ()>>;
                    /// Get the headers associated with the Request.
                    ///
                    /// The returned `headers` resource is immutable: `set`, `append`, and
                    /// `delete` operations will fail with `header-error.immutable`.
                    ///
                    /// This headers resource is a child: it must be dropped before the parent
                    /// `outgoing-request` is dropped, or its ownership is transfered to
                    /// another component by e.g. `outgoing-handler.handle`.
                    fn headers(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingRequest>,
                    ) -> wasmtime::Result<wasmtime::component::Resource<Headers>>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<OutgoingRequest>,
                    ) -> wasmtime::Result<()>;
                }
                /// Parameters for making an HTTP Request. Each of these parameters is
                /// currently an optional timeout applicable to the transport layer of the
                /// HTTP protocol.
                ///
                /// These timeouts are separate from any the user may use to bound a
                /// blocking call to `wasi:io/poll.poll`.
                pub enum RequestOptions {}
                pub trait HostRequestOptions {
                    /// Construct a default `request-options` value.
                    fn new(
                        &mut self,
                    ) -> wasmtime::Result<wasmtime::component::Resource<RequestOptions>>;
                    /// The timeout for the initial connect to the HTTP Server.
                    fn connect_timeout(
                        &mut self,
                        self_: wasmtime::component::Resource<RequestOptions>,
                    ) -> wasmtime::Result<Option<Duration>>;
                    /// Set the timeout for the initial connect to the HTTP Server. An error
                    /// return value indicates that this timeout is not supported.
                    fn set_connect_timeout(
                        &mut self,
                        self_: wasmtime::component::Resource<RequestOptions>,
                        duration: Option<Duration>,
                    ) -> wasmtime::Result<Result<(), ()>>;
                    /// The timeout for receiving the first byte of the Response body.
                    fn first_byte_timeout(
                        &mut self,
                        self_: wasmtime::component::Resource<RequestOptions>,
                    ) -> wasmtime::Result<Option<Duration>>;
                    /// Set the timeout for receiving the first byte of the Response body. An
                    /// error return value indicates that this timeout is not supported.
                    fn set_first_byte_timeout(
                        &mut self,
                        self_: wasmtime::component::Resource<RequestOptions>,
                        duration: Option<Duration>,
                    ) -> wasmtime::Result<Result<(), ()>>;
                    /// The timeout for receiving subsequent chunks of bytes in the Response
                    /// body stream.
                    fn between_bytes_timeout(
                        &mut self,
                        self_: wasmtime::component::Resource<RequestOptions>,
                    ) -> wasmtime::Result<Option<Duration>>;
                    /// Set the timeout for receiving subsequent chunks of bytes in the Response
                    /// body stream. An error return value indicates that this timeout is not
                    /// supported.
                    fn set_between_bytes_timeout(
                        &mut self,
                        self_: wasmtime::component::Resource<RequestOptions>,
                        duration: Option<Duration>,
                    ) -> wasmtime::Result<Result<(), ()>>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<RequestOptions>,
                    ) -> wasmtime::Result<()>;
                }
                /// Represents the ability to send an HTTP Response.
                ///
                /// This resource is used by the `wasi:http/incoming-handler` interface to
                /// allow a Response to be sent corresponding to the Request provided as the
                /// other argument to `incoming-handler.handle`.
                pub enum ResponseOutparam {}
                pub trait HostResponseOutparam {
                    /// Set the value of the `response-outparam` to either send a response,
                    /// or indicate an error.
                    ///
                    /// This method consumes the `response-outparam` to ensure that it is
                    /// called at most once. If it is never called, the implementation
                    /// will respond with an error.
                    ///
                    /// The user may provide an `error` to `response` to allow the
                    /// implementation determine how to respond with an HTTP error response.
                    fn set(
                        &mut self,
                        param: wasmtime::component::Resource<ResponseOutparam>,
                        response: Result<
                            wasmtime::component::Resource<OutgoingResponse>,
                            ErrorCode,
                        >,
                    ) -> wasmtime::Result<()>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<ResponseOutparam>,
                    ) -> wasmtime::Result<()>;
                }
                /// This type corresponds to the HTTP standard Status Code.
                pub type StatusCode = u16;
                const _: () = {
                    if !(2 == <StatusCode as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 2 == <StatusCode as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(2
                        == <StatusCode as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 2 == <StatusCode as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// Represents an incoming HTTP Response.
                pub enum IncomingResponse {}
                pub trait HostIncomingResponse {
                    /// Returns the status code from the incoming response.
                    fn status(
                        &mut self,
                        self_: wasmtime::component::Resource<IncomingResponse>,
                    ) -> wasmtime::Result<StatusCode>;
                    /// Returns the headers from the incoming response.
                    ///
                    /// The returned `headers` resource is immutable: `set`, `append`, and
                    /// `delete` operations will fail with `header-error.immutable`.
                    ///
                    /// This headers resource is a child: it must be dropped before the parent
                    /// `incoming-response` is dropped.
                    fn headers(
                        &mut self,
                        self_: wasmtime::component::Resource<IncomingResponse>,
                    ) -> wasmtime::Result<wasmtime::component::Resource<Headers>>;
                    /// Returns the incoming body. May be called at most once. Returns error
                    /// if called additional times.
                    fn consume(
                        &mut self,
                        self_: wasmtime::component::Resource<IncomingResponse>,
                    ) -> wasmtime::Result<
                        Result<wasmtime::component::Resource<IncomingBody>, ()>,
                    >;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<IncomingResponse>,
                    ) -> wasmtime::Result<()>;
                }
                /// Represents an incoming HTTP Request or Response's Body.
                ///
                /// A body has both its contents - a stream of bytes - and a (possibly
                /// empty) set of trailers, indicating that the full contents of the
                /// body have been received. This resource represents the contents as
                /// an `input-stream` and the delivery of trailers as a `future-trailers`,
                /// and ensures that the user of this interface may only be consuming either
                /// the body contents or waiting on trailers at any given time.
                pub enum IncomingBody {}
                pub trait HostIncomingBody {
                    /// Returns the contents of the body, as a stream of bytes.
                    ///
                    /// Returns success on first call: the stream representing the contents
                    /// can be retrieved at most once. Subsequent calls will return error.
                    ///
                    /// The returned `input-stream` resource is a child: it must be dropped
                    /// before the parent `incoming-body` is dropped, or consumed by
                    /// `incoming-body.finish`.
                    ///
                    /// This invariant ensures that the implementation can determine whether
                    /// the user is consuming the contents of the body, waiting on the
                    /// `future-trailers` to be ready, or neither. This allows for network
                    /// backpressure is to be applied when the user is consuming the body,
                    /// and for that backpressure to not inhibit delivery of the trailers if
                    /// the user does not read the entire body.
                    fn stream(
                        &mut self,
                        self_: wasmtime::component::Resource<IncomingBody>,
                    ) -> wasmtime::Result<
                        Result<wasmtime::component::Resource<InputStream>, ()>,
                    >;
                    /// Takes ownership of `incoming-body`, and returns a `future-trailers`.
                    /// This function will trap if the `input-stream` child is still alive.
                    fn finish(
                        &mut self,
                        this: wasmtime::component::Resource<IncomingBody>,
                    ) -> wasmtime::Result<wasmtime::component::Resource<FutureTrailers>>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<IncomingBody>,
                    ) -> wasmtime::Result<()>;
                }
                /// Represents a future which may eventaully return trailers, or an error.
                ///
                /// In the case that the incoming HTTP Request or Response did not have any
                /// trailers, this future will resolve to the empty set of trailers once the
                /// complete Request or Response body has been received.
                pub enum FutureTrailers {}
                pub trait HostFutureTrailers {
                    /// Returns a pollable which becomes ready when either the trailers have
                    /// been received, or an error has occured. When this pollable is ready,
                    /// the `get` method will return `some`.
                    /// subscribe: func() -> pollable; // Hermes does NOT support `poll`
                    /// Returns the contents of the trailers, or an error which occured,
                    /// once the future is ready.
                    ///
                    /// The outer `option` represents future readiness. Users can wait on this
                    /// `option` to become `some` using the `subscribe` method.
                    ///
                    /// The outer `result` is used to retrieve the trailers or error at most
                    /// once. It will be success on the first call in which the outer option
                    /// is `some`, and error on subsequent calls.
                    ///
                    /// The inner `result` represents that either the HTTP Request or Response
                    /// body, as well as any trailers, were received successfully, or that an
                    /// error occured receiving them. The optional `trailers` indicates whether
                    /// or not trailers were present in the body.
                    ///
                    /// When some `trailers` are returned by this method, the `trailers`
                    /// resource is immutable, and a child. Use of the `set`, `append`, or
                    /// `delete` methods will return an error, and the resource must be
                    /// dropped before the parent `future-trailers` is dropped.
                    fn get(
                        &mut self,
                        self_: wasmtime::component::Resource<FutureTrailers>,
                    ) -> wasmtime::Result<
                        Option<
                            Result<
                                Result<
                                    Option<wasmtime::component::Resource<Trailers>>,
                                    ErrorCode,
                                >,
                                (),
                            >,
                        >,
                    >;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<FutureTrailers>,
                    ) -> wasmtime::Result<()>;
                }
                /// Represents an outgoing HTTP Response.
                pub enum OutgoingResponse {}
                pub trait HostOutgoingResponse {
                    /// Construct an `outgoing-response`, with a default `status-code` of `200`.
                    /// If a different `status-code` is needed, it must be set via the
                    /// `set-status-code` method.
                    ///
                    /// * `headers` is the HTTP Headers for the Response.
                    fn new(
                        &mut self,
                        headers: wasmtime::component::Resource<Headers>,
                    ) -> wasmtime::Result<
                        wasmtime::component::Resource<OutgoingResponse>,
                    >;
                    /// Get the HTTP Status Code for the Response.
                    fn status_code(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingResponse>,
                    ) -> wasmtime::Result<StatusCode>;
                    /// Set the HTTP Status Code for the Response. Fails if the status-code
                    /// given is not a valid http status code.
                    fn set_status_code(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingResponse>,
                        status_code: StatusCode,
                    ) -> wasmtime::Result<Result<(), ()>>;
                    /// Get the headers associated with the Request.
                    ///
                    /// The returned `headers` resource is immutable: `set`, `append`, and
                    /// `delete` operations will fail with `header-error.immutable`.
                    ///
                    /// This headers resource is a child: it must be dropped before the parent
                    /// `outgoing-request` is dropped, or its ownership is transfered to
                    /// another component by e.g. `outgoing-handler.handle`.
                    fn headers(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingResponse>,
                    ) -> wasmtime::Result<wasmtime::component::Resource<Headers>>;
                    /// Returns the resource corresponding to the outgoing Body for this Response.
                    ///
                    /// Returns success on the first call: the `outgoing-body` resource for
                    /// this `outgoing-response` can be retrieved at most once. Subsequent
                    /// calls will return error.
                    fn body(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingResponse>,
                    ) -> wasmtime::Result<
                        Result<wasmtime::component::Resource<OutgoingBody>, ()>,
                    >;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<OutgoingResponse>,
                    ) -> wasmtime::Result<()>;
                }
                /// Represents an outgoing HTTP Request or Response's Body.
                ///
                /// A body has both its contents - a stream of bytes - and a (possibly
                /// empty) set of trailers, inducating the full contents of the body
                /// have been sent. This resource represents the contents as an
                /// `output-stream` child resource, and the completion of the body (with
                /// optional trailers) with a static function that consumes the
                /// `outgoing-body` resource, and ensures that the user of this interface
                /// may not write to the body contents after the body has been finished.
                ///
                /// If the user code drops this resource, as opposed to calling the static
                /// method `finish`, the implementation should treat the body as incomplete,
                /// and that an error has occured. The implementation should propogate this
                /// error to the HTTP protocol by whatever means it has available,
                /// including: corrupting the body on the wire, aborting the associated
                /// Request, or sending a late status code for the Response.
                pub enum OutgoingBody {}
                pub trait HostOutgoingBody {
                    /// Returns a stream for writing the body contents.
                    ///
                    /// The returned `output-stream` is a child resource: it must be dropped
                    /// before the parent `outgoing-body` resource is dropped (or finished),
                    /// otherwise the `outgoing-body` drop or `finish` will trap.
                    ///
                    /// Returns success on the first call: the `output-stream` resource for
                    /// this `outgoing-body` may be retrieved at most once. Subsequent calls
                    /// will return error.
                    fn write(
                        &mut self,
                        self_: wasmtime::component::Resource<OutgoingBody>,
                    ) -> wasmtime::Result<
                        Result<wasmtime::component::Resource<OutputStream>, ()>,
                    >;
                    /// Finalize an outgoing body, optionally providing trailers. This must be
                    /// called to signal that the response is complete. If the `outgoing-body`
                    /// is dropped without calling `outgoing-body.finalize`, the implementation
                    /// should treat the body as corrupted.
                    ///
                    /// Fails if the body's `outgoing-request` or `outgoing-response` was
                    /// constructed with a Content-Length header, and the contents written
                    /// to the body (via `write`) does not match the value given in the
                    /// Content-Length.
                    fn finish(
                        &mut self,
                        this: wasmtime::component::Resource<OutgoingBody>,
                        trailers: Option<wasmtime::component::Resource<Trailers>>,
                    ) -> wasmtime::Result<Result<(), ErrorCode>>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<OutgoingBody>,
                    ) -> wasmtime::Result<()>;
                }
                /// Represents a future which may eventaully return an incoming HTTP
                /// Response, or an error.
                ///
                /// This resource is returned by the `wasi:http/outgoing-handler` interface to
                /// provide the HTTP Response corresponding to the sent Request.
                pub enum FutureIncomingResponse {}
                pub trait HostFutureIncomingResponse {
                    /// *
                    ///     /// Returns a pollable which becomes ready when either the Response has
                    ///     /// been received, or an error has occured. When this pollable is ready,
                    ///     /// the `get` method will return `some`.
                    ///     subscribe: func() -> pollable;
                    ///     */
                    /// Returns the incoming HTTP Response, or an error, once one is ready.
                    ///
                    /// The outer `option` represents future readiness. Users can wait on this
                    /// `option` to become `some` using the `subscribe` method.
                    ///
                    /// The outer `result` is used to retrieve the response or error at most
                    /// once. It will be success on the first call in which the outer option
                    /// is `some`, and error on subsequent calls.
                    ///
                    /// The inner `result` represents that either the incoming HTTP Response
                    /// status and headers have recieved successfully, or that an error
                    /// occured. Errors may also occur while consuming the response body,
                    /// but those will be reported by the `incoming-body` and its
                    /// `output-stream` child.
                    fn get(
                        &mut self,
                        self_: wasmtime::component::Resource<FutureIncomingResponse>,
                    ) -> wasmtime::Result<
                        Option<
                            Result<
                                Result<
                                    wasmtime::component::Resource<IncomingResponse>,
                                    ErrorCode,
                                >,
                                (),
                            >,
                        >,
                    >;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<FutureIncomingResponse>,
                    ) -> wasmtime::Result<()>;
                }
                pub trait Host: HostFields + HostIncomingRequest + HostOutgoingRequest + HostRequestOptions + HostResponseOutparam + HostIncomingResponse + HostIncomingBody + HostFutureTrailers + HostOutgoingResponse + HostOutgoingBody + HostFutureIncomingResponse {
                    /// Attempts to extract a http-related `error` from the wasi:io `error`
                    /// provided.
                    ///
                    /// Stream operations which return
                    /// `wasi:io/stream/stream-error::last-operation-failed` have a payload of
                    /// type `wasi:io/error/error` with more information about the operation
                    /// that failed. This payload can be passed through to this function to see
                    /// if there's http-related information about the error to return.
                    ///
                    /// Note that this function is fallible because not all io-errors are
                    /// http-related errors.
                    fn http_error_code(
                        &mut self,
                        err: wasmtime::component::Resource<IoError>,
                    ) -> wasmtime::Result<Option<ErrorCode>>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:http/types@0.2.0")?;
                    inst.resource(
                        "fields",
                        wasmtime::component::ResourceType::host::<Fields>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostFields::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "incoming-request",
                        wasmtime::component::ResourceType::host::<IncomingRequest>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostIncomingRequest::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "outgoing-request",
                        wasmtime::component::ResourceType::host::<OutgoingRequest>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostOutgoingRequest::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "request-options",
                        wasmtime::component::ResourceType::host::<RequestOptions>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostRequestOptions::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "response-outparam",
                        wasmtime::component::ResourceType::host::<ResponseOutparam>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostResponseOutparam::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "incoming-response",
                        wasmtime::component::ResourceType::host::<IncomingResponse>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostIncomingResponse::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "incoming-body",
                        wasmtime::component::ResourceType::host::<IncomingBody>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostIncomingBody::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "future-trailers",
                        wasmtime::component::ResourceType::host::<FutureTrailers>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostFutureTrailers::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "outgoing-response",
                        wasmtime::component::ResourceType::host::<OutgoingResponse>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostOutgoingResponse::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "outgoing-body",
                        wasmtime::component::ResourceType::host::<OutgoingBody>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostOutgoingBody::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "future-incoming-response",
                        wasmtime::component::ResourceType::host::<
                            FutureIncomingResponse,
                        >(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostFutureIncomingResponse::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.func_wrap(
                        "http-error-code",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IoError>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::http_error_code(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[constructor]fields",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = HostFields::new(host);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[static]fields.from-list",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (Vec<(FieldKey, FieldValue)>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostFields::from_list(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]fields.get",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<Fields>, FieldKey)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostFields::get(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]fields.has",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<Fields>, FieldKey)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostFields::has(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]fields.set",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (
                                wasmtime::component::Resource<Fields>,
                                FieldKey,
                                Vec<FieldValue>,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostFields::set(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]fields.delete",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<Fields>, FieldKey)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostFields::delete(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]fields.append",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (
                                wasmtime::component::Resource<Fields>,
                                FieldKey,
                                FieldValue,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostFields::append(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]fields.entries",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Fields>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostFields::entries(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]fields.clone",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Fields>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostFields::clone(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]incoming-request.method",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IncomingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostIncomingRequest::method(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]incoming-request.path-with-query",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IncomingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostIncomingRequest::path_with_query(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]incoming-request.scheme",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IncomingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostIncomingRequest::scheme(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]incoming-request.authority",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IncomingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostIncomingRequest::authority(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]incoming-request.headers",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IncomingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostIncomingRequest::headers(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]incoming-request.consume",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IncomingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostIncomingRequest::consume(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[constructor]outgoing-request",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Headers>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingRequest::new(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-request.body",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutgoingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingRequest::body(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-request.method",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutgoingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingRequest::method(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-request.set-method",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<OutgoingRequest>, Method)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingRequest::set_method(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-request.path-with-query",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutgoingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingRequest::path_with_query(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-request.set-path-with-query",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (
                                wasmtime::component::Resource<OutgoingRequest>,
                                Option<String>,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingRequest::set_path_with_query(
                                host,
                                arg0,
                                arg1,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-request.scheme",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutgoingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingRequest::scheme(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-request.set-scheme",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (
                                wasmtime::component::Resource<OutgoingRequest>,
                                Option<Scheme>,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingRequest::set_scheme(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-request.authority",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutgoingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingRequest::authority(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-request.set-authority",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (
                                wasmtime::component::Resource<OutgoingRequest>,
                                Option<String>,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingRequest::set_authority(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-request.headers",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutgoingRequest>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingRequest::headers(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[constructor]request-options",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = HostRequestOptions::new(host);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]request-options.connect-timeout",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<RequestOptions>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostRequestOptions::connect_timeout(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]request-options.set-connect-timeout",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (
                                wasmtime::component::Resource<RequestOptions>,
                                Option<Duration>,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostRequestOptions::set_connect_timeout(
                                host,
                                arg0,
                                arg1,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]request-options.first-byte-timeout",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<RequestOptions>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostRequestOptions::first_byte_timeout(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]request-options.set-first-byte-timeout",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (
                                wasmtime::component::Resource<RequestOptions>,
                                Option<Duration>,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostRequestOptions::set_first_byte_timeout(
                                host,
                                arg0,
                                arg1,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]request-options.between-bytes-timeout",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<RequestOptions>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostRequestOptions::between_bytes_timeout(
                                host,
                                arg0,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]request-options.set-between-bytes-timeout",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (
                                wasmtime::component::Resource<RequestOptions>,
                                Option<Duration>,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostRequestOptions::set_between_bytes_timeout(
                                host,
                                arg0,
                                arg1,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[static]response-outparam.set",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (
                                wasmtime::component::Resource<ResponseOutparam>,
                                Result<
                                    wasmtime::component::Resource<OutgoingResponse>,
                                    ErrorCode,
                                >,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostResponseOutparam::set(host, arg0, arg1);
                            r
                        },
                    )?;
                    inst.func_wrap(
                        "[method]incoming-response.status",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IncomingResponse>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostIncomingResponse::status(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]incoming-response.headers",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IncomingResponse>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostIncomingResponse::headers(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]incoming-response.consume",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IncomingResponse>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostIncomingResponse::consume(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]incoming-body.stream",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IncomingBody>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostIncomingBody::stream(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[static]incoming-body.finish",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<IncomingBody>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostIncomingBody::finish(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]future-trailers.get",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<FutureTrailers>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostFutureTrailers::get(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[constructor]outgoing-response",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Headers>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingResponse::new(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-response.status-code",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutgoingResponse>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingResponse::status_code(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-response.set-status-code",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (
                                wasmtime::component::Resource<OutgoingResponse>,
                                StatusCode,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingResponse::set_status_code(
                                host,
                                arg0,
                                arg1,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-response.headers",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutgoingResponse>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingResponse::headers(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-response.body",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutgoingResponse>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingResponse::body(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]outgoing-body.write",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutgoingBody>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingBody::write(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[static]outgoing-body.finish",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (
                                wasmtime::component::Resource<OutgoingBody>,
                                Option<wasmtime::component::Resource<Trailers>>,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutgoingBody::finish(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]future-incoming-response.get",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                            ): (wasmtime::component::Resource<FutureIncomingResponse>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostFutureIncomingResponse::get(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
            #[allow(clippy::all)]
            pub mod outgoing_handler {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type OutgoingRequest = super::super::super::wasi::http::types::OutgoingRequest;
                pub type RequestOptions = super::super::super::wasi::http::types::RequestOptions;
                pub type FutureIncomingResponse = super::super::super::wasi::http::types::FutureIncomingResponse;
                pub type ErrorCode = super::super::super::wasi::http::types::ErrorCode;
                const _: () = {
                    if !(32 == <ErrorCode as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 32 == <ErrorCode as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(8 == <ErrorCode as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <ErrorCode as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub trait Host {
                    /// This function is invoked with an outgoing HTTP Request, and it returns
                    /// a resource `future-incoming-response` which represents an HTTP Response
                    /// which may arrive in the future.
                    ///
                    /// The `options` argument accepts optional parameters for the HTTP
                    /// protocol's transport layer.
                    ///
                    /// This function may return an error if the `outgoing-request` is invalid
                    /// or not allowed to be made. Otherwise, protocol errors are reported
                    /// through the `future-incoming-response`.
                    fn handle(
                        &mut self,
                        request: wasmtime::component::Resource<OutgoingRequest>,
                        options: Option<wasmtime::component::Resource<RequestOptions>>,
                    ) -> wasmtime::Result<
                        Result<
                            wasmtime::component::Resource<FutureIncomingResponse>,
                            ErrorCode,
                        >,
                    >;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:http/outgoing-handler@0.2.0")?;
                    inst.func_wrap(
                        "handle",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (
                                wasmtime::component::Resource<OutgoingRequest>,
                                Option<wasmtime::component::Resource<RequestOptions>>,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::handle(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod io {
            #[allow(clippy::all)]
            pub mod error {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                /// A resource which represents some error information.
                ///
                /// The only method provided by this resource is `to-debug-string`,
                /// which provides some human-readable information about the error.
                ///
                /// In the `wasi:io` package, this resource is returned through the
                /// `wasi:io/streams/stream-error` type.
                ///
                /// To provide more specific error information, other interfaces may
                /// provide functions to further "downcast" this error into more specific
                /// error information. For example, `error`s returned in streams derived
                /// from filesystem types to be described using the filesystem's own
                /// error-code type, using the function
                /// `wasi:filesystem/types/filesystem-error-code`, which takes a parameter
                /// `borrow<error>` and returns
                /// `option<wasi:filesystem/types/error-code>`.
                ///
                /// The set of functions which can "downcast" an `error` into a more
                /// concrete type is open.
                pub enum Error {}
                pub trait HostError {
                    /// Returns a string that is suitable to assist humans in debugging
                    /// this error.
                    ///
                    /// WARNING: The returned string should not be consumed mechanically!
                    /// It may change across platforms, hosts, or other implementation
                    /// details. Parsing this string is a major platform-compatibility
                    /// hazard.
                    fn to_debug_string(
                        &mut self,
                        self_: wasmtime::component::Resource<Error>,
                    ) -> wasmtime::Result<String>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<Error>,
                    ) -> wasmtime::Result<()>;
                }
                pub trait Host: HostError {}
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:io/error@0.2.0")?;
                    inst.resource(
                        "error",
                        wasmtime::component::ResourceType::host::<Error>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostError::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.func_wrap(
                        "[method]error.to-debug-string",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<Error>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostError::to_debug_string(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
            #[allow(clippy::all)]
            pub mod streams {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Error = super::super::super::wasi::io::error::Error;
                /// *
                ///     // Hermes does not support `poll`
                ///     use poll.{pollable};
                ///     */
                /// An error for input-stream and output-stream operations.
                #[component(variant)]
                pub enum StreamError {
                    /// The last operation (a write or flush) failed before completion.
                    ///
                    /// More information is available in the `error` payload.
                    #[component(name = "last-operation-failed")]
                    LastOperationFailed(wasmtime::component::Resource<Error>),
                    /// The stream is closed: no more input will be accepted by the
                    /// stream. A closed output-stream will return this error on all
                    /// future operations.
                    #[component(name = "closed")]
                    Closed,
                }
                unsafe impl wasmtime::component::Lower for StreamError {
                    #[inline]
                    fn lower<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        dst: &mut std::mem::MaybeUninit<Self::Lower>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        match self {
                            Self::LastOperationFailed(value) => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(0u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).LastOperationFailed)
                                                }
                                            }
                                        },
                                        |dst| {
                                            value
                                                .lower(
                                                    cx,
                                                    ty
                                                        .cases[0usize]
                                                        .ty
                                                        .unwrap_or_else(
                                                            wasmtime::component::__internal::bad_type_info,
                                                        ),
                                                    dst,
                                                )
                                        },
                                    )
                                }
                            }
                            Self::Closed => {
                                {
                                    #[allow(unused_unsafe)]
                                    {
                                        unsafe {
                                            use ::wasmtime::component::__internal::MaybeUninitExt;
                                            let m: &mut std::mem::MaybeUninit<_> = dst;
                                            m.map(|p| &raw mut (*p).tag)
                                        }
                                    }
                                }
                                    .write(wasmtime::ValRaw::u32(1u32));
                                unsafe {
                                    wasmtime::component::__internal::lower_payload(
                                        {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                                    m.map(|p| &raw mut (*p).payload)
                                                }
                                            }
                                        },
                                        |payload| {
                                            #[allow(unused_unsafe)]
                                            {
                                                unsafe {
                                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                                    let m: &mut std::mem::MaybeUninit<_> = payload;
                                                    m.map(|p| &raw mut (*p).Closed)
                                                }
                                            }
                                        },
                                        |dst| Ok(()),
                                    )
                                }
                            }
                        }
                    }
                    #[inline]
                    fn store<T>(
                        &self,
                        cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        mut offset: usize,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        if true {
                            if !(offset
                                % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                    as usize) == 0)
                            {
                                ::core::panicking::panic(
                                    "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                )
                            }
                        }
                        match self {
                            Self::LastOperationFailed(value) => {
                                *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                                value
                                    .store(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        offset
                                            + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                    )
                            }
                            Self::Closed => {
                                *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                                Ok(())
                            }
                        }
                    }
                }
                unsafe impl wasmtime::component::Lift for StreamError {
                    #[inline]
                    fn lift(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        src: &Self::Lower,
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match src.tag.get_u32() {
                                0u32 => {
                                    Self::LastOperationFailed(
                                        <wasmtime::component::Resource<
                                            Error,
                                        > as wasmtime::component::Lift>::lift(
                                            cx,
                                            ty
                                                .cases[0usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            unsafe { &src.payload.LastOperationFailed },
                                        )?,
                                    )
                                }
                                1u32 => Self::Closed,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                    #[inline]
                    fn load(
                        cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                        ty: wasmtime::component::__internal::InterfaceType,
                        bytes: &[u8],
                    ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                        let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                        if true {
                            if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                                ::core::panicking::panic(
                                    "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                                )
                            }
                        }
                        let discrim = bytes[0];
                        let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                        let payload = &bytes[payload_offset..];
                        let ty = match ty {
                            wasmtime::component::__internal::InterfaceType::Variant(
                                i,
                            ) => &cx.types[i],
                            _ => wasmtime::component::__internal::bad_type_info(),
                        };
                        Ok(
                            match discrim {
                                0u8 => {
                                    Self::LastOperationFailed(
                                        <wasmtime::component::Resource<
                                            Error,
                                        > as wasmtime::component::Lift>::load(
                                            cx,
                                            ty
                                                .cases[0usize]
                                                .ty
                                                .unwrap_or_else(
                                                    wasmtime::component::__internal::bad_type_info,
                                                ),
                                            &payload[..<wasmtime::component::Resource<
                                                Error,
                                            > as wasmtime::component::ComponentType>::SIZE32],
                                        )?,
                                    )
                                }
                                1u8 => Self::Closed,
                                discrim => {
                                    return ::anyhow::__private::Err(
                                        ::anyhow::Error::msg({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected discriminant: {0}", discrim),
                                            );
                                            res
                                        }),
                                    );
                                }
                            },
                        )
                    }
                }
                const _: () = {
                    #[doc(hidden)]
                    #[repr(C)]
                    pub struct LowerStreamError<T0: Copy> {
                        tag: wasmtime::ValRaw,
                        payload: LowerPayloadStreamError<T0>,
                    }
                    #[automatically_derived]
                    impl<T0: ::core::clone::Clone + Copy> ::core::clone::Clone
                    for LowerStreamError<T0> {
                        #[inline]
                        fn clone(&self) -> LowerStreamError<T0> {
                            LowerStreamError {
                                tag: ::core::clone::Clone::clone(&self.tag),
                                payload: ::core::clone::Clone::clone(&self.payload),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<T0: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerStreamError<T0> {}
                    #[doc(hidden)]
                    #[allow(non_snake_case)]
                    #[repr(C)]
                    union LowerPayloadStreamError<T0: Copy> {
                        LastOperationFailed: T0,
                        Closed: [wasmtime::ValRaw; 0],
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<
                        T0: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    > ::core::clone::Clone for LowerPayloadStreamError<T0> {
                        #[inline]
                        fn clone(&self) -> LowerPayloadStreamError<T0> {
                            let _: ::core::clone::AssertParamIsCopy<Self>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    #[allow(non_snake_case)]
                    impl<T0: ::core::marker::Copy + Copy> ::core::marker::Copy
                    for LowerPayloadStreamError<T0> {}
                    unsafe impl wasmtime::component::ComponentType for StreamError {
                        type Lower = LowerStreamError<
                            <wasmtime::component::Resource<
                                Error,
                            > as wasmtime::component::ComponentType>::Lower,
                        >;
                        #[inline]
                        fn typecheck(
                            ty: &wasmtime::component::__internal::InterfaceType,
                            types: &wasmtime::component::__internal::InstanceType<'_>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            wasmtime::component::__internal::typecheck_variant(
                                ty,
                                types,
                                &[
                                    (
                                        "last-operation-failed",
                                        Some(
                                            <wasmtime::component::Resource<
                                                Error,
                                            > as wasmtime::component::ComponentType>::typecheck,
                                        ),
                                    ),
                                    ("closed", None),
                                ],
                            )
                        }
                        const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                            &[
                                Some(
                                    <wasmtime::component::Resource<
                                        Error,
                                    > as wasmtime::component::ComponentType>::ABI,
                                ),
                                None,
                            ],
                        );
                    }
                    unsafe impl wasmtime::component::__internal::ComponentVariant
                    for StreamError {
                        const CASES: &'static [Option<
                            wasmtime::component::__internal::CanonicalAbiInfo,
                        >] = &[
                            Some(
                                <wasmtime::component::Resource<
                                    Error,
                                > as wasmtime::component::ComponentType>::ABI,
                            ),
                            None,
                        ];
                    }
                };
                impl core::fmt::Debug for StreamError {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        match self {
                            StreamError::LastOperationFailed(e) => {
                                f.debug_tuple("StreamError::LastOperationFailed")
                                    .field(e)
                                    .finish()
                            }
                            StreamError::Closed => {
                                f.debug_tuple("StreamError::Closed").finish()
                            }
                        }
                    }
                }
                impl core::fmt::Display for StreamError {
                    fn fmt(
                        &self,
                        f: &mut core::fmt::Formatter<'_>,
                    ) -> core::fmt::Result {
                        f.write_fmt(format_args!("{0:?}", self))
                    }
                }
                impl std::error::Error for StreamError {}
                const _: () = {
                    if !(8
                        == <StreamError as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <StreamError as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4
                        == <StreamError as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <StreamError as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                /// An input bytestream.
                ///
                /// `input-stream`s are *non-blocking* to the extent practical on underlying
                /// platforms. I/O operations always return promptly; if fewer bytes are
                /// promptly available than requested, they return the number of bytes promptly
                /// available, which could even be zero. To wait for data to be available,
                /// use the `subscribe` function to obtain a `pollable` which can be polled
                /// for using `wasi:io/poll`.
                pub enum InputStream {}
                pub trait HostInputStream {
                    /// Perform a non-blocking read from the stream.
                    ///
                    /// This function returns a list of bytes containing the read data,
                    /// when successful. The returned list will contain up to `len` bytes;
                    /// it may return fewer than requested, but not more. The list is
                    /// empty when no bytes are available for reading at this time. The
                    /// pollable given by `subscribe` will be ready when more bytes are
                    /// available.
                    ///
                    /// This function fails with a `stream-error` when the operation
                    /// encounters an error, giving `last-operation-failed`, or when the
                    /// stream is closed, giving `closed`.
                    ///
                    /// When the caller gives a `len` of 0, it represents a request to
                    /// read 0 bytes. If the stream is still open, this call should
                    /// succeed and return an empty list, or otherwise fail with `closed`.
                    ///
                    /// The `len` parameter is a `u64`, which could represent a list of u8 which
                    /// is not possible to allocate in wasm32, or not desirable to allocate as
                    /// as a return value by the callee. The callee may return a list of bytes
                    /// less than `len` in size while more bytes are available for reading.
                    fn read(
                        &mut self,
                        self_: wasmtime::component::Resource<InputStream>,
                        len: u64,
                    ) -> wasmtime::Result<Result<Vec<u8>, StreamError>>;
                    /// Read bytes from a stream, after blocking until at least one byte can
                    /// be read. Except for blocking, behavior is identical to `read`.
                    fn blocking_read(
                        &mut self,
                        self_: wasmtime::component::Resource<InputStream>,
                        len: u64,
                    ) -> wasmtime::Result<Result<Vec<u8>, StreamError>>;
                    /// Skip bytes from a stream. Returns number of bytes skipped.
                    ///
                    /// Behaves identical to `read`, except instead of returning a list
                    /// of bytes, returns the number of bytes consumed from the stream.
                    fn skip(
                        &mut self,
                        self_: wasmtime::component::Resource<InputStream>,
                        len: u64,
                    ) -> wasmtime::Result<Result<u64, StreamError>>;
                    /// Skip bytes from a stream, after blocking until at least one byte
                    /// can be skipped. Except for blocking behavior, identical to `skip`.
                    fn blocking_skip(
                        &mut self,
                        self_: wasmtime::component::Resource<InputStream>,
                        len: u64,
                    ) -> wasmtime::Result<Result<u64, StreamError>>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<InputStream>,
                    ) -> wasmtime::Result<()>;
                }
                /// An output bytestream.
                ///
                /// `output-stream`s are *non-blocking* to the extent practical on
                /// underlying platforms. Except where specified otherwise, I/O operations also
                /// always return promptly, after the number of bytes that can be written
                /// promptly, which could even be zero. To wait for the stream to be ready to
                /// accept data, the `subscribe` function to obtain a `pollable` which can be
                /// polled for using `wasi:io/poll`.
                pub enum OutputStream {}
                pub trait HostOutputStream {
                    /// Check readiness for writing. This function never blocks.
                    ///
                    /// Returns the number of bytes permitted for the next call to `write`,
                    /// or an error. Calling `write` with more bytes than this function has
                    /// permitted will trap.
                    ///
                    /// When this function returns 0 bytes, the `subscribe` pollable will
                    /// become ready when this function will report at least 1 byte, or an
                    /// error.
                    fn check_write(
                        &mut self,
                        self_: wasmtime::component::Resource<OutputStream>,
                    ) -> wasmtime::Result<Result<u64, StreamError>>;
                    /// Perform a write. This function never blocks.
                    ///
                    /// Precondition: check-write gave permit of Ok(n) and contents has a
                    /// length of less than or equal to n. Otherwise, this function will trap.
                    ///
                    /// returns Err(closed) without writing if the stream has closed since
                    /// the last call to check-write provided a permit.
                    fn write(
                        &mut self,
                        self_: wasmtime::component::Resource<OutputStream>,
                        contents: Vec<u8>,
                    ) -> wasmtime::Result<Result<(), StreamError>>;
                    /// Perform a write of up to 4096 bytes, and then flush the stream. Block
                    /// until all of these operations are complete, or an error occurs.
                    ///
                    /// This is a convenience wrapper around the use of `check-write`,
                    /// `subscribe`, `write`, and `flush`, and is implemented with the
                    /// following pseudo-code:
                    ///
                    /// ```text
                    /// let pollable = this.subscribe();
                    /// while !contents.is_empty() {
                    /// // Wait for the stream to become writable
                    /// poll-one(pollable);
                    /// let Ok(n) = this.check-write(); // eliding error handling
                    /// let len = min(n, contents.len());
                    /// let (chunk, rest) = contents.split_at(len);
                    /// this.write(chunk  );            // eliding error handling
                    /// contents = rest;
                    /// }
                    /// this.flush();
                    /// // Wait for completion of `flush`
                    /// poll-one(pollable);
                    /// // Check for any errors that arose during `flush`
                    /// let _ = this.check-write();         // eliding error handling
                    /// ```
                    fn blocking_write_and_flush(
                        &mut self,
                        self_: wasmtime::component::Resource<OutputStream>,
                        contents: Vec<u8>,
                    ) -> wasmtime::Result<Result<(), StreamError>>;
                    /// Request to flush buffered output. This function never blocks.
                    ///
                    /// This tells the output-stream that the caller intends any buffered
                    /// output to be flushed. the output which is expected to be flushed
                    /// is all that has been passed to `write` prior to this call.
                    ///
                    /// Upon calling this function, the `output-stream` will not accept any
                    /// writes (`check-write` will return `ok(0)`) until the flush has
                    /// completed. The `subscribe` pollable will become ready when the
                    /// flush has completed and the stream can accept more writes.
                    fn flush(
                        &mut self,
                        self_: wasmtime::component::Resource<OutputStream>,
                    ) -> wasmtime::Result<Result<(), StreamError>>;
                    /// Request to flush buffered output, and block until flush completes
                    /// and stream is ready for writing again.
                    fn blocking_flush(
                        &mut self,
                        self_: wasmtime::component::Resource<OutputStream>,
                    ) -> wasmtime::Result<Result<(), StreamError>>;
                    /// *
                    ///         /// Create a `pollable` which will resolve once the output-stream
                    ///         /// is ready for more writing, or an error has occured. When this
                    ///         /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
                    ///         /// error.
                    ///         ///
                    ///         /// If the stream is closed, this pollable is always ready immediately.
                    ///         ///
                    ///         /// The created `pollable` is a child resource of the `output-stream`.
                    ///         /// Implementations may trap if the `output-stream` is dropped before
                    ///         /// all derived `pollable`s created with this function are dropped.
                    ///         subscribe: func() -> pollable;
                    ///         */
                    /// Write zeroes to a stream.
                    ///
                    /// this should be used precisely like `write` with the exact same
                    /// preconditions (must use check-write first), but instead of
                    /// passing a list of bytes, you simply pass the number of zero-bytes
                    /// that should be written.
                    fn write_zeroes(
                        &mut self,
                        self_: wasmtime::component::Resource<OutputStream>,
                        len: u64,
                    ) -> wasmtime::Result<Result<(), StreamError>>;
                    /// Perform a write of up to 4096 zeroes, and then flush the stream.
                    /// Block until all of these operations are complete, or an error
                    /// occurs.
                    ///
                    /// This is a convenience wrapper around the use of `check-write`,
                    /// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
                    /// the following pseudo-code:
                    ///
                    /// ```text
                    /// let pollable = this.subscribe();
                    /// while num_zeroes != 0 {
                    /// // Wait for the stream to become writable
                    /// poll-one(pollable);
                    /// let Ok(n) = this.check-write(); // eliding error handling
                    /// let len = min(n, num_zeroes);
                    /// this.write-zeroes(len);         // eliding error handling
                    /// num_zeroes -= len;
                    /// }
                    /// this.flush();
                    /// // Wait for completion of `flush`
                    /// poll-one(pollable);
                    /// // Check for any errors that arose during `flush`
                    /// let _ = this.check-write();         // eliding error handling
                    /// ```
                    fn blocking_write_zeroes_and_flush(
                        &mut self,
                        self_: wasmtime::component::Resource<OutputStream>,
                        len: u64,
                    ) -> wasmtime::Result<Result<(), StreamError>>;
                    /// Read from one stream and write to another.
                    ///
                    /// The behavior of splice is equivelant to:
                    /// 1. calling `check-write` on the `output-stream`
                    /// 2. calling `read` on the `input-stream` with the smaller of the
                    /// `check-write` permitted length and the `len` provided to `splice`
                    /// 3. calling `write` on the `output-stream` with that read data.
                    ///
                    /// Any error reported by the call to `check-write`, `read`, or
                    /// `write` ends the splice and reports that error.
                    ///
                    /// This function returns the number of bytes transferred; it may be less
                    /// than `len`.
                    fn splice(
                        &mut self,
                        self_: wasmtime::component::Resource<OutputStream>,
                        src: wasmtime::component::Resource<InputStream>,
                        len: u64,
                    ) -> wasmtime::Result<Result<u64, StreamError>>;
                    /// Read from one stream and write to another, with blocking.
                    ///
                    /// This is similar to `splice`, except that it blocks until the
                    /// `output-stream` is ready for writing, and the `input-stream`
                    /// is ready for reading, before performing the `splice`.
                    fn blocking_splice(
                        &mut self,
                        self_: wasmtime::component::Resource<OutputStream>,
                        src: wasmtime::component::Resource<InputStream>,
                        len: u64,
                    ) -> wasmtime::Result<Result<u64, StreamError>>;
                    fn drop(
                        &mut self,
                        rep: wasmtime::component::Resource<OutputStream>,
                    ) -> wasmtime::Result<()>;
                }
                pub trait Host: HostInputStream + HostOutputStream {}
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:io/streams@0.2.0")?;
                    inst.resource(
                        "input-stream",
                        wasmtime::component::ResourceType::host::<InputStream>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostInputStream::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.resource(
                        "output-stream",
                        wasmtime::component::ResourceType::host::<OutputStream>(),
                        move |mut store, rep| -> wasmtime::Result<()> {
                            HostOutputStream::drop(
                                get(store.data_mut()),
                                wasmtime::component::Resource::new_own(rep),
                            )
                        },
                    )?;
                    inst.func_wrap(
                        "[method]input-stream.read",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<InputStream>, u64)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostInputStream::read(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]input-stream.blocking-read",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<InputStream>, u64)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostInputStream::blocking_read(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]input-stream.skip",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<InputStream>, u64)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostInputStream::skip(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]input-stream.blocking-skip",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<InputStream>, u64)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostInputStream::blocking_skip(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]output-stream.check-write",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutputStream>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutputStream::check_write(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]output-stream.write",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<OutputStream>, Vec<u8>)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutputStream::write(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]output-stream.blocking-write-and-flush",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<OutputStream>, Vec<u8>)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutputStream::blocking_write_and_flush(
                                host,
                                arg0,
                                arg1,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]output-stream.flush",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutputStream>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutputStream::flush(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]output-stream.blocking-flush",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (wasmtime::component::Resource<OutputStream>,)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutputStream::blocking_flush(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]output-stream.write-zeroes",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<OutputStream>, u64)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutputStream::write_zeroes(host, arg0, arg1);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]output-stream.blocking-write-zeroes-and-flush",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                            ): (wasmtime::component::Resource<OutputStream>, u64)|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutputStream::blocking_write_zeroes_and_flush(
                                host,
                                arg0,
                                arg1,
                            );
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]output-stream.splice",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (
                                wasmtime::component::Resource<OutputStream>,
                                wasmtime::component::Resource<InputStream>,
                                u64,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutputStream::splice(host, arg0, arg1, arg2);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "[method]output-stream.blocking-splice",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (
                                arg0,
                                arg1,
                                arg2,
                            ): (
                                wasmtime::component::Resource<OutputStream>,
                                wasmtime::component::Resource<InputStream>,
                                u64,
                            )|
                        {
                            let host = get(caller.data_mut());
                            let r = HostOutputStream::blocking_splice(
                                host,
                                arg0,
                                arg1,
                                arg2,
                            );
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
        pub mod random {
            #[allow(clippy::all)]
            pub mod random {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub trait Host {
                    /// Return `len` cryptographically-secure random or pseudo-random bytes.
                    ///
                    /// This function must produce data at least as cryptographically secure and
                    /// fast as an adequately seeded cryptographically-secure pseudo-random
                    /// number generator (CSPRNG). It must not block, from the perspective of
                    /// the calling program, under any circumstances, including on the first
                    /// request and on requests for numbers of bytes. The returned data must
                    /// always be unpredictable.
                    ///
                    /// This function must always return fresh data. Deterministic environments
                    /// must omit this function, rather than implementing it with deterministic
                    /// data.
                    fn get_random_bytes(
                        &mut self,
                        len: u64,
                    ) -> wasmtime::Result<Vec<u8>>;
                    /// Return a cryptographically-secure random or pseudo-random `u64` value.
                    ///
                    /// This function returns the same type of data as `get-random-bytes`,
                    /// represented as a `u64`.
                    fn get_random_u64(&mut self) -> wasmtime::Result<u64>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:random/random@0.2.0")?;
                    inst.func_wrap(
                        "get-random-bytes",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (u64,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::get_random_bytes(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "get-random-u64",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::get_random_u64(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
            #[allow(clippy::all)]
            pub mod insecure {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub trait Host {
                    /// Return `len` insecure pseudo-random bytes.
                    ///
                    /// This function is not cryptographically secure. Do not use it for
                    /// anything related to security.
                    ///
                    /// There are no requirements on the values of the returned bytes, however
                    /// implementations are encouraged to return evenly distributed values with
                    /// a long period.
                    fn get_insecure_random_bytes(
                        &mut self,
                        len: u64,
                    ) -> wasmtime::Result<Vec<u8>>;
                    /// Return an insecure pseudo-random `u64` value.
                    ///
                    /// This function returns the same type of pseudo-random data as
                    /// `get-insecure-random-bytes`, represented as a `u64`.
                    fn get_insecure_random_u64(&mut self) -> wasmtime::Result<u64>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:random/insecure@0.2.0")?;
                    inst.func_wrap(
                        "get-insecure-random-bytes",
                        move |
                            mut caller: wasmtime::StoreContextMut<'_, T>,
                            (arg0,): (u64,)|
                        {
                            let host = get(caller.data_mut());
                            let r = Host::get_insecure_random_bytes(host, arg0);
                            Ok((r?,))
                        },
                    )?;
                    inst.func_wrap(
                        "get-insecure-random-u64",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::get_insecure_random_u64(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
            #[allow(clippy::all)]
            pub mod insecure_seed {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub trait Host {
                    /// Return a 128-bit value that may contain a pseudo-random value.
                    ///
                    /// The returned value is not required to be computed from a CSPRNG, and may
                    /// even be entirely deterministic. Host implementations are encouraged to
                    /// provide pseudo-random values to any program exposed to
                    /// attacker-controlled content, to enable DoS protection built into many
                    /// languages' hash-map implementations.
                    ///
                    /// This function is intended to only be called once, by a source language
                    /// to initialize Denial Of Service (DoS) protection in its hash-map
                    /// implementation.
                    ///
                    /// # Expected future evolution
                    ///
                    /// This will likely be changed to a value import, to prevent it from being
                    /// called multiple times and potentially used for purposes other than DoS
                    /// protection.
                    fn insecure_seed(&mut self) -> wasmtime::Result<(u64, u64)>;
                }
                pub fn add_to_linker<T, U>(
                    linker: &mut wasmtime::component::Linker<T>,
                    get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
                ) -> wasmtime::Result<()>
                where
                    U: Host,
                {
                    let mut inst = linker.instance("wasi:random/insecure-seed@0.2.0")?;
                    inst.func_wrap(
                        "insecure-seed",
                        move |mut caller: wasmtime::StoreContextMut<'_, T>, (): ()| {
                            let host = get(caller.data_mut());
                            let r = Host::insecure_seed(host);
                            Ok((r?,))
                        },
                    )?;
                    Ok(())
                }
            }
        }
    }
    pub mod exports {
        pub mod hermes {
            pub mod cardano {
                #[allow(clippy::all)]
                pub mod event_on_block {
                    #[allow(unused_imports)]
                    use wasmtime::component::__internal::anyhow;
                    pub type CardanoBlockchainId = super::super::super::super::hermes::cardano::api::CardanoBlockchainId;
                    const _: () = {
                        if !(1
                            == <CardanoBlockchainId as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 1 == <CardanoBlockchainId as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(1
                            == <CardanoBlockchainId as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 1 == <CardanoBlockchainId as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    pub type CardanoBlock = super::super::super::super::hermes::cardano::api::CardanoBlock;
                    const _: () = {
                        if !(8
                            == <CardanoBlock as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 8 == <CardanoBlock as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(4
                            == <CardanoBlock as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 4 == <CardanoBlock as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    pub struct BlockSrc {
                        #[doc(hidden)]
                        __inner0: u8,
                    }
                    #[automatically_derived]
                    impl ::core::marker::Copy for BlockSrc {}
                    #[automatically_derived]
                    impl ::core::clone::Clone for BlockSrc {
                        #[inline]
                        fn clone(&self) -> BlockSrc {
                            let _: ::core::clone::AssertParamIsClone<u8>;
                            *self
                        }
                    }
                    #[automatically_derived]
                    impl ::core::default::Default for BlockSrc {
                        #[inline]
                        fn default() -> BlockSrc {
                            BlockSrc {
                                __inner0: ::core::default::Default::default(),
                            }
                        }
                    }
                    impl BlockSrc {
                        pub const TIP: Self = Self { __inner0: 1u8 };
                        pub const NODE: Self = Self { __inner0: 2u8 };
                        pub const MITHRIL: Self = Self { __inner0: 4u8 };
                        pub fn as_array(&self) -> [u32; 1usize] {
                            [self.__inner0 as u32]
                        }
                        pub fn empty() -> Self {
                            Self::default()
                        }
                        pub fn all() -> Self {
                            use std::ops::Not;
                            Self::default().not()
                        }
                        pub fn contains(&self, other: Self) -> bool {
                            *self & other == other
                        }
                        pub fn intersects(&self, other: Self) -> bool {
                            *self & other != Self::empty()
                        }
                    }
                    impl std::cmp::PartialEq for BlockSrc {
                        fn eq(&self, rhs: &BlockSrc) -> bool {
                            (self.__inner0 & 7u8).eq(&(rhs.__inner0 & 7u8))
                        }
                    }
                    impl std::cmp::Eq for BlockSrc {}
                    impl std::fmt::Debug for BlockSrc {
                        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                            wasmtime::component::__internal::format_flags(
                                &self.as_array(),
                                &["TIP", "NODE", "MITHRIL"],
                                f,
                            )
                        }
                    }
                    impl std::ops::BitOr for BlockSrc {
                        type Output = BlockSrc;
                        fn bitor(self, rhs: BlockSrc) -> BlockSrc {
                            Self {
                                __inner0: self.__inner0.bitor(rhs.__inner0),
                            }
                        }
                    }
                    impl std::ops::BitOrAssign for BlockSrc {
                        fn bitor_assign(&mut self, rhs: BlockSrc) {
                            self.__inner0.bitor_assign(rhs.__inner0)
                        }
                    }
                    impl std::ops::BitAnd for BlockSrc {
                        type Output = BlockSrc;
                        fn bitand(self, rhs: BlockSrc) -> BlockSrc {
                            Self {
                                __inner0: self.__inner0.bitand(rhs.__inner0),
                            }
                        }
                    }
                    impl std::ops::BitAndAssign for BlockSrc {
                        fn bitand_assign(&mut self, rhs: BlockSrc) {
                            self.__inner0.bitand_assign(rhs.__inner0)
                        }
                    }
                    impl std::ops::BitXor for BlockSrc {
                        type Output = BlockSrc;
                        fn bitxor(self, rhs: BlockSrc) -> BlockSrc {
                            Self {
                                __inner0: self.__inner0.bitxor(rhs.__inner0),
                            }
                        }
                    }
                    impl std::ops::BitXorAssign for BlockSrc {
                        fn bitxor_assign(&mut self, rhs: BlockSrc) {
                            self.__inner0.bitxor_assign(rhs.__inner0)
                        }
                    }
                    impl std::ops::Not for BlockSrc {
                        type Output = BlockSrc;
                        fn not(self) -> BlockSrc {
                            Self {
                                __inner0: self.__inner0.not(),
                            }
                        }
                    }
                    const _: () = {
                        #[doc(hidden)]
                        #[repr(C)]
                        pub struct LowerBlockSrc<T0: Copy> {
                            __inner0: T0,
                            _align: [wasmtime::ValRaw; 0],
                        }
                        #[automatically_derived]
                        impl<T0: ::core::clone::Clone + Copy> ::core::clone::Clone
                        for LowerBlockSrc<T0> {
                            #[inline]
                            fn clone(&self) -> LowerBlockSrc<T0> {
                                LowerBlockSrc {
                                    __inner0: ::core::clone::Clone::clone(&self.__inner0),
                                    _align: ::core::clone::Clone::clone(&self._align),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<T0: ::core::marker::Copy + Copy> ::core::marker::Copy
                        for LowerBlockSrc<T0> {}
                        unsafe impl wasmtime::component::ComponentType for BlockSrc {
                            type Lower = LowerBlockSrc<
                                <u8 as wasmtime::component::ComponentType>::Lower,
                            >;
                            const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                                &[<u8 as wasmtime::component::ComponentType>::ABI],
                            );
                            #[inline]
                            fn typecheck(
                                ty: &wasmtime::component::__internal::InterfaceType,
                                types: &wasmtime::component::__internal::InstanceType<'_>,
                            ) -> wasmtime::component::__internal::anyhow::Result<()> {
                                wasmtime::component::__internal::typecheck_flags(
                                    ty,
                                    types,
                                    &["tip", "node", "mithril"],
                                )
                            }
                        }
                    };
                    unsafe impl wasmtime::component::Lower for BlockSrc {
                        fn lower<T>(
                            &self,
                            cx: &mut wasmtime::component::__internal::LowerContext<
                                '_,
                                T,
                            >,
                            _ty: wasmtime::component::__internal::InterfaceType,
                            dst: &mut std::mem::MaybeUninit<Self::Lower>,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            self.__inner0
                                .lower(
                                    cx,
                                    wasmtime::component::__internal::InterfaceType::U8,
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).__inner0)
                                            }
                                        }
                                    },
                                )?;
                            Ok(())
                        }
                        fn store<T>(
                            &self,
                            cx: &mut wasmtime::component::__internal::LowerContext<
                                '_,
                                T,
                            >,
                            _ty: wasmtime::component::__internal::InterfaceType,
                            mut offset: usize,
                        ) -> wasmtime::component::__internal::anyhow::Result<()> {
                            if true {
                                if !(offset
                                    % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                        as usize) == 0)
                                {
                                    ::core::panicking::panic(
                                        "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                    )
                                }
                            }
                            self.__inner0
                                .store(
                                    cx,
                                    wasmtime::component::__internal::InterfaceType::U8,
                                    offset,
                                )?;
                            offset += std::mem::size_of_val(&self.__inner0);
                            Ok(())
                        }
                    }
                    unsafe impl wasmtime::component::Lift for BlockSrc {
                        fn lift(
                            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                            _ty: wasmtime::component::__internal::InterfaceType,
                            src: &Self::Lower,
                        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                            Ok(Self {
                                __inner0: wasmtime::component::Lift::lift(
                                    cx,
                                    wasmtime::component::__internal::InterfaceType::U8,
                                    &src.__inner0,
                                )?,
                            })
                        }
                        fn load(
                            cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                            _ty: wasmtime::component::__internal::InterfaceType,
                            bytes: &[u8],
                        ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                            if true {
                                if !((bytes.as_ptr() as usize)
                                    % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                        as usize) == 0)
                                {
                                    ::core::panicking::panic(
                                        "assertion failed: (bytes.as_ptr() as usize) %\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                                    )
                                }
                            }
                            let (field, bytes) = bytes.split_at(1usize);
                            let __inner0 = wasmtime::component::Lift::load(
                                cx,
                                wasmtime::component::__internal::InterfaceType::U8,
                                field,
                            )?;
                            Ok(Self { __inner0 })
                        }
                    }
                    const _: () = {
                        if !(1
                            == <BlockSrc as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 1 == <BlockSrc as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(1
                            == <BlockSrc as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 1 == <BlockSrc as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    pub struct EventOnBlock {
                        on_cardano_block: wasmtime::component::Func,
                    }
                    impl EventOnBlock {
                        pub fn new(
                            __exports: &mut wasmtime::component::ExportInstance<'_, '_>,
                        ) -> wasmtime::Result<EventOnBlock> {
                            let on_cardano_block = *__exports
                                .typed_func::<
                                    (CardanoBlockchainId, &CardanoBlock, BlockSrc),
                                    (),
                                >("on-cardano-block")?
                                .func();
                            Ok(EventOnBlock { on_cardano_block })
                        }
                        /// Triggered when a cardano block event fires.
                        ///
                        /// The module must export this interface to use it.
                        ///
                        /// ## Parameters
                        ///
                        /// - `blockchain` : The blockchain id the block originated from.
                        /// - `block` : This raw CBOR block data.
                        /// - `source` : Source information about where the block came from, and if we are at tip or not.
                        ///
                        /// Returns:
                        /// Nothing.
                        pub fn call_on_cardano_block<S: wasmtime::AsContextMut>(
                            &self,
                            mut store: S,
                            arg0: CardanoBlockchainId,
                            arg1: &CardanoBlock,
                            arg2: BlockSrc,
                        ) -> wasmtime::Result<()> {
                            let callee = unsafe {
                                wasmtime::component::TypedFunc::<
                                    (CardanoBlockchainId, &CardanoBlock, BlockSrc),
                                    (),
                                >::new_unchecked(self.on_cardano_block)
                            };
                            let () = callee
                                .call(store.as_context_mut(), (arg0, arg1, arg2))?;
                            callee.post_return(store.as_context_mut())?;
                            Ok(())
                        }
                    }
                }
                #[allow(clippy::all)]
                pub mod event_on_txn {
                    #[allow(unused_imports)]
                    use wasmtime::component::__internal::anyhow;
                    pub type CardanoBlockchainId = super::super::super::super::hermes::cardano::api::CardanoBlockchainId;
                    const _: () = {
                        if !(1
                            == <CardanoBlockchainId as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 1 == <CardanoBlockchainId as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(1
                            == <CardanoBlockchainId as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 1 == <CardanoBlockchainId as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    pub type CardanoTxn = super::super::super::super::hermes::cardano::api::CardanoTxn;
                    const _: () = {
                        if !(8
                            == <CardanoTxn as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 8 == <CardanoTxn as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(4
                            == <CardanoTxn as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 4 == <CardanoTxn as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    pub struct EventOnTxn {
                        on_cardano_txn: wasmtime::component::Func,
                    }
                    impl EventOnTxn {
                        pub fn new(
                            __exports: &mut wasmtime::component::ExportInstance<'_, '_>,
                        ) -> wasmtime::Result<EventOnTxn> {
                            let on_cardano_txn = *__exports
                                .typed_func::<
                                    (CardanoBlockchainId, u64, u32, &CardanoTxn),
                                    (),
                                >("on-cardano-txn")?
                                .func();
                            Ok(EventOnTxn { on_cardano_txn })
                        }
                        /// Triggered when a cardano transaction event fires.
                        ///
                        /// The module must export this interface to use it.
                        ///
                        /// ## Parameters
                        ///
                        /// - `blockchain` : The blockchain id the block originated from.
                        /// - `slot`       : The slot the transaction is in.
                        /// - `txn-index`  : The offset in the block this transaction is at.
                        /// - `txn`        : The raw transaction data itself.
                        ///
                        /// Returns:
                        /// Nothing.
                        pub fn call_on_cardano_txn<S: wasmtime::AsContextMut>(
                            &self,
                            mut store: S,
                            arg0: CardanoBlockchainId,
                            arg1: u64,
                            arg2: u32,
                            arg3: &CardanoTxn,
                        ) -> wasmtime::Result<()> {
                            let callee = unsafe {
                                wasmtime::component::TypedFunc::<
                                    (CardanoBlockchainId, u64, u32, &CardanoTxn),
                                    (),
                                >::new_unchecked(self.on_cardano_txn)
                            };
                            let () = callee
                                .call(store.as_context_mut(), (arg0, arg1, arg2, arg3))?;
                            callee.post_return(store.as_context_mut())?;
                            Ok(())
                        }
                    }
                }
                #[allow(clippy::all)]
                pub mod event_on_rollback {
                    #[allow(unused_imports)]
                    use wasmtime::component::__internal::anyhow;
                    pub type CardanoBlockchainId = super::super::super::super::hermes::cardano::api::CardanoBlockchainId;
                    const _: () = {
                        if !(1
                            == <CardanoBlockchainId as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 1 == <CardanoBlockchainId as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(1
                            == <CardanoBlockchainId as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 1 == <CardanoBlockchainId as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    pub struct EventOnRollback {
                        on_cardano_rollback: wasmtime::component::Func,
                    }
                    impl EventOnRollback {
                        pub fn new(
                            __exports: &mut wasmtime::component::ExportInstance<'_, '_>,
                        ) -> wasmtime::Result<EventOnRollback> {
                            let on_cardano_rollback = *__exports
                                .typed_func::<
                                    (CardanoBlockchainId, u64),
                                    (),
                                >("on-cardano-rollback")?
                                .func();
                            Ok(EventOnRollback {
                                on_cardano_rollback,
                            })
                        }
                        /// Triggered when a cardano rollback event fires.
                        ///
                        /// The module must export this interface to use it.
                        ///
                        /// ## Parameters
                        ///
                        /// - `blockchain` : The blockchain id the rollback originated from.
                        /// - `slot`       : The slot the rollback is targeting. (The next block event will be from this slot.)
                        ///
                        /// Returns:
                        /// Nothing.
                        pub fn call_on_cardano_rollback<S: wasmtime::AsContextMut>(
                            &self,
                            mut store: S,
                            arg0: CardanoBlockchainId,
                            arg1: u64,
                        ) -> wasmtime::Result<()> {
                            let callee = unsafe {
                                wasmtime::component::TypedFunc::<
                                    (CardanoBlockchainId, u64),
                                    (),
                                >::new_unchecked(self.on_cardano_rollback)
                            };
                            let () = callee.call(store.as_context_mut(), (arg0, arg1))?;
                            callee.post_return(store.as_context_mut())?;
                            Ok(())
                        }
                    }
                }
            }
            pub mod cron {
                #[allow(clippy::all)]
                pub mod event {
                    #[allow(unused_imports)]
                    use wasmtime::component::__internal::anyhow;
                    pub type CronEventTag = super::super::super::super::hermes::cron::api::CronEventTag;
                    const _: () = {
                        if !(8
                            == <CronEventTag as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 8 == <CronEventTag as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(4
                            == <CronEventTag as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 4 == <CronEventTag as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    pub type CronTagged = super::super::super::super::hermes::cron::api::CronTagged;
                    const _: () = {
                        if !(16
                            == <CronTagged as wasmtime::component::ComponentType>::SIZE32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 16 == <CronTagged as wasmtime::component::ComponentType>::SIZE32",
                            )
                        }
                        if !(4
                            == <CronTagged as wasmtime::component::ComponentType>::ALIGN32)
                        {
                            ::core::panicking::panic(
                                "assertion failed: 4 == <CronTagged as wasmtime::component::ComponentType>::ALIGN32",
                            )
                        }
                    };
                    pub struct Event {
                        on_cron: wasmtime::component::Func,
                    }
                    impl Event {
                        pub fn new(
                            __exports: &mut wasmtime::component::ExportInstance<'_, '_>,
                        ) -> wasmtime::Result<Event> {
                            let on_cron = *__exports
                                .typed_func::<(&CronTagged, bool), (bool,)>("on-cron")?
                                .func();
                            Ok(Event { on_cron })
                        }
                        /// Triggered when a cron event fires.
                        ///
                        /// This event is only ever generated for the application that added
                        /// the cron job.
                        ///
                        /// The module must export this interface to use it.
                        ///
                        /// ## Parameters
                        ///
                        /// - `event` : The tagged cron event that was triggered.
                        /// - `last` : This cron event will not retrigger.
                        ///
                        /// Returns:
                        /// - `true`  - retrigger. (Ignored if the cron event is `final`).
                        /// - `false` - stop the cron.
                        pub fn call_on_cron<S: wasmtime::AsContextMut>(
                            &self,
                            mut store: S,
                            arg0: &CronTagged,
                            arg1: bool,
                        ) -> wasmtime::Result<bool> {
                            let callee = unsafe {
                                wasmtime::component::TypedFunc::<
                                    (&CronTagged, bool),
                                    (bool,),
                                >::new_unchecked(self.on_cron)
                            };
                            let (ret0,) = callee
                                .call(store.as_context_mut(), (arg0, arg1))?;
                            callee.post_return(store.as_context_mut())?;
                            Ok(ret0)
                        }
                    }
                }
            }
        }
        pub mod wasi {
            pub mod http {
                #[allow(clippy::all)]
                pub mod incoming_handler {
                    #[allow(unused_imports)]
                    use wasmtime::component::__internal::anyhow;
                    pub type IncomingRequest = super::super::super::super::wasi::http::types::IncomingRequest;
                    pub type ResponseOutparam = super::super::super::super::wasi::http::types::ResponseOutparam;
                    pub struct IncomingHandler {
                        handle: wasmtime::component::Func,
                    }
                    impl IncomingHandler {
                        pub fn new(
                            __exports: &mut wasmtime::component::ExportInstance<'_, '_>,
                        ) -> wasmtime::Result<IncomingHandler> {
                            let handle = *__exports
                                .typed_func::<
                                    (
                                        wasmtime::component::Resource<IncomingRequest>,
                                        wasmtime::component::Resource<ResponseOutparam>,
                                    ),
                                    (),
                                >("handle")?
                                .func();
                            Ok(IncomingHandler { handle })
                        }
                        /// This function is invoked with an incoming HTTP Request, and a resource
                        /// `response-outparam` which provides the capability to reply with an HTTP
                        /// Response. The response is sent by calling the `response-outparam.set`
                        /// method, which allows execution to continue after the response has been
                        /// sent. This enables both streaming to the response body, and performing other
                        /// work.
                        ///
                        /// The implementor of this function must write a response to the
                        /// `response-outparam` before returning, or else the caller will respond
                        /// with an error on its behalf.
                        pub fn call_handle<S: wasmtime::AsContextMut>(
                            &self,
                            mut store: S,
                            arg0: wasmtime::component::Resource<IncomingRequest>,
                            arg1: wasmtime::component::Resource<ResponseOutparam>,
                        ) -> wasmtime::Result<()> {
                            let callee = unsafe {
                                wasmtime::component::TypedFunc::<
                                    (
                                        wasmtime::component::Resource<IncomingRequest>,
                                        wasmtime::component::Resource<ResponseOutparam>,
                                    ),
                                    (),
                                >::new_unchecked(self.handle)
                            };
                            let () = callee.call(store.as_context_mut(), (arg0, arg1))?;
                            callee.post_return(store.as_context_mut())?;
                            Ok(())
                        }
                    }
                }
            }
        }
    }
    const _: &str = "package hermes:binary;\n\nworld all {\n    import api;\n}\n";
    const _: &str = "/// # Binary Data API\n///\n/// Binary Data types and functions.\n///\n/// ## Permissions\n///\n/// This API is permissionless.\n\n// cspell: words\n\n/// Binary API Interface - Imports ONLY\ninterface api {\n    // Binary String (bstr) is a list of bytes.\n    //    This type is used to indicate the data is an arbitrary array of bytes.\n    type bstr = list<u8>;\n\n    // 128 bit value\n    type b128 = tuple<u64, u64>;\n\n    // 256 bit value\n    type b256 = tuple<u64, u64, u64, u64>;\n\n    // 512 bit value\n    type b512 = tuple<u64, u64, u64, u64, u64, u64, u64, u64>;\n\n}\n\n\n/// World just for the Hermes \'cron\' API and Event.\nworld binary-api {\n    import api;\n}\n  ";
    const _: &str = "package hermes:cbor;\n\nworld all {\n    import api;\n}\n";
    const _: &str = "/// # CBOR API\n///\n/// CBOR Data types and functions.\n///\n/// ## Permissions\n///\n/// This API is permissionless.\n\n// cspell: words\n\n/// CBOR API Interface - Imports ONLY\ninterface api {\n    /// Get the `bstr` type from the `hermes:binary` module.\n    use hermes:binary/api.{bstr};\n\n    /// CBOR is a binary cbor data type.\n    ///    This type is used to indicate the binary array MUST be CBOR data.\n    type cbor = bstr;\n}\n\n\n/// World just for the Hermes \'cron\' API and Event.\nworld cbor-api {\n    import api;\n}\n  ";
    const _: &str = "/// # Cardano API\n///\n/// Events triggered by subscribing to blockchain updates.\n///\n/// ## Event Scheduling\n///\n/// **Guarantee**: Block events will occur and be fully processed, \n/// before any transaction events from that block are sent.\n///\n/// **Guarantee**: Transaction events will be sent and could arrive in any order,\n/// BUT only after all event processing of the block they come from is complete.\n/// Further block or rollback events will not occur until all transaction events\n/// from a block are fully processed.\n/// \n/// **Guarantee**: Rollback events will be fully processed before the next block \n/// event will be sent.  The block event sent immediately after a rollback event \n/// will be the target of the rollback.  This means that rollback processing does \n/// not need to reset or re-subscribe the blockchain follower.\n///\n/// **Warning**: Events from different blockchains are not synchronized between \n/// each other.\n\n/// Cardano API Interface - Export ONLY\ninterface event-on-block {\n    use api.{cardano-blockchain-id, cardano-block};\n\n    flags block-src {\n        tip,\n        node,\n        mithril\n    }\n\n    /// Triggered when a cardano block event fires.\n    ///\n    /// The module must export this interface to use it.\n    ///\n    /// ## Parameters\n    ///\n    /// - `blockchain` : The blockchain id the block originated from.\n    /// - `block` : This raw CBOR block data.\n    /// - `source` : Source information about where the block came from, and if we are at tip or not.\n    ///\n    /// Returns:\n    ///     Nothing.\n    /// \n    on-cardano-block: func(blockchain: cardano-blockchain-id, block: cardano-block, source:block-src);\n}\n\n/// Cardano API Interface - Export ONLY\ninterface event-on-txn {\n    use api.{cardano-blockchain-id, cardano-txn};\n\n    /// Triggered when a cardano transaction event fires.\n    ///\n    /// The module must export this interface to use it.\n    ///\n    /// ## Parameters\n    ///\n    /// - `blockchain` : The blockchain id the block originated from.\n    /// - `slot`       : The slot the transaction is in.\n    /// - `txn-index`  : The offset in the block this transaction is at.\n    /// - `txn`        : The raw transaction data itself.\n    ///\n    /// Returns:\n    ///     Nothing.\n    /// \n    on-cardano-txn: func(blockchain: cardano-blockchain-id, slot:u64, txn-index: u32, txn: cardano-txn);\n}\n\n/// Cardano API Interface - Export ONLY\ninterface event-on-rollback {\n    use api.{cardano-blockchain-id};\n\n    /// Triggered when a cardano rollback event fires.\n    ///\n    /// The module must export this interface to use it.\n    ///\n    /// ## Parameters\n    ///\n    /// - `blockchain` : The blockchain id the rollback originated from.\n    /// - `slot`       : The slot the rollback is targeting. (The next block event will be from this slot.)\n    ///\n    /// Returns:\n    ///     Nothing.\n    /// \n    on-cardano-rollback: func(blockchain: cardano-blockchain-id, slot:u64);\n}\n\n\nworld cardano-events {\n    export event-on-block;\n    export event-on-txn;\n    export event-on-rollback;\n}";
    const _: &str = "package hermes:cardano;\n\n\nworld all {\n    import api;\n\n    export event-on-block;\n    export event-on-txn;\n    export event-on-rollback;\n}\n";
    const _: &str = "/// # Cardano Blockchain API\n///\n/// Cardano Blockchain API functionality exposed to the Hermes WASM Modules.\n///\n/// ## Permissions\n///\n/// This API is ALWAYS available.\n\n/// Cardano API Interface\ninterface api {\n    use hermes:cbor/api.{cbor};\n\n    /// Cardano Blocks are CBOR Data\n    type cardano-block = cbor;\n\n    /// Cardano Transactions are CBOR Data\n    type cardano-txn = cbor;\n\n    /// The ID of the blockchain to interact with.\n    enum cardano-blockchain-id {\n        mainnet, // Cardano Mainnet\n        preprod, // Cardano Preprod Network\n        preview, // Cardano Preview Network\n        local-test-blockchain // A local isolated test blockchain.\n    }\n\n    /// The Slot number to interact with\n    variant slot {\n        genesis,      // The very start of the blockchain.\n        slot-no(u64), // A particular slot number.\n        tip,          // The TIP of the blockchain.\n        continue,     // From wherever its currently pointing.\n    }\n\n    /// Errors that can happen fetching/subscribing to blocks\n    enum fetch-error {\n        blockchain-not-available, // The blockchain requested is not available.\n        invalid-slot,   // The slot requested is not a valid slot for the blockchain.\n    }\n\n    /// Errors that can occur when posting transactions.\n    enum txn-error {\n        blockchain-not-available, // The blockchain requested is not available.\n        malformed-transaction, // The transaction is not well formed, and can not be posted.\n        post-txn-not-allowed // Posting transactions is not allowed, nothing sent to blockchain.\n    }\n\n    /// Options used to unsubscribe from the blockchain data flow.\n    flags unsubscribe-options {\n        block,  // Stop receiving block data\n        transaction, // Stop receiving txn data\n        rollback, // Stop receiving rollback data\n        stop // stop the blockchain fetching process altogether.\n    }\n\n\n    /// Subscribe to the Blockchain block data.\n    /// \n    /// **Parameters**\n    ///\n    /// - `net` : The blockchain network to fetch block from, and subscribe to.\n    /// - `whence`: Where to start fetching blocks from.\n    /// \n    /// **Returns**\n    /// \n    /// - `ok(u64)` : The slot we are synching from now.\n    /// - `error(fetch-error)` : If an error occured.\n    /// \n    /// **Notes**\n    /// \n    /// If the blockchain is not yet syncing, it will start, from the requested slot.\n    /// If the blockchain is not yet syncing, and `whence` == `continue` then the blockchain will\n    /// not be synced from, the calling module will only be subscribed for block events.\n    /// \n    /// If the blockchain is already syncing, the sync will stop and restart, unless `whence` == `continue`.\n    /// When `whence` == `continue` the blockchain will keep syncing from where it is at, and this module\n    /// will be subscribed to block updates.\n    /// \n    /// `whence` == `stop` will prevent the blockchain syncing, and the caller will be unsubscribed.\n    /// \n    /// \n    subscribe-blocks: func (net: cardano-blockchain-id, whence: slot ) -> result<u64, fetch-error>;\n\n    /// Unsubscribe from the blockchain events listed.\n    /// \n    /// **Parameters**\n    ///\n    /// - `events` : The events to unsubscribe from (and optionally stop the blockchain follower).\n    /// \n    /// **Notes**\n    /// \n    /// This only unsubscribes from the events.\n    /// The option `stop` MUST be set to actually stop fetching data from the blockchain once started.\n    /// \n    /// `stop` can be set without unsubscribing, and this will interrupt the flow of blockchain data.\n    /// After `stop`,  `subscribe-blocks(?, continue)` would cause blockchain sync to continue from \n    /// the last block received.  This would result in the last block being sent as an event twice,\n    /// once before the `stop` and once after the `continue`.\n    unsubscribe: func(events: unsubscribe-options);\n\n    /// Subscribe to transaction data events, does not alter the blockchain sync in anyway.\n    /// \n    /// **Parameters**\n    ///\n    /// - `net` : The blockchain network to subscribe to txn events from.\n    /// \n    subscribe-txn: func (net: cardano-blockchain-id);\n\n    /// Subscribe to blockchain rollback events, does not alter the blockchain sync in anyway.\n    /// \n    /// **Parameters**\n    ///\n    /// - `net` : The blockchain network to subscribe to txn events from.\n    /// \n    /// **Notes**\n    /// \n    /// After a rollback event, the blockchain sync will AUTOMATICALLY start sending block\n    /// data from the rollback point.  No action is required to actually follow the rollback, unless the\n    /// default behavior is not desired.\n    subscribe-rollback: func (net: cardano-blockchain-id);\n\n    /// Fetch a block from the requested blockchain at the requested slot.\n    /// \n    /// **Parameters**\n    ///\n    /// - `net`    : The blockchain network to get a block from.\n    /// - `whence` : Which block to get.\n    /// \n    /// **Returns**\n    /// \n    /// - `cardano-block` : The block requested.\n    /// - `fetch-error` : An error if the block can not be fetched.\n    /// \n    /// **Notes**\n    /// \n    /// Fetching a block does not require the blockchain to be subscribed, or for blocks to be\n    /// being followed and generating events.\n    /// It also will not alter the automatic fetching of blocks in any way, and happens in parallel\n    /// to automated block fetch.\n    /// \n    fetch-block: func (net: cardano-blockchain-id, whence: slot) -> result<cardano-block, fetch-error>;\n\n    /// Get transactions from a block.\n    /// \n    /// This can be used to easily extract all transactions from a complete block.\n    /// \n    /// **Parameters**\n    ///\n    /// - `block` : The blockchain data to extract transactions from.\n    /// \n    /// **Returns**\n    /// \n    /// - a list of all transactions in the block, in the order they appear in the block.\n    /// \n    /// **Notes**\n    /// \n    /// This function exists to support `fetch-block`.\n    /// Transactions from subscribed block events, should be processed as transaction events.\n    /// \n    get-txns: func (block: cardano-block) -> list<cardano-txn>;\n\n    /// Post a transactions to the blockchain.\n    /// \n    /// This can be used to post a pre-formed transaction to the required blockchain.\n    /// \n    /// **Parameters**\n    ///\n    /// - `net` : The blockchain to post the transaction to.\n    /// - `txn` : The transaction data, ready to submit.\n    /// \n    /// **Returns**\n    /// \n    /// - An error if the transaction can not be posted.\n    /// \n    /// **Notes**\n    /// \n    /// This is proposed functionality, and is not yet active.\n    /// All calls to this function will return `post-txn-not-allowed` error.\n    /// \n    post-txn: func (net: cardano-blockchain-id, txn: cardano-txn) -> result<_, txn-error>;\n}\n\n/// World just for the Hermes \'json\' API.\nworld cardano-api {\n    import api;\n}\n";
    const _: &str = "package wasi:clocks@0.2.0;\n\nworld imports {\n    import monotonic-clock;\n    import wall-clock;\n}\n";
    const _: &str = "package wasi:clocks@0.2.0;\n/// WASI Wall Clock is a clock API intended to let users query the current\n/// time. The name \"wall\" makes an analogy to a \"clock on the wall\", which\n/// is not necessarily monotonic as it may be reset.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A wall clock is a clock which measures the date and time according to\n/// some external reference.\n///\n/// External references may be reset, so this clock is not necessarily\n/// monotonic, making it unsuitable for measuring elapsed time.\n///\n/// It is intended for reporting the current date and time for humans.\ninterface wall-clock {\n    /// A time and date in seconds plus nanoseconds.\n    record datetime {\n        seconds: u64,\n        nanoseconds: u32,\n    }\n\n    /// Read the current value of the clock.\n    ///\n    /// This clock is not monotonic, therefore calling this function repeatedly\n    /// will not necessarily produce a sequence of non-decreasing values.\n    ///\n    /// The returned timestamps represent the number of seconds since\n    /// 1970-01-01T00:00:00Z, also known as [POSIX\'s Seconds Since the Epoch],\n    /// also known as [Unix Time].\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    ///\n    /// [POSIX\'s Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16\n    /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time\n    now: func() -> datetime;\n\n    /// Query the resolution of the clock.\n    ///\n    /// The nanoseconds field of the output is always less than 1000000000.\n    resolution: func() -> datetime;\n}\n";
    const _: &str = "package wasi:clocks@0.2.0;\n/// WASI Monotonic Clock is a clock API intended to let users measure elapsed\n/// time.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\n///\n/// A monotonic clock is a clock which has an unspecified initial value, and\n/// successive reads of the clock will produce non-decreasing values.\n///\n/// It is intended for measuring elapsed time.\ninterface monotonic-clock {\n    // Hermes does not support `poll`\n    //use wasi:io/poll@0.2.0.{pollable};\n\n    /// An instant in time, in nanoseconds. An instant is relative to an\n    /// unspecified initial value, and can only be compared to instances from\n    /// the same monotonic-clock.\n    type instant = u64;\n\n    /// A duration of time, in nanoseconds.\n    type duration = u64;\n\n    /// Read the current value of the clock.\n    ///\n    /// The clock is monotonic, therefore calling this function repeatedly will\n    /// produce a sequence of non-decreasing values.\n    now: func() -> instant;\n\n    /// Query the resolution of the clock. Returns the duration of time\n    /// corresponding to a clock tick.\n    resolution: func() -> duration;\n\n    /*\n    /// Create a `pollable` which will resolve once the specified instant\n    /// occured.\n    subscribe-instant: func(\n        when: instant,\n    ) -> pollable;\n    \n    /// Create a `pollable` which will resolve once the given duration has\n    /// elapsed, starting at the time at which this function was called.\n    /// occured.\n    subscribe-duration: func(\n        when: duration,\n    ) -> pollable;\n    */\n}\n";
    const _: &str = "/// # Cron API\n///\n/// Event triggered on CRON schedule.\n///\n/// ## Event Scheduling\n///\n/// **Guarantee**: Cron events with the same tag will be delivered and executed in the order\n/// they occur.\n///\n/// **Guarantee**: Later cron events with the same tag will not begin processing until the\n/// previous cron event with that tag has been fully processed by all processors of the event.\n///\n/// **Warning**: Events with different tags can arrive out of sequence with respect to each other.\n/// Sequence is only guaranteed by the tag.\n\n/// CRON API Interface - Export ONLY\ninterface event {\n    use api.{cron-event-tag, cron-tagged};\n\n    /// Triggered when a cron event fires.\n    ///\n    /// This event is only ever generated for the application that added\n    /// the cron job.\n    ///\n    /// The module must export this interface to use it.\n    ///\n    /// ## Parameters\n    ///\n    /// - `event` : The tagged cron event that was triggered.\n    /// - `last` : This cron event will not retrigger.\n    ///\n    /// Returns:\n    /// - `true`  - retrigger. (Ignored if the cron event is `final`).\n    /// - `false` - stop the cron.\n    on-cron: func(event: cron-tagged, last: bool) -> bool;\n}\n\nworld cron-event {\n    export event;\n}";
    const _: &str = "/// # Cron API\n///\n/// Allow time based scheduling of events.\n///\n/// ## Permissions\n///\n/// This API is permissionless.\n\n// cspell: words crontabs mkcron retrigger retriggering\n\n/// CRON API Interface - Imports ONLY\ninterface api {\n\n    /// Get the `instant` type from the `wasi:clocks` module.\n    use wasi:clocks/monotonic-clock@0.2.0.{instant};\n\n    /// A Tag used to mark a delivered cron event.\n    type cron-event-tag = string;\n\n    /// A cron schedule in crontab format.\n    type cron-sched = string;\n\n    /// A tagged crontab entry\n    /// It is valid for multiple crontab entries at the same time to have different tags.\n    /// It is valid for crontab entries at different times to have the same tag.\n    /// BUT there can only ever be 1 crontab entry at a specified time with a specified tag.\n    /// ie, `when` + `tag` is uniquely identifying of every crontab entry.\n    /// See: [crontab.5 man page](https://www.man7.org/linux/man-pages/man5/crontab.5.html) for details on cron schedule format.\n    record cron-tagged {\n        /// The crontab entry in standard cron format.\n        /// The Time is ALWAYS relative to UTC and does not account for local time.\n        /// If Localtime adjustment is required it must be handled by the module.\n        when: cron-sched,\n\n        /// The tag associated with the crontab entry.\n        tag: cron-event-tag\n    }\n\n    /// A discreet time entry used to help convert numeric times into crontab entries.\n    variant cron-component {\n        // Maps to `*` in a cron schedule (ie, match all)\n        all,\n        // Match an absolute time/date\n        at(u8),\n        // Match an inclusive list of time/date values.\n        range(tuple<u8,u8>),\n    }\n\n    /// A list of cron time components\n    type cron-time = list<cron-component>;\n\n    /// # Schedule Recurrent CRON event\n    ///\n    /// Cron events will be delivered to the `on-cron` event handler.\n    ///\n    /// ## Parameters\n    ///\n    /// - `entry`: The crontab entry to add.\n    ///     - `when`: When the event triggers.  Standard crontab format.\n    ///     - `tag`: A tag which will accompany the triggered event.\n    /// - `retrigger`:\n    ///     - `true`: The event will re-trigger every time the crontab entry matches until cancelled.\n    ///     - `false`: The event will automatically cancel after it is generated once.\n    ///\n    /// ## Returns\n    ///\n    /// - `true`: Crontab added successfully.  (Or the crontab event already exists)\n    /// - `false`: Crontab failed to be added.\n    ///\n    /// ## Note:\n    ///\n    /// If the crontab entry already exists, the retrigger flag can be changed by calling\n    /// this function.  This could be useful where a retriggering crontab event is desired\n    /// to be stopped, but ONLY after it has triggered once more.\n    ///\n    add: func(entry: cron-tagged, retrigger: bool) -> bool;\n\n    /// # Schedule A Single cron event after a fixed delay.\n    ///\n    /// Allows for easy timed wait events to be delivered without\n    /// requiring datetime calculations or formatting cron entries.\n    ///\n    /// ## Parameters\n    ///\n    /// - `duration`: How many nanoseconds to delay.  The delay will be AT LEAST this long.\n    /// - `tag`: A tag which will accompany the triggered event.\n    ///\n    /// ## Returns\n    ///\n    /// - `true`: Crontab added successfully.\n    /// - `false`: Crontab failed to be added.\n    ///\n    /// ## Note:\n    ///\n    /// This is a convenience function which will automatically calculate the crontab\n    /// entry needed to trigger the event after the requested `duration`.\n    /// It is added as a non-retriggering event.\n    /// Listing the crontabs after this call will list the delay in addition to all other\n    /// crontab entries.\n    ///\n    delay: func(duration: instant, tag: cron-event-tag) -> bool;\n\n\n    /// # List currently active cron schedule.\n    ///\n    /// Allows for management of scheduled cron events.\n    ///\n    /// ## Parameters\n    ///\n    /// - `tag`: Optional, the tag to limit the list to.  If `none` then all crons listed.\n    ///\n    /// ## Returns\n    ///\n    /// - A list of tuples containing the scheduled crontabs and their tags, along with the current retrigger flag.\n    ///   The list is sorted from most crontab that will trigger soonest to latest.\n    ///   Crontabs are only listed once, in the case where a crontab may be scheduled\n    ///   may times before a later one.\n    ///     - `0` - `cron-tagged` - The Tagged crontab event.\n    ///     - `1` - `bool` - The state of the retrigger flag.\n    ///\n    ls: func(tag: option<cron-event-tag>) -> list<tuple<cron-tagged, bool>>;\n\n    /// # Remove the requested crontab.\n    ///\n    /// Allows for management of scheduled cron events.\n    ///\n    /// ## Parameters\n    ///\n    /// - `when`: The crontab entry to add.  Standard crontab format.\n    /// - `tag`: A tag which will accompany the triggered event.\n    ///\n    /// ## Returns\n    ///\n    /// - `true`: The requested crontab was deleted and will not trigger.\n    /// - `false`: The requested crontab does not exist.\n    ///\n    rm: func(entry: cron-tagged) -> bool;\n\n    /// # Make a crontab entry from individual time values.\n    ///\n    /// Crates the properly formatted cron entry\n    /// from numeric cron time components.\n    /// Convenience function to make building cron strings simpler when they are\n    /// calculated from data.\n    ///\n    /// ## Parameters\n    ///\n    /// - `dow` - DayOfWeek (0-7, 0 or 7 = Sunday)\n    /// - `month` - Month of the year (1-12, 1 = January)\n    /// - `day` - Day in the month (1-31)\n    /// - `hour` - Hour in the day (0-23)\n    /// - `minute` - Minute in the hour (0-59)\n    ///\n    /// ## Returns\n    ///\n    /// - A matching `cron-sched` ready for use in the cron functions above.\n    ///\n    /// ## Note:\n    /// No checking is done to determine if the requested date is valid.\n    /// If a particular component is out of its allowable range it will be silently\n    /// clamped within the allowable range of each parameter.\n    /// Redundant entries will be removed.\n    ///     - For example specifying a `month` as `3` and `2-4` will\n    ///         remove the individual month and only produce the range.\n    mkcron: func(dow: cron-time, month: cron-time, day: cron-time,\n                 hour: cron-time, minute: cron-time ) -> cron-sched;\n}\n\n/// World just for the Hermes \'cron\' API and Event.\nworld cron-api {\n    import api;\n}\n  ";
    const _: &str = "package hermes:cron;\n\nworld all {\n    import api;\n    export event;\n}\n";
    const _: &str = "package hermes:crypto;\n\nworld all {\n    import api;\n}\n";
    const _: &str = "/// # Crypto API\n///\n/// Crypto API functionality exposed to the Hermes WASM Modules.\n///\n/// ## Permissions\n///\n/// This API is ALWAYS available.\n\n/// Crypto API Interface\ninterface api {\n    use hermes:binary/api.{bstr, b256, b512};\n\n    // ed25519-bip32 Private Key\n    type ed25519-bip32-private-key = b256;\n\n    // ed25519-bip32 Extended Private Key\n    type ed25519-bip32-extended-private-key = b512;\n\n    // ed25519-bip32 Public Key\n    type ed25519-bip32-public-key = b256;\n\n    // ed25519-bip32 Signature\n    type ed25519-bip32-signature = b256;\n\n    resource ed25519-bip32 {\n        /// Create a new ED25519-BIP32 Crypto resource\n        /// \n        /// **Parameters**\n        ///\n        /// - `private_key` : The key to use, if not supplied one is RANDOMLY generated.\n        /// \n        constructor(private-key: option<list<ed25519-bip32-private-key>>);\n\n        /// Get the public key for this private key.\n        public-key: func() -> ed25519-bip32-public-key;\n\n        /// Sign data with the Private key, and return it.\n        /// \n        /// **Parameters**\n        ///\n        /// - `data` : The data to sign.\n        /// \n        sign-data: func(data: bstr) -> ed25519-bip32-signature;\n\n\n        /// Check a signature on a set of data.\n        /// \n        /// **Parameters**\n        ///\n        /// - `data` : The data to check.\n        /// - `sig`  : The signature to check.\n        /// \n        /// **Returns**\n        /// \n        /// - `true` : Signature checked OK.\n        /// - `false` : Signature check failed.\n        ///\n        check-sig: func(data: bstr, sig: ed25519-bip32-signature) -> bool;\n\n        /// Derive a new private key from the current private key.\n        /// \n        /// Note: uses BIP32 HD key derivation.\n        /// \n        derive: func() -> ed25519-bip32;\n\n        /// Create a new RANDOM private key.\n        /// \n        /// Note, this does not need to be used, as the constructor will do this automatically.\n        /// \n        gen-private-key: static func() -> ed25519-bip32-private-key;\n    }\n}\n\n/// World just for the Hermes \'json\' API.\nworld crypto-api {\n    import api;\n}\n";
    const _: &str = "/// # Data Hash API\n///\n/// Hashing Data types and functions.\n///\n/// ## Permissions\n///\n/// This API is permissionless.\n\n/// Hashing API Interface - Imports ONLY\ninterface api {\n    /// Get the `bstr` type from the `hermes:binary` module.\n    use hermes:binary/api.{bstr};\n\n    //  Errors that can occur during hashing.\n    enum errno {\n        key-too-big,  // The ley is larger than supported by the hash function.\n        hash-too-big  // The hash size requested is larger than supported by the hash function.\n    }\n\n    /// # BLAKE2s Hash Function\n    ///\n    /// Hash a binary buffer with BLAKE2s.\n    ///\n    /// ## Parameters\n    ///\n    /// - `buf`: The binary data buffer to hash.\n    /// - `outlen`: Optional.  The size of the digest.\n    ///             If the outlen is not defined, it defaults to 32.\n    /// - `key`: Optional. The key to use with the hash.\n    ///             If not defined, the hash is not keyed.\n    ///             Should not be > 32 bytes.\n    ///\n    /// ## Returns\n    ///\n    /// - Either a buffer the size requested, with the hash.\n    /// - Or an error:\n    ///     - `key_too_big` if `key` is specified and is > 32 bytes.\n    ///     - `hash_too_big` if `outlen` is specified and is > 32 bytes.\n    ///\n    /// ## Note:\n    ///\n    /// `key` length is checked before `outlen` so if both sizes are invalid, only\n    /// `key_too_big` will be returned.\n    ///\n    blake2s: func( buf: bstr, outlen: option<u8>, key: option<bstr> ) -> result<bstr, errno>;\n\n    /// # BLAKE2b Hash Function\n    ///\n    /// Hash a binary buffer with BLAKE2b.\n    ///\n    /// ## Parameters\n    ///\n    /// - `buf`: The binary data buffer to hash.\n    /// - `outlen`: Optional.  The size of the digest.\n    ///             If the outlen is not defined, it defaults to 64.\n    /// - `key`: Optional. The key to use with the hash.\n    ///             If not defined, the hash is not keyed.\n    ///             Should not be > 64 bytes.\n    ///\n    /// ## Returns\n    ///\n    /// - Either a buffer the size requested, with the hash.\n    /// - Or an error:\n    ///     - `key_too_big` if `key` is specified and is > 64 bytes.\n    ///     - `hash_too_big` if `outlen` is specified and is > 64 bytes.\n    ///\n    /// ## Note:\n    ///\n    /// `key` length is checked before `outlen` so if both sizes are invalid, only\n    /// `key_too_big` will be returned.\n    ///\n    blake2b: func( buf: bstr, outlen: option<u8>, key: option<bstr> ) -> result<bstr, errno>;\n\n    /// # BLAKE3 Hash Function\n    ///\n    /// Hash a binary buffer with BLAKE3.\n    ///\n    /// ## Parameters\n    ///\n    /// - `buf`: The binary data buffer to hash.\n    /// - `outlen`: Optional.  The size of the digest.\n    ///             If the outlen is not defined, it defaults to 32.\n    /// - `key`: Optional. The key to use with the hash.\n    ///             If not defined, the hash is not keyed.\n    ///             Should not be > 32 bytes.\n    ///\n    /// ## Returns\n    ///\n    /// - Either a buffer the size requested, with the hash.\n    /// - Or an error:\n    ///     - `key_too_big` if `key` is specified and is > 32 bytes.\n    ///     - `hash_too_big` if `outlen` is specified and is > 32 bytes.\n    ///\n    /// ## Note:\n    ///\n    /// `key` length is checked before `outlen` so if both sizes are invalid, only\n    /// `key_too_big` will be returned.\n    ///\n    blake3:  func( buf: bstr, outlen: option<u8>, key: option<bstr> ) -> result<bstr, errno>;   \n}\n\n\n/// World just for the Hermes \'hash\' API.\nworld hash-api {\n    import api;\n}\n  ";
    const _: &str = "package hermes:hash;\n\nworld all {\n    import api;\n}\n";
    const _: &str = "package hermes:init;\n\nworld all {\n    import event;\n}\n";
    const _: &str = "/// # Init API\n///\n/// The Init Event is only ever called once per application the webasm module is used in.\n///\n/// ## Permissions\n///\n/// This API is ALWAYS available, and not permissioned.\n\n/// Logging API Interface\ninterface event {\n\n    /// Perform application start up initialization.\n    ///\n    /// This will only ever be called once when the application this module is a part of is started.\n    /// The module must export this interface to use it.\n    ///\n    /// Returns:\n    /// - `true`  - Initialization is successful, the application may commence.\n    /// - `false` - Fatal error during Initialization.  DO NOT START APPLICATION.\n    init: func() -> bool;\n}";
    const _: &str = "package hermes:json;\n\nworld all {\n    import api;\n}\n";
    const _: &str = "/// # JSON API\n///\n/// JSON Data types and functions.\n///\n/// ## Permissions\n///\n/// This API is permissionless.\n\n// cspell: words\n\n/// JSON API Interface - Imports ONLY\ninterface api {\n    /// JSON is just a string.\n    ///   This type is used to indicate the string MUST be properly formatted JSON.\n    type json = string;\n}\n\n\n/// World just for the Hermes \'json\' API.\nworld json-api {\n    import api;\n}\n  ";
    const _: &str = "package hermes:kv-store;\n\nworld all {\n    import api;\n    import event;\n}\n";
    const _: &str = "/// Interface to local in-memory K-V database instance.\n/// \n/// This API is atomic.  It is safe to call it from multiple wasm modules in the same application.\n/// The atomic nature of these calls allows multiple wasm modules to communicate without data race \n/// conditions through the KV store.\n///\n/// These are primitive operations, and the caller is expected to provide more complex semaphore/mutex\n/// logic on top of these building blocks, if required.\n/// \n/// There is no support for multi-key atomic operations, the application is required to manage\n/// multi-key updates given the functionality provided here.\n/// For example, a single Key could be used to \"Lock\" a set of other keys.\n/// \n/// There is no protection against deadlock, if a key is used as a semaphore/mutex then it is the\n/// responsibility of the applications modules to properly manage them.\n/// \ninterface api {\n    /// Get the `bstr` type from the `hermes:binary` module.\n    use hermes:binary/api.{bstr};\n    /// Get the `cbor` type from the `hermes:cbor` module.\n    use hermes:cbor/api.{cbor};\n    /// Get the `json` type from the `hermes:json` module.\n    use hermes:json/api.{json};\n\n    /// A time and date in seconds plus nanoseconds.\n    variant kv-values {\n      kv-string(string),  // A String\n      kv-s64(s64),        // Just use the largest signed integer type supported\n      kv-u64(u64),        // Just use the largest integer type supported\n      kv-f64(float64),    // Just use the largest float type supported\n      kv-bstr(bstr),      // A byte string\n      kv-cbor(cbor),      // CBOR data\n      kv-json(json)       // JSON data\n    }\n\n  /// Set a value in the local key-value store\n  /// Setting None will cause the Key to be deleted from the KV store.\n  kv-set: func(key: string, value: option<kv-values>);\n\n  /// Get a value from the local key-value store\n  /// Returns the default if not set.\n  kv-get-default: func(key: string, default: option<kv-values>) -> option<kv-values>;\n\n  /// Get a value from the local key-value store\n  /// Returns None if the Key does not exist in the KV Store.\n  /// This is a convenience function, and is equivalent to `kv-get-default(key, none)`\n  kv-get: func(key: string) -> option<kv-values>;\n\n  /// Get a value, and then set it (Atomic)\n  /// Setting None will cause the Key to be deleted from the KV store.\n  kv-get-set: func(key: string, value: option<kv-values>) -> option<kv-values>;\n\n  /// Get a value, and then add to it (Atomic)\n  /// Adding to a string will concatenate the string.\n  ///   String concatenation will only occur up to the maximum possible size of a string value.\\\n  ///   Concatenation beyond the maximum size will result in truncation.\n  /// Adding to a numeric will have the expected behavior (rounded to nearest if necessary).\n  ///   The original type does not change, so: `float64 + u64 = float64`.  `s64 + float64 = s64`\n  ///   If the value overflows or under-flows it will saturate at the limit.\n  ///   This behavior allows us to decrement values by using the signed version, so `u64(10) + s64(-5) = u64(5))`\n  /// If a string is added to a numeric, nothing happens.\n  /// If a numeric is added to a string, it is converted to a string first, and then concatenated\n  ///   Note: There will be no spaces added.  So \"My string\" + u32(77) = \"My string77\"\n  kv-add: func(key: string, value: option<kv-values>) -> option<kv-values>;\n\n  /// Check if the Key equals a test value (exact match) and if it does, store the new value.\n  /// In all cases, the current value is returned.\n  /// If the types are NOT the same, the comparison will fail, even if the values are equivalent.\n  /// For example: `u64(7) != s64(7)`, `float64(-1) != s64(-1)`.\n  kv-cas: func(key: string, test: option<kv-values>, value: option<kv-values>) -> option<kv-values>;\n\n  /// Subscribe to any updates made to a particular Key.\n  /// After this call, this module will receive Key Update events when a key is written.\n  /// It returns the current value of the Key and None if it is not set.\n  kv-subscribe: func(key: string) -> option<kv-values>;\n\n  /// Unsubscribe to any updates made to a particular Key.\n  /// After this call, this module will no longer receive Key Update events when a key is written.\n  /// It returns the current value of the Key and None if it is not set.\n  kv-unsubscribe: func(key: string) -> option<kv-values>;\n}\n";
    const _: &str = "/// Interface to local in-memory K-V database instance.\n///\n/// ## Permissions\n///\n/// This API is ALWAYS available.  It is permissionless.\n\n/// Logging API Interface\ninterface event {\n\n    use api.{kv-values};\n\n    /// A Subscribed key has updated.\n    ///\n    /// This will only ever be called if the module has subscribed to updates using \n    /// `kv-subscribe`\n    ///\n    /// Returns:\n    ///     Nothing.\n    kv-update: func(key: string, value: kv-values);\n}";
    const _: &str = "package hermes:localtime;\n\n// API\n    // localtime struct\n        // timezone string\n        // dd(u8 1-31) mm(u8 1-12) yy (s16 -32677 - +32767) hh(u8 0-11) mm(u8 0-59) ss(u8 0-59)\n\n    // Get localized time\n        // (optional secs since 1970 UTC time)\n        // (optional timezone string)\n\n    // localtime to UTC time\n    \n\nworld all {\n    import api;\n}";
    const _: &str = "/// # Localtime API\n///\n/// Localtime API functionality exposed to the Hermes WASM Modules.\n///\n/// ## Permissions\n///\n/// This API is ALWAYS available.\n\n/// Logging API Interface\ninterface api {\n\n    /// Get the `datetime` type from the `wasi:clocks` module.\n    use wasi:clocks/wall-clock@0.2.0.{datetime};\n\n    // The timezone we are localized for.\n    type timezone = string;\n\n    // Time in localtime format.\n    record localtime {\n        year: u64,   // Year \n        month: u8,   // Month (0-11)\n        dow: u8,     // Day of week (0-6)\n        day: u8,     // Day (1-31)\n\n        hh: u8,      // Hour (0-23)\n        mm: u8,      // Minute (0-59)\n        ss: u8,      // Second (0-59)\n\n        ns: u32,     // Nanoseconds\n\n        tz: timezone // Timezone string.\n    }\n\n    // Errors that can occur converting times\n    enum errno {\n        invalid-localtime,\n        unknown-timezone,\n        year-out-of-range // The earliest year which can convert to a datetime is 1970.\n\n    }\n\n    /// Get localtime from a datetime or now.\n    /// \n    /// **Parameters**\n    /// \n    /// `when` : The datetime we want to convert (Optional, if not set it will convert `now`).\n    /// `tz` : The timezone to use. (Optional, if not set uses the local machines configured local timezone.)\n    /// \n    /// **Returns**\n    /// \n    /// `localtime` : the converted time.\n    /// `errno`     : An error indicating why conversion failed.\n    /// \n    get-localtime: func(when: option<datetime>, tz: option<timezone>) -> result<localtime, errno>;\n\n\n    /// Get a new localtime from a localtime, by recalculating time for a new timezone.\n    /// \n    /// **Parameters**\n    /// \n    /// `time` : The localtime to convert.\n    /// `tz` : The timezone to use. (Optional, if not set uses the local machines configured local timezone.)\n    /// \n    /// **Returns**\n    /// \n    /// `localtime` : the converted time.\n    /// `errno`     : An error indicating why conversion failed.\n    /// \n    alt-localtime: func(time: localtime, tz: option<timezone>) -> result<localtime, errno>;\n\n    /// Get a datetime from a localtime.\n    /// \n    /// **Parameters**\n    /// \n    /// `time` : The localtime to convert.\n    /// \n    /// **Returns**\n    /// \n    /// `datetime`  : the converted time.\n    /// `errno`     : An error indicating why conversion failed.\n    /// \n    get-datetime: func(time: localtime) -> result<datetime, errno>;\n}\n\n/// World just for the Hermes \'json\' API.\nworld localtime-api {\n    import api;\n}\n";
    const _: &str = "/// # Logging API\n///\n/// Logging API functionality exposed to the Hermes WASM Modules.\n///\n/// ## Permissions\n///\n/// This API is ALWAYS available, and not permissionless.\n\n/// Logging API Interface\ninterface api {\n    use hermes:json/api.{json};\n\n    /// The supported logging levels\n    enum level {\n        /// Debug Log Level\n        debug,\n        /// Tracing Log level\n        trace,\n        /// General Informational Log Level\n        info,\n        /// Warning about something that might be a problem.\n        warn,\n        /// A very serious error\n        error,\n    }\n\n    /// Generate a Log\n    ///\n    /// The Hermes API will add extra information to the log, such as the instance of the webasm\n    /// module being logged.\n    /// The Webasm module does not need to concern itself with this kind of information, and should\n    /// log as if it is the only instance.\n    /// It also should not log any webasm shared context, except where it is relevant to the log message itself.\n    ///\n    /// **Parameters**\n    ///\n    /// - `level` : The log level this message is for. \n    /// - `file`  : The name of the src file being logged from. (Optional)\n    /// - `fn`    : The function within the file being logged from. (Optional)\n    /// - `line`  : The line of code the log was generated from. (Optional)\n    /// - `col`   : The column of code the log was generated from. (Optional)\n    /// - `ctx`   : The logging context.  (Should have no newlines or formatting).\n    /// - `msg`   : A Single line message to be logged. (Should have no newlines or formatting).\n    /// - `data`  : A Free form json payload that will be logged with the msg.  This must be valid JSON.\n    ///\n    /// *Notes*\n    ///\n    /// The `data` parameter may contain a record of the format:\n    /// ```json\n    /// {\n    ///     \"bt\" : [ <string> , <string> ]\n    /// }\n    /// ```\n    /// The logger will interpret this as a backtrace where each entry in the array is one line of the backtrace.\n    /// The format of the backtrace lines is up to the webasm module generating the log.\n    /// The individual backtrace entries may contain line breaks if the backtrace entry is\n    /// multiline.\n    ///     * Multiline backtrace entries should be de-dented, relative to the first line.  \n    ///     * This is to allow the display to properly format multiline entries.\n    /// This format is designed to keep the broadest flexibility for multiple languages capabilities.\n    /// The backtrace must be sorted with most recent lines of the backtrace occurring first in the array.\n    /// Backtrace must be contained in a single `log` call.  Multiple log calls will be considered independent logs.\n    log: func(level: level, \n                file: option<string>, fn: option<string>, line: option<u32>, col:option<u32>, \n                ctx: option<string>, \n                msg: string, \n                data: option<json>);\n}\n\n/// World just for the Hermes \'json\' API.\nworld logging-api {\n    import api;\n}\n";
    const _: &str = "package hermes:logging;\n\nworld all {\n    import api;\n}\n";
    const _: &str = "package wasi:io@0.2.0;\n\n\ninterface error {\n    /// A resource which represents some error information.\n    ///\n    /// The only method provided by this resource is `to-debug-string`,\n    /// which provides some human-readable information about the error.\n    ///\n    /// In the `wasi:io` package, this resource is returned through the\n    /// `wasi:io/streams/stream-error` type.\n    ///\n    /// To provide more specific error information, other interfaces may\n    /// provide functions to further \"downcast\" this error into more specific\n    /// error information. For example, `error`s returned in streams derived\n    /// from filesystem types to be described using the filesystem\'s own\n    /// error-code type, using the function\n    /// `wasi:filesystem/types/filesystem-error-code`, which takes a parameter\n    /// `borrow<error>` and returns\n    /// `option<wasi:filesystem/types/error-code>`.\n    ///\n    /// The set of functions which can \"downcast\" an `error` into a more\n    /// concrete type is open.\n    resource error {\n        /// Returns a string that is suitable to assist humans in debugging\n        /// this error.\n        ///\n        /// WARNING: The returned string should not be consumed mechanically!\n        /// It may change across platforms, hosts, or other implementation\n        /// details. Parsing this string is a major platform-compatibility\n        /// hazard.\n        to-debug-string: func() -> string;\n    }\n}\n";
    const _: &str = "package wasi:io@0.2.0;\n\nworld imports {\n    import streams;\n    //import poll;\n}\n";
    const _: &str = "package wasi:io@0.2.0;\n\n/// WASI I/O is an I/O abstraction API which is currently focused on providing\n/// stream types.\n///\n/// In the future, the component model is expected to add built-in stream types;\n/// when it does, they are expected to subsume this API.\ninterface streams {\n    use error.{error};\n\n    /*\n    // Hermes does not support `poll`\n    use poll.{pollable};\n    */\n\n    /// An error for input-stream and output-stream operations.\n    variant stream-error {\n        /// The last operation (a write or flush) failed before completion.\n        ///\n        /// More information is available in the `error` payload.\n        last-operation-failed(error),\n        /// The stream is closed: no more input will be accepted by the\n        /// stream. A closed output-stream will return this error on all\n        /// future operations.\n        closed\n    }\n\n    /// An input bytestream.\n    ///\n    /// `input-stream`s are *non-blocking* to the extent practical on underlying\n    /// platforms. I/O operations always return promptly; if fewer bytes are\n    /// promptly available than requested, they return the number of bytes promptly\n    /// available, which could even be zero. To wait for data to be available,\n    /// use the `subscribe` function to obtain a `pollable` which can be polled\n    /// for using `wasi:io/poll`.\n    resource input-stream {\n        /// Perform a non-blocking read from the stream.\n        ///\n        /// This function returns a list of bytes containing the read data,\n        /// when successful. The returned list will contain up to `len` bytes;\n        /// it may return fewer than requested, but not more. The list is\n        /// empty when no bytes are available for reading at this time. The\n        /// pollable given by `subscribe` will be ready when more bytes are\n        /// available.\n        ///\n        /// This function fails with a `stream-error` when the operation\n        /// encounters an error, giving `last-operation-failed`, or when the\n        /// stream is closed, giving `closed`.\n        ///\n        /// When the caller gives a `len` of 0, it represents a request to\n        /// read 0 bytes. If the stream is still open, this call should\n        /// succeed and return an empty list, or otherwise fail with `closed`.\n        ///\n        /// The `len` parameter is a `u64`, which could represent a list of u8 which\n        /// is not possible to allocate in wasm32, or not desirable to allocate as\n        /// as a return value by the callee. The callee may return a list of bytes\n        /// less than `len` in size while more bytes are available for reading.\n        read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Read bytes from a stream, after blocking until at least one byte can\n        /// be read. Except for blocking, behavior is identical to `read`.\n        blocking-read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>;\n\n        /// Skip bytes from a stream. Returns number of bytes skipped.\n        ///\n        /// Behaves identical to `read`, except instead of returning a list\n        /// of bytes, returns the number of bytes consumed from the stream.\n        skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Skip bytes from a stream, after blocking until at least one byte\n        /// can be skipped. Except for blocking behavior, identical to `skip`.\n        blocking-skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /*\n        /// Create a `pollable` which will resolve once either the specified stream\n        /// has bytes available to read or the other end of the stream has been\n        /// closed.\n        /// The created `pollable` is a child resource of the `input-stream`.\n        /// Implementations may trap if the `input-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        subscribe: func() -> pollable;\n        */\n    }\n\n\n    /// An output bytestream.\n    ///\n    /// `output-stream`s are *non-blocking* to the extent practical on\n    /// underlying platforms. Except where specified otherwise, I/O operations also\n    /// always return promptly, after the number of bytes that can be written\n    /// promptly, which could even be zero. To wait for the stream to be ready to\n    /// accept data, the `subscribe` function to obtain a `pollable` which can be\n    /// polled for using `wasi:io/poll`.\n    resource output-stream {\n        /// Check readiness for writing. This function never blocks.\n        ///\n        /// Returns the number of bytes permitted for the next call to `write`,\n        /// or an error. Calling `write` with more bytes than this function has\n        /// permitted will trap.\n        ///\n        /// When this function returns 0 bytes, the `subscribe` pollable will\n        /// become ready when this function will report at least 1 byte, or an\n        /// error.\n        check-write: func() -> result<u64, stream-error>;\n\n        /// Perform a write. This function never blocks.\n        ///\n        /// Precondition: check-write gave permit of Ok(n) and contents has a\n        /// length of less than or equal to n. Otherwise, this function will trap.\n        ///\n        /// returns Err(closed) without writing if the stream has closed since\n        /// the last call to check-write provided a permit.\n        write: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 bytes, and then flush the stream. Block\n        /// until all of these operations are complete, or an error occurs.\n        ///\n        /// This is a convenience wrapper around the use of `check-write`,\n        /// `subscribe`, `write`, and `flush`, and is implemented with the\n        /// following pseudo-code:\n        ///\n        /// ```text\n        /// let pollable = this.subscribe();\n        /// while !contents.is_empty() {\n        ///     // Wait for the stream to become writable\n        ///     poll-one(pollable);\n        ///     let Ok(n) = this.check-write(); // eliding error handling\n        ///     let len = min(n, contents.len());\n        ///     let (chunk, rest) = contents.split_at(len);\n        ///     this.write(chunk  );            // eliding error handling\n        ///     contents = rest;\n        /// }\n        /// this.flush();\n        /// // Wait for completion of `flush`\n        /// poll-one(pollable);\n        /// // Check for any errors that arose during `flush`\n        /// let _ = this.check-write();         // eliding error handling\n        /// ```\n        blocking-write-and-flush: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>;\n\n        /// Request to flush buffered output. This function never blocks.\n        ///\n        /// This tells the output-stream that the caller intends any buffered\n        /// output to be flushed. the output which is expected to be flushed\n        /// is all that has been passed to `write` prior to this call.\n        ///\n        /// Upon calling this function, the `output-stream` will not accept any\n        /// writes (`check-write` will return `ok(0)`) until the flush has\n        /// completed. The `subscribe` pollable will become ready when the\n        /// flush has completed and the stream can accept more writes.\n        flush: func() -> result<_, stream-error>;\n\n        /// Request to flush buffered output, and block until flush completes\n        /// and stream is ready for writing again.\n        blocking-flush: func() -> result<_, stream-error>;\n\n        /*\n        /// Create a `pollable` which will resolve once the output-stream\n        /// is ready for more writing, or an error has occured. When this\n        /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an\n        /// error.\n        ///\n        /// If the stream is closed, this pollable is always ready immediately.\n        ///\n        /// The created `pollable` is a child resource of the `output-stream`.\n        /// Implementations may trap if the `output-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        subscribe: func() -> pollable;\n        */\n\n        /// Write zeroes to a stream.\n        ///\n        /// this should be used precisely like `write` with the exact same\n        /// preconditions (must use check-write first), but instead of\n        /// passing a list of bytes, you simply pass the number of zero-bytes\n        /// that should be written.\n        write-zeroes: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Perform a write of up to 4096 zeroes, and then flush the stream.\n        /// Block until all of these operations are complete, or an error\n        /// occurs.\n        ///\n        /// This is a convenience wrapper around the use of `check-write`,\n        /// `subscribe`, `write-zeroes`, and `flush`, and is implemented with\n        /// the following pseudo-code:\n        ///\n        /// ```text\n        /// let pollable = this.subscribe();\n        /// while num_zeroes != 0 {\n        ///     // Wait for the stream to become writable\n        ///     poll-one(pollable);\n        ///     let Ok(n) = this.check-write(); // eliding error handling\n        ///     let len = min(n, num_zeroes);\n        ///     this.write-zeroes(len);         // eliding error handling\n        ///     num_zeroes -= len;\n        /// }\n        /// this.flush();\n        /// // Wait for completion of `flush`\n        /// poll-one(pollable);\n        /// // Check for any errors that arose during `flush`\n        /// let _ = this.check-write();         // eliding error handling\n        /// ```\n        blocking-write-zeroes-and-flush: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>;\n\n        /// Read from one stream and write to another.\n        ///\n        /// The behavior of splice is equivelant to:\n        /// 1. calling `check-write` on the `output-stream`\n        /// 2. calling `read` on the `input-stream` with the smaller of the\n        /// `check-write` permitted length and the `len` provided to `splice`\n        /// 3. calling `write` on the `output-stream` with that read data.\n        ///\n        /// Any error reported by the call to `check-write`, `read`, or\n        /// `write` ends the splice and reports that error.\n        ///\n        /// This function returns the number of bytes transferred; it may be less\n        /// than `len`.\n        splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n\n        /// Read from one stream and write to another, with blocking.\n        ///\n        /// This is similar to `splice`, except that it blocks until the\n        /// `output-stream` is ready for writing, and the `input-stream`\n        /// is ready for reading, before performing the `splice`.\n        blocking-splice: func(\n            /// The stream to read from\n            src: borrow<input-stream>,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>;\n    }\n}\n";
    const _: &str = "package wasi:filesystem@0.2.0;\n\nworld imports {\n    import types;\n    import preopens;\n}\n";
    const _: &str = "package wasi:filesystem@0.2.0;\n\ninterface preopens {\n    use types.{descriptor};\n\n    /// Return the set of preopened directories, and their path.\n    get-directories: func() -> list<tuple<descriptor, string>>;\n}\n";
    const _: &str = "package wasi:filesystem@0.2.0;\n/// WASI filesystem is a filesystem API primarily intended to let users run WASI\n/// programs that access their files on their existing filesystems, without\n/// significant overhead.\n///\n/// It is intended to be roughly portable between Unix-family platforms and\n/// Windows, though it does not hide many of the major differences.\n///\n/// Paths are passed as interface-type `string`s, meaning they must consist of\n/// a sequence of Unicode Scalar Values (USVs). Some filesystems may contain\n/// paths which are not accessible by this API.\n///\n/// The directory separator in WASI is always the forward-slash (`/`).\n///\n/// All paths in WASI are relative paths, and are interpreted relative to a\n/// `descriptor` referring to a base directory. If a `path` argument to any WASI\n/// function starts with `/`, or if any step of resolving a `path`, including\n/// `..` and symbolic link steps, reaches a directory outside of the base\n/// directory, or reaches a symlink to an absolute or rooted path in the\n/// underlying filesystem, the function fails with `error-code::not-permitted`.\n///\n/// For more information about WASI path resolution and sandboxing, see\n/// [WASI filesystem path resolution].\n///\n/// [WASI filesystem path resolution]: https://github.com/WebAssembly/wasi-filesystem/blob/main/path-resolution.md\ninterface types {\n    use wasi:io/streams@0.2.0.{input-stream, output-stream, error};\n    use wasi:clocks/wall-clock@0.2.0.{datetime};\n\n    /// File size or length of a region within a file.\n    type filesize = u64;\n\n    /// The type of a filesystem object referenced by a descriptor.\n    ///\n    /// Note: This was called `filetype` in earlier versions of WASI.\n    enum descriptor-type {\n        /// The type of the descriptor or file is unknown or is different from\n        /// any of the other types specified.\n        unknown,\n        /// The descriptor refers to a block device inode.\n        block-device,\n        /// The descriptor refers to a character device inode.\n        character-device,\n        /// The descriptor refers to a directory inode.\n        directory,\n        /// The descriptor refers to a named pipe.\n        fifo,\n        /// The file refers to a symbolic link inode.\n        symbolic-link,\n        /// The descriptor refers to a regular file inode.\n        regular-file,\n        /// The descriptor refers to a socket.\n        socket,\n    }\n\n    /// Descriptor flags.\n    ///\n    /// Note: This was called `fdflags` in earlier versions of WASI.\n    flags descriptor-flags {\n        /// Read mode: Data can be read.\n        read,\n        /// Write mode: Data can be written to.\n        write,\n        /// Request that writes be performed according to synchronized I/O file\n        /// integrity completion. The data stored in the file and the file\'s\n        /// metadata are synchronized. This is similar to `O_SYNC` in POSIX.\n        ///\n        /// The precise semantics of this operation have not yet been defined for\n        /// WASI. At this time, it should be interpreted as a request, and not a\n        /// requirement.\n        file-integrity-sync,\n        /// Request that writes be performed according to synchronized I/O data\n        /// integrity completion. Only the data stored in the file is\n        /// synchronized. This is similar to `O_DSYNC` in POSIX.\n        ///\n        /// The precise semantics of this operation have not yet been defined for\n        /// WASI. At this time, it should be interpreted as a request, and not a\n        /// requirement.\n        data-integrity-sync,\n        /// Requests that reads be performed at the same level of integrety\n        /// requested for writes. This is similar to `O_RSYNC` in POSIX.\n        ///\n        /// The precise semantics of this operation have not yet been defined for\n        /// WASI. At this time, it should be interpreted as a request, and not a\n        /// requirement.\n        requested-write-sync,\n        /// Mutating directories mode: Directory contents may be mutated.\n        ///\n        /// When this flag is unset on a descriptor, operations using the\n        /// descriptor which would create, rename, delete, modify the data or\n        /// metadata of filesystem objects, or obtain another handle which\n        /// would permit any of those, shall fail with `error-code::read-only` if\n        /// they would otherwise succeed.\n        ///\n        /// This may only be set on directories.\n        mutate-directory,\n    }\n\n    /// File attributes.\n    ///\n    /// Note: This was called `filestat` in earlier versions of WASI.\n    record descriptor-stat {\n        /// File type.\n        %type: descriptor-type,\n        /// Number of hard links to the file.\n        link-count: link-count,\n        /// For regular files, the file size in bytes. For symbolic links, the\n        /// length in bytes of the pathname contained in the symbolic link.\n        size: filesize,\n        /// Last data access timestamp.\n        ///\n        /// If the `option` is none, the platform doesn\'t maintain an access\n        /// timestamp for this file.\n        data-access-timestamp: option<datetime>,\n        /// Last data modification timestamp.\n        ///\n        /// If the `option` is none, the platform doesn\'t maintain a\n        /// modification timestamp for this file.\n        data-modification-timestamp: option<datetime>,\n        /// Last file status-change timestamp.\n        ///\n        /// If the `option` is none, the platform doesn\'t maintain a\n        /// status-change timestamp for this file.\n        status-change-timestamp: option<datetime>,\n    }\n\n    /// Flags determining the method of how paths are resolved.\n    flags path-flags {\n        /// As long as the resolved path corresponds to a symbolic link, it is\n        /// expanded.\n        symlink-follow,\n    }\n\n    /// Open flags used by `open-at`.\n    flags open-flags {\n        /// Create file if it does not exist, similar to `O_CREAT` in POSIX.\n        create,\n        /// Fail if not a directory, similar to `O_DIRECTORY` in POSIX.\n        directory,\n        /// Fail if file already exists, similar to `O_EXCL` in POSIX.\n        exclusive,\n        /// Truncate file to size 0, similar to `O_TRUNC` in POSIX.\n        truncate,\n    }\n\n    /// Number of hard links to an inode.\n    type link-count = u64;\n\n    /// When setting a timestamp, this gives the value to set it to.\n    variant new-timestamp {\n        /// Leave the timestamp set to its previous value.\n        no-change,\n        /// Set the timestamp to the current time of the system clock associated\n        /// with the filesystem.\n        now,\n        /// Set the timestamp to the given value.\n        timestamp(datetime),\n    }\n\n    /// A directory entry.\n    record directory-entry {\n        /// The type of the file referred to by this directory entry.\n        %type: descriptor-type,\n\n        /// The name of the object.\n        name: string,\n    }\n\n    /// Error codes returned by functions, similar to `errno` in POSIX.\n    /// Not all of these error codes are returned by the functions provided by this\n    /// API; some are used in higher-level library layers, and others are provided\n    /// merely for alignment with POSIX.\n    enum error-code {\n        /// Permission denied, similar to `EACCES` in POSIX.\n        access,\n        /// Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX.\n        would-block,\n        /// Connection already in progress, similar to `EALREADY` in POSIX.\n        already,\n        /// Bad descriptor, similar to `EBADF` in POSIX.\n        bad-descriptor,\n        /// Device or resource busy, similar to `EBUSY` in POSIX.\n        busy,\n        /// Resource deadlock would occur, similar to `EDEADLK` in POSIX.\n        deadlock,\n        /// Storage quota exceeded, similar to `EDQUOT` in POSIX.\n        quota,\n        /// File exists, similar to `EEXIST` in POSIX.\n        exist,\n        /// File too large, similar to `EFBIG` in POSIX.\n        file-too-large,\n        /// Illegal byte sequence, similar to `EILSEQ` in POSIX.\n        illegal-byte-sequence,\n        /// Operation in progress, similar to `EINPROGRESS` in POSIX.\n        in-progress,\n        /// Interrupted function, similar to `EINTR` in POSIX.\n        interrupted,\n        /// Invalid argument, similar to `EINVAL` in POSIX.\n        invalid,\n        /// I/O error, similar to `EIO` in POSIX.\n        io,\n        /// Is a directory, similar to `EISDIR` in POSIX.\n        is-directory,\n        /// Too many levels of symbolic links, similar to `ELOOP` in POSIX.\n        loop,\n        /// Too many links, similar to `EMLINK` in POSIX.\n        too-many-links,\n        /// Message too large, similar to `EMSGSIZE` in POSIX.\n        message-size,\n        /// Filename too long, similar to `ENAMETOOLONG` in POSIX.\n        name-too-long,\n        /// No such device, similar to `ENODEV` in POSIX.\n        no-device,\n        /// No such file or directory, similar to `ENOENT` in POSIX.\n        no-entry,\n        /// No locks available, similar to `ENOLCK` in POSIX.\n        no-lock,\n        /// Not enough space, similar to `ENOMEM` in POSIX.\n        insufficient-memory,\n        /// No space left on device, similar to `ENOSPC` in POSIX.\n        insufficient-space,\n        /// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.\n        not-directory,\n        /// Directory not empty, similar to `ENOTEMPTY` in POSIX.\n        not-empty,\n        /// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.\n        not-recoverable,\n        /// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.\n        unsupported,\n        /// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.\n        no-tty,\n        /// No such device or address, similar to `ENXIO` in POSIX.\n        no-such-device,\n        /// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.\n        overflow,\n        /// Operation not permitted, similar to `EPERM` in POSIX.\n        not-permitted,\n        /// Broken pipe, similar to `EPIPE` in POSIX.\n        pipe,\n        /// Read-only file system, similar to `EROFS` in POSIX.\n        read-only,\n        /// Invalid seek, similar to `ESPIPE` in POSIX.\n        invalid-seek,\n        /// Text file busy, similar to `ETXTBSY` in POSIX.\n        text-file-busy,\n        /// Cross-device link, similar to `EXDEV` in POSIX.\n        cross-device,\n    }\n\n    /// File or memory access pattern advisory information.\n    enum advice {\n        /// The application has no advice to give on its behavior with respect\n        /// to the specified data.\n        normal,\n        /// The application expects to access the specified data sequentially\n        /// from lower offsets to higher offsets.\n        sequential,\n        /// The application expects to access the specified data in a random\n        /// order.\n        random,\n        /// The application expects to access the specified data in the near\n        /// future.\n        will-need,\n        /// The application expects that it will not access the specified data\n        /// in the near future.\n        dont-need,\n        /// The application expects to access the specified data once and then\n        /// not reuse it thereafter.\n        no-reuse,\n    }\n\n    /// A 128-bit hash value, split into parts because wasm doesn\'t have a\n    /// 128-bit integer type.\n    record metadata-hash-value {\n       /// 64 bits of a 128-bit hash value.\n       lower: u64,\n       /// Another 64 bits of a 128-bit hash value.\n       upper: u64,\n    }\n\n    /// A descriptor is a reference to a filesystem object, which may be a file,\n    /// directory, named pipe, special file, or other object on which filesystem\n    /// calls may be made.\n    resource descriptor {\n        /// Return a stream for reading from a file, if available.\n        ///\n        /// May fail with an error-code describing why the file cannot be read.\n        ///\n        /// Multiple read, write, and append streams may be active on the same open\n        /// file and they do not interfere with each other.\n        ///\n        /// Note: This allows using `read-stream`, which is similar to `read` in POSIX.\n        read-via-stream: func(\n            /// The offset within the file at which to start reading.\n            offset: filesize,\n        ) -> result<input-stream, error-code>;\n\n        /// Return a stream for writing to a file, if available.\n        ///\n        /// May fail with an error-code describing why the file cannot be written.\n        ///\n        /// Note: This allows using `write-stream`, which is similar to `write` in\n        /// POSIX.\n        write-via-stream: func(\n            /// The offset within the file at which to start writing.\n            offset: filesize,\n        ) -> result<output-stream, error-code>;\n\n        /// Return a stream for appending to a file, if available.\n        ///\n        /// May fail with an error-code describing why the file cannot be appended.\n        ///\n        /// Note: This allows using `write-stream`, which is similar to `write` with\n        /// `O_APPEND` in in POSIX.\n        append-via-stream: func() -> result<output-stream, error-code>;\n\n        /// Provide file advisory information on a descriptor.\n        ///\n        /// This is similar to `posix_fadvise` in POSIX.\n        advise: func(\n            /// The offset within the file to which the advisory applies.\n            offset: filesize,\n            /// The length of the region to which the advisory applies.\n            length: filesize,\n            /// The advice.\n            advice: advice\n        ) -> result<_, error-code>;\n\n        /// Synchronize the data of a file to disk.\n        ///\n        /// This function succeeds with no effect if the file descriptor is not\n        /// opened for writing.\n        ///\n        /// Note: This is similar to `fdatasync` in POSIX.\n        sync-data: func() -> result<_, error-code>;\n\n        /// Get flags associated with a descriptor.\n        ///\n        /// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.\n        ///\n        /// Note: This returns the value that was the `fs_flags` value returned\n        /// from `fdstat_get` in earlier versions of WASI.\n        get-flags: func() -> result<descriptor-flags, error-code>;\n\n        /// Get the dynamic type of a descriptor.\n        ///\n        /// Note: This returns the same value as the `type` field of the `fd-stat`\n        /// returned by `stat`, `stat-at` and similar.\n        ///\n        /// Note: This returns similar flags to the `st_mode & S_IFMT` value provided\n        /// by `fstat` in POSIX.\n        ///\n        /// Note: This returns the value that was the `fs_filetype` value returned\n        /// from `fdstat_get` in earlier versions of WASI.\n        get-type: func() -> result<descriptor-type, error-code>;\n\n        /// Adjust the size of an open file. If this increases the file\'s size, the\n        /// extra bytes are filled with zeros.\n        ///\n        /// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.\n        set-size: func(size: filesize) -> result<_, error-code>;\n\n        /// Adjust the timestamps of an open file or directory.\n        ///\n        /// Note: This is similar to `futimens` in POSIX.\n        ///\n        /// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.\n        set-times: func(\n            /// The desired values of the data access timestamp.\n            data-access-timestamp: new-timestamp,\n            /// The desired values of the data modification timestamp.\n            data-modification-timestamp: new-timestamp,\n        ) -> result<_, error-code>;\n\n        /// Read from a descriptor, without using and updating the descriptor\'s offset.\n        ///\n        /// This function returns a list of bytes containing the data that was\n        /// read, along with a bool which, when true, indicates that the end of the\n        /// file was reached. The returned list will contain up to `length` bytes; it\n        /// may return fewer than requested, if the end of the file is reached or\n        /// if the I/O operation is interrupted.\n        ///\n        /// In the future, this may change to return a `stream<u8, error-code>`.\n        ///\n        /// Note: This is similar to `pread` in POSIX.\n        read: func(\n            /// The maximum number of bytes to read.\n            length: filesize,\n            /// The offset within the file at which to read.\n            offset: filesize,\n        ) -> result<tuple<list<u8>, bool>, error-code>;\n\n        /// Write to a descriptor, without using and updating the descriptor\'s offset.\n        ///\n        /// It is valid to write past the end of a file; the file is extended to the\n        /// extent of the write, with bytes between the previous end and the start of\n        /// the write set to zero.\n        ///\n        /// In the future, this may change to take a `stream<u8, error-code>`.\n        ///\n        /// Note: This is similar to `pwrite` in POSIX.\n        write: func(\n            /// Data to write\n            buffer: list<u8>,\n            /// The offset within the file at which to write.\n            offset: filesize,\n        ) -> result<filesize, error-code>;\n\n        /// Read directory entries from a directory.\n        ///\n        /// On filesystems where directories contain entries referring to themselves\n        /// and their parents, often named `.` and `..` respectively, these entries\n        /// are omitted.\n        ///\n        /// This always returns a new stream which starts at the beginning of the\n        /// directory. Multiple streams may be active on the same directory, and they\n        /// do not interfere with each other.\n        read-directory: func() -> result<directory-entry-stream, error-code>;\n\n        /// Synchronize the data and metadata of a file to disk.\n        ///\n        /// This function succeeds with no effect if the file descriptor is not\n        /// opened for writing.\n        ///\n        /// Note: This is similar to `fsync` in POSIX.\n        sync: func() -> result<_, error-code>;\n\n        /// Create a directory.\n        ///\n        /// Note: This is similar to `mkdirat` in POSIX.\n        create-directory-at: func(\n            /// The relative path at which to create the directory.\n            path: string,\n        ) -> result<_, error-code>;\n\n        /// Return the attributes of an open file or directory.\n        ///\n        /// Note: This is similar to `fstat` in POSIX, except that it does not return\n        /// device and inode information. For testing whether two descriptors refer to\n        /// the same underlying filesystem object, use `is-same-object`. To obtain\n        /// additional data that can be used do determine whether a file has been\n        /// modified, use `metadata-hash`.\n        ///\n        /// Note: This was called `fd_filestat_get` in earlier versions of WASI.\n        stat: func() -> result<descriptor-stat, error-code>;\n\n        /// Return the attributes of a file or directory.\n        ///\n        /// Note: This is similar to `fstatat` in POSIX, except that it does not\n        /// return device and inode information. See the `stat` description for a\n        /// discussion of alternatives.\n        ///\n        /// Note: This was called `path_filestat_get` in earlier versions of WASI.\n        stat-at: func(\n            /// Flags determining the method of how the path is resolved.\n            path-flags: path-flags,\n            /// The relative path of the file or directory to inspect.\n            path: string,\n        ) -> result<descriptor-stat, error-code>;\n\n        /// Adjust the timestamps of a file or directory.\n        ///\n        /// Note: This is similar to `utimensat` in POSIX.\n        ///\n        /// Note: This was called `path_filestat_set_times` in earlier versions of\n        /// WASI.\n        set-times-at: func(\n            /// Flags determining the method of how the path is resolved.\n            path-flags: path-flags,\n            /// The relative path of the file or directory to operate on.\n            path: string,\n            /// The desired values of the data access timestamp.\n            data-access-timestamp: new-timestamp,\n            /// The desired values of the data modification timestamp.\n            data-modification-timestamp: new-timestamp,\n        ) -> result<_, error-code>;\n\n        /// Create a hard link.\n        ///\n        /// Note: This is similar to `linkat` in POSIX.\n        link-at: func(\n            /// Flags determining the method of how the path is resolved.\n            old-path-flags: path-flags,\n            /// The relative source path from which to link.\n            old-path: string,\n            /// The base directory for `new-path`.\n            new-descriptor: borrow<descriptor>,\n            /// The relative destination path at which to create the hard link.\n            new-path: string,\n        ) -> result<_, error-code>;\n\n        /// Open a file or directory.\n        ///\n        /// The returned descriptor is not guaranteed to be the lowest-numbered\n        /// descriptor not currently open/ it is randomized to prevent applications\n        /// from depending on making assumptions about indexes, since this is\n        /// error-prone in multi-threaded contexts. The returned descriptor is\n        /// guaranteed to be less than 2**31.\n        ///\n        /// If `flags` contains `descriptor-flags::mutate-directory`, and the base\n        /// descriptor doesn\'t have `descriptor-flags::mutate-directory` set,\n        /// `open-at` fails with `error-code::read-only`.\n        ///\n        /// If `flags` contains `write` or `mutate-directory`, or `open-flags`\n        /// contains `truncate` or `create`, and the base descriptor doesn\'t have\n        /// `descriptor-flags::mutate-directory` set, `open-at` fails with\n        /// `error-code::read-only`.\n        ///\n        /// Note: This is similar to `openat` in POSIX.\n        open-at: func(\n            /// Flags determining the method of how the path is resolved.\n            path-flags: path-flags,\n            /// The relative path of the object to open.\n            path: string,\n            /// The method by which to open the file.\n            open-flags: open-flags,\n            /// Flags to use for the resulting descriptor.\n            %flags: descriptor-flags,\n        ) -> result<descriptor, error-code>;\n\n        /// Read the contents of a symbolic link.\n        ///\n        /// If the contents contain an absolute or rooted path in the underlying\n        /// filesystem, this function fails with `error-code::not-permitted`.\n        ///\n        /// Note: This is similar to `readlinkat` in POSIX.\n        readlink-at: func(\n            /// The relative path of the symbolic link from which to read.\n            path: string,\n        ) -> result<string, error-code>;\n\n        /// Remove a directory.\n        ///\n        /// Return `error-code::not-empty` if the directory is not empty.\n        ///\n        /// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.\n        remove-directory-at: func(\n            /// The relative path to a directory to remove.\n            path: string,\n        ) -> result<_, error-code>;\n\n        /// Rename a filesystem object.\n        ///\n        /// Note: This is similar to `renameat` in POSIX.\n        rename-at: func(\n            /// The relative source path of the file or directory to rename.\n            old-path: string,\n            /// The base directory for `new-path`.\n            new-descriptor: borrow<descriptor>,\n            /// The relative destination path to which to rename the file or directory.\n            new-path: string,\n        ) -> result<_, error-code>;\n\n        /// Create a symbolic link (also known as a \"symlink\").\n        ///\n        /// If `old-path` starts with `/`, the function fails with\n        /// `error-code::not-permitted`.\n        ///\n        /// Note: This is similar to `symlinkat` in POSIX.\n        symlink-at: func(\n            /// The contents of the symbolic link.\n            old-path: string,\n            /// The relative destination path at which to create the symbolic link.\n            new-path: string,\n        ) -> result<_, error-code>;\n\n        /// Unlink a filesystem object that is not a directory.\n        ///\n        /// Return `error-code::is-directory` if the path refers to a directory.\n        /// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.\n        unlink-file-at: func(\n            /// The relative path to a file to unlink.\n            path: string,\n        ) -> result<_, error-code>;\n\n        /// Test whether two descriptors refer to the same filesystem object.\n        ///\n        /// In POSIX, this corresponds to testing whether the two descriptors have the\n        /// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.\n        /// wasi-filesystem does not expose device and inode numbers, so this function\n        /// may be used instead.\n        is-same-object: func(other: borrow<descriptor>) -> bool;\n\n        /// Return a hash of the metadata associated with a filesystem object referred\n        /// to by a descriptor.\n        ///\n        /// This returns a hash of the last-modification timestamp and file size, and\n        /// may also include the inode number, device number, birth timestamp, and\n        /// other metadata fields that may change when the file is modified or\n        /// replaced. It may also include a secret value chosen by the\n        /// implementation and not otherwise exposed.\n        ///\n        /// Implementations are encourated to provide the following properties:\n        ///\n        ///  - If the file is not modified or replaced, the computed hash value should\n        ///    usually not change.\n        ///  - If the object is modified or replaced, the computed hash value should\n        ///    usually change.\n        ///  - The inputs to the hash should not be easily computable from the\n        ///    computed hash.\n        ///\n        /// However, none of these is required.\n        metadata-hash: func() -> result<metadata-hash-value, error-code>;\n\n        /// Return a hash of the metadata associated with a filesystem object referred\n        /// to by a directory descriptor and a relative path.\n        ///\n        /// This performs the same hash computation as `metadata-hash`.\n        metadata-hash-at: func(\n            /// Flags determining the method of how the path is resolved.\n            path-flags: path-flags,\n            /// The relative path of the file or directory to inspect.\n            path: string,\n        ) -> result<metadata-hash-value, error-code>;\n    }\n\n    /// A stream of directory entries.\n    resource directory-entry-stream {\n        /// Read a single directory entry from a `directory-entry-stream`.\n        read-directory-entry: func() -> result<option<directory-entry>, error-code>;\n    }\n\n    /// Attempts to extract a filesystem-related `error-code` from the stream\n    /// `error` provided.\n    ///\n    /// Stream operations which return `stream-error::last-operation-failed`\n    /// have a payload with more information about the operation that failed.\n    /// This payload can be passed through to this function to see if there\'s\n    /// filesystem-related information about the error to return.\n    ///\n    /// Note that this function is fallible because not all stream-related\n    /// errors are filesystem-related errors.\n    filesystem-error-code: func(err: borrow<error>) -> option<error-code>;\n}\n";
    const _: &str = "package wasi:random@0.2.0;\n\nworld imports {\n    import random;\n    import insecure;\n    import insecure-seed;\n}\n";
    const _: &str = "package wasi:random@0.2.0;\n/// WASI Random is a random data API.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\ninterface random {\n    /// Return `len` cryptographically-secure random or pseudo-random bytes.\n    ///\n    /// This function must produce data at least as cryptographically secure and\n    /// fast as an adequately seeded cryptographically-secure pseudo-random\n    /// number generator (CSPRNG). It must not block, from the perspective of\n    /// the calling program, under any circumstances, including on the first\n    /// request and on requests for numbers of bytes. The returned data must\n    /// always be unpredictable.\n    ///\n    /// This function must always return fresh data. Deterministic environments\n    /// must omit this function, rather than implementing it with deterministic\n    /// data.\n    get-random-bytes: func(len: u64) -> list<u8>;\n\n    /// Return a cryptographically-secure random or pseudo-random `u64` value.\n    ///\n    /// This function returns the same type of data as `get-random-bytes`,\n    /// represented as a `u64`.\n    get-random-u64: func() -> u64;\n}\n";
    const _: &str = "package wasi:random@0.2.0;\n/// The insecure interface for insecure pseudo-random numbers.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\ninterface insecure {\n    /// Return `len` insecure pseudo-random bytes.\n    ///\n    /// This function is not cryptographically secure. Do not use it for\n    /// anything related to security.\n    ///\n    /// There are no requirements on the values of the returned bytes, however\n    /// implementations are encouraged to return evenly distributed values with\n    /// a long period.\n    get-insecure-random-bytes: func(len: u64) -> list<u8>;\n\n    /// Return an insecure pseudo-random `u64` value.\n    ///\n    /// This function returns the same type of pseudo-random data as\n    /// `get-insecure-random-bytes`, represented as a `u64`.\n    get-insecure-random-u64: func() -> u64;\n}\n";
    const _: &str = "package wasi:random@0.2.0;\n/// The insecure-seed interface for seeding hash-map DoS resistance.\n///\n/// It is intended to be portable at least between Unix-family platforms and\n/// Windows.\ninterface insecure-seed {\n    /// Return a 128-bit value that may contain a pseudo-random value.\n    ///\n    /// The returned value is not required to be computed from a CSPRNG, and may\n    /// even be entirely deterministic. Host implementations are encouraged to\n    /// provide pseudo-random values to any program exposed to\n    /// attacker-controlled content, to enable DoS protection built into many\n    /// languages\' hash-map implementations.\n    ///\n    /// This function is intended to only be called once, by a source language\n    /// to initialize Denial Of Service (DoS) protection in its hash-map\n    /// implementation.\n    ///\n    /// # Expected future evolution\n    ///\n    /// This will likely be changed to a value import, to prevent it from being\n    /// called multiple times and potentially used for purposes other than DoS\n    /// protection.\n    insecure-seed: func() -> tuple<u64, u64>;\n}\n";
    const _: &str = "interface environment {\n  /// Get the POSIX-style environment variables.\n  ///\n  /// Each environment variable is provided as a pair of string variable names\n  /// and string value.\n  ///\n  /// Morally, these are a value import, but until value imports are available\n  /// in the component model, this import function should return the same\n  /// values each time it is called.\n  get-environment: func() -> list<tuple<string, string>>;\n\n  /// Get the POSIX-style arguments to the program.\n  get-arguments: func() -> list<string>;\n\n  /// Return a path that programs should use as their initial current working\n  /// directory, interpreting `.` as shorthand for this.\n  initial-cwd: func() -> option<string>;\n}\n";
    const _: &str = "package wasi:cli@0.2.0;\n\nworld imports {\n  include wasi:clocks/imports@0.2.0;\n  include wasi:filesystem/imports@0.2.0;\n  // include wasi:sockets/imports@0.2.0; // Sockets are not available in hermes\n  include wasi:random/imports@0.2.0;\n  include wasi:io/imports@0.2.0;\n\n  import environment;\n  //import exit;\n  import stdin;\n  import stdout;\n  import stderr;\n\n  // Terminal IO not supported in Hermes.\n  //import terminal-input;\n  //import terminal-output;\n  //import terminal-stdin;\n  //import terminal-stdout;\n  //import terminal-stderr;\n}\n";
    const _: &str = "interface stdin {\n  use wasi:io/streams@0.2.0.{input-stream};\n\n  get-stdin: func() -> input-stream;\n}\n\ninterface stdout {\n  use wasi:io/streams@0.2.0.{output-stream};\n\n  get-stdout: func() -> output-stream;\n}\n\ninterface stderr {\n  use wasi:io/streams@0.2.0.{output-stream};\n\n  get-stderr: func() -> output-stream;\n}\n";
    const _: &str = "/// This interface defines a handler of incoming HTTP Requests. It should\n/// be exported by components which can respond to HTTP Requests.\ninterface incoming-handler {\n  use types.{incoming-request, response-outparam};\n\n  /// This function is invoked with an incoming HTTP Request, and a resource\n  /// `response-outparam` which provides the capability to reply with an HTTP\n  /// Response. The response is sent by calling the `response-outparam.set`\n  /// method, which allows execution to continue after the response has been\n  /// sent. This enables both streaming to the response body, and performing other\n  /// work.\n  ///\n  /// The implementor of this function must write a response to the\n  /// `response-outparam` before returning, or else the caller will respond\n  /// with an error on its behalf.\n  handle: func(\n    request: incoming-request,\n    response-out: response-outparam\n  );\n}\n\n/// This interface defines a handler of outgoing HTTP Requests. It should be\n/// imported by components which wish to make HTTP Requests.\ninterface outgoing-handler {\n  use types.{\n    outgoing-request, request-options, future-incoming-response, error-code\n  };\n\n  /// This function is invoked with an outgoing HTTP Request, and it returns\n  /// a resource `future-incoming-response` which represents an HTTP Response\n  /// which may arrive in the future.\n  ///\n  /// The `options` argument accepts optional parameters for the HTTP\n  /// protocol\'s transport layer.\n  ///\n  /// This function may return an error if the `outgoing-request` is invalid\n  /// or not allowed to be made. Otherwise, protocol errors are reported\n  /// through the `future-incoming-response`.\n  handle: func(\n    request: outgoing-request,\n    options: option<request-options>\n  ) -> result<future-incoming-response, error-code>;\n}\n";
    const _: &str = "package wasi:http@0.2.0;\n\n/// The `wasi:http/proxy` world captures a widely-implementable intersection of\n/// hosts that includes HTTP forward and reverse proxies. Components targeting\n/// this world may concurrently stream in and out any number of incoming and\n/// outgoing HTTP requests.\nworld proxy {\n  /// HTTP proxies have access to time and randomness.\n  include wasi:clocks/imports@0.2.0;\n  import wasi:random/random@0.2.0;\n\n  /// Proxies have standard output and error streams which are expected to\n  /// terminate in a developer-facing console provided by the host.\n  import wasi:cli/stdout@0.2.0;\n  import wasi:cli/stderr@0.2.0;\n\n  /// TODO: this is a temporary workaround until component tooling is able to\n  /// gracefully handle the absence of stdin. Hosts must return an eof stream\n  /// for this import, which is what wasi-libc + tooling will do automatically\n  /// when this import is properly removed.\n  import wasi:cli/stdin@0.2.0;\n\n  /// This is the default handler to use when user code simply wants to make an\n  /// HTTP request (e.g., via `fetch()`).\n  import outgoing-handler;\n\n  /// The host delivers incoming HTTP requests to a component by calling the\n  /// `handle` function of this exported interface. A host may arbitrarily reuse\n  /// or not reuse component instance when delivering incoming HTTP requests and\n  /// thus a component must be able to handle 0..N calls to `handle`.\n  export incoming-handler;\n}\n";
    const _: &str = "/// This interface defines all of the types and methods for implementing\n/// HTTP Requests and Responses, both incoming and outgoing, as well as\n/// their headers, trailers, and bodies.\ninterface types {\n  use wasi:clocks/monotonic-clock@0.2.0.{duration};\n  use wasi:io/streams@0.2.0.{input-stream, output-stream};\n  use wasi:io/error@0.2.0.{error as io-error};\n  \n  // Hermes doews not support `poll`\n  //use wasi:io/poll@0.2.0.{pollable};\n\n  /// This type corresponds to HTTP standard Methods.\n  variant method {\n    get,\n    head,\n    post,\n    put,\n    delete,\n    connect,\n    options,\n    trace,\n    patch,\n    other(string)\n  }\n\n  /// This type corresponds to HTTP standard Related Schemes.\n  variant scheme {\n    HTTP,\n    HTTPS,\n    other(string)\n  }\n\n  /// These cases are inspired by the IANA HTTP Proxy Error Types:\n  ///   https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types\n  variant error-code {\n    DNS-timeout,\n    DNS-error(DNS-error-payload),\n    destination-not-found,\n    destination-unavailable,\n    destination-IP-prohibited,\n    destination-IP-unroutable,\n    connection-refused,\n    connection-terminated,\n    connection-timeout,\n    connection-read-timeout,\n    connection-write-timeout,\n    connection-limit-reached,\n    TLS-protocol-error,\n    TLS-certificate-error,\n    TLS-alert-received(TLS-alert-received-payload),\n    HTTP-request-denied,\n    HTTP-request-length-required,\n    HTTP-request-body-size(option<u64>),\n    HTTP-request-method-invalid,\n    HTTP-request-URI-invalid,\n    HTTP-request-URI-too-long,\n    HTTP-request-header-section-size(option<u32>),\n    HTTP-request-header-size(option<field-size-payload>),\n    HTTP-request-trailer-section-size(option<u32>),\n    HTTP-request-trailer-size(field-size-payload),\n    HTTP-response-incomplete,\n    HTTP-response-header-section-size(option<u32>),\n    HTTP-response-header-size(field-size-payload),\n    HTTP-response-body-size(option<u64>),\n    HTTP-response-trailer-section-size(option<u32>),\n    HTTP-response-trailer-size(field-size-payload),\n    HTTP-response-transfer-coding(option<string>),\n    HTTP-response-content-coding(option<string>),\n    HTTP-response-timeout,\n    HTTP-upgrade-failed,\n    HTTP-protocol-error,\n    loop-detected,\n    configuration-error,\n    /// This is a catch-all error for anything that doesn\'t fit cleanly into a\n    /// more specific case. It also includes an optional string for an\n    /// unstructured description of the error. Users should not depend on the\n    /// string for diagnosing errors, as it\'s not required to be consistent\n    /// between implementations.\n    internal-error(option<string>)\n  }\n\n  /// Defines the case payload type for `DNS-error` above:\n  record DNS-error-payload {\n    rcode: option<string>,\n    info-code: option<u16>\n  }\n\n  /// Defines the case payload type for `TLS-alert-received` above:\n  record TLS-alert-received-payload {\n    alert-id: option<u8>,\n    alert-message: option<string>\n  }\n\n  /// Defines the case payload type for `HTTP-response-{header,trailer}-size` above:\n  record field-size-payload {\n    field-name: option<string>,\n    field-size: option<u32>\n  }\n\n  /// Attempts to extract a http-related `error` from the wasi:io `error`\n  /// provided.\n  ///\n  /// Stream operations which return\n  /// `wasi:io/stream/stream-error::last-operation-failed` have a payload of\n  /// type `wasi:io/error/error` with more information about the operation\n  /// that failed. This payload can be passed through to this function to see\n  /// if there\'s http-related information about the error to return.\n  ///\n  /// Note that this function is fallible because not all io-errors are\n  /// http-related errors.\n  http-error-code: func(err: borrow<io-error>) -> option<error-code>;\n\n  /// This type enumerates the different kinds of errors that may occur when\n  /// setting or appending to a `fields` resource.\n  variant header-error {\n    /// This error indicates that a `field-key` or `field-value` was\n    /// syntactically invalid when used with an operation that sets headers in a\n    /// `fields`.\n    invalid-syntax,\n\n    /// This error indicates that a forbidden `field-key` was used when trying\n    /// to set a header in a `fields`.\n    forbidden,\n\n    /// This error indicates that the operation on the `fields` was not\n    /// permitted because the fields are immutable.\n    immutable,\n  }\n\n  /// Field keys are always strings.\n  type field-key = string;\n\n  /// Field values should always be ASCII strings. However, in\n  /// reality, HTTP implementations often have to interpret malformed values,\n  /// so they are provided as a list of bytes.\n  type field-value = list<u8>;\n\n  /// This following block defines the `fields` resource which corresponds to\n  /// HTTP standard Fields. Fields are a common representation used for both\n  /// Headers and Trailers.\n  ///\n  /// A `fields` may be mutable or immutable. A `fields` created using the\n  /// constructor, `from-list`, or `clone` will be mutable, but a `fields`\n  /// resource given by other means (including, but not limited to,\n  /// `incoming-request.headers`, `outgoing-request.headers`) might be be\n  /// immutable. In an immutable fields, the `set`, `append`, and `delete`\n  /// operations will fail with `header-error.immutable`.\n  resource fields {\n\n    /// Construct an empty HTTP Fields.\n    ///\n    /// The resulting `fields` is mutable.\n    constructor();\n\n    /// Construct an HTTP Fields.\n    ///\n    /// The resulting `fields` is mutable.\n    ///\n    /// The list represents each key-value pair in the Fields. Keys\n    /// which have multiple values are represented by multiple entries in this\n    /// list with the same key.\n    ///\n    /// The tuple is a pair of the field key, represented as a string, and\n    /// Value, represented as a list of bytes. In a valid Fields, all keys\n    /// and values are valid UTF-8 strings. However, values are not always\n    /// well-formed, so they are represented as a raw list of bytes.\n    ///\n    /// An error result will be returned if any header or value was\n    /// syntactically invalid, or if a header was forbidden.\n    from-list: static func(\n      entries: list<tuple<field-key,field-value>>\n    ) -> result<fields, header-error>;\n\n    /// Get all of the values corresponding to a key. If the key is not present\n    /// in this `fields`, an empty list is returned. However, if the key is\n    /// present but empty, this is represented by a list with one or more\n    /// empty field-values present.\n    get: func(name: field-key) -> list<field-value>;\n\n    /// Returns `true` when the key is present in this `fields`. If the key is\n    /// syntactically invalid, `false` is returned.\n    has: func(name: field-key) -> bool;\n\n    /// Set all of the values for a key. Clears any existing values for that\n    /// key, if they have been set.\n    ///\n    /// Fails with `header-error.immutable` if the `fields` are immutable.\n    set: func(name: field-key, value: list<field-value>) -> result<_, header-error>;\n\n    /// Delete all values for a key. Does nothing if no values for the key\n    /// exist.\n    ///\n    /// Fails with `header-error.immutable` if the `fields` are immutable.\n    delete: func(name: field-key) -> result<_, header-error>;\n\n    /// Append a value for a key. Does not change or delete any existing\n    /// values for that key.\n    ///\n    /// Fails with `header-error.immutable` if the `fields` are immutable.\n    append: func(name: field-key, value: field-value) -> result<_, header-error>;\n\n    /// Retrieve the full set of keys and values in the Fields. Like the\n    /// constructor, the list represents each key-value pair.\n    ///\n    /// The outer list represents each key-value pair in the Fields. Keys\n    /// which have multiple values are represented by multiple entries in this\n    /// list with the same key.\n    entries: func() -> list<tuple<field-key,field-value>>;\n\n    /// Make a deep copy of the Fields. Equivelant in behavior to calling the\n    /// `fields` constructor on the return value of `entries`. The resulting\n    /// `fields` is mutable.\n    clone: func() -> fields;\n  }\n\n  /// Headers is an alias for Fields.\n  type headers = fields;\n\n  /// Trailers is an alias for Fields.\n  type trailers = fields;\n\n  /// Represents an incoming HTTP Request.\n  resource incoming-request {\n\n    /// Returns the method of the incoming request.\n    method: func() -> method;\n\n    /// Returns the path with query parameters from the request, as a string.\n    path-with-query: func() -> option<string>;\n\n    /// Returns the protocol scheme from the request.\n    scheme: func() -> option<scheme>;\n\n    /// Returns the authority from the request, if it was present.\n    authority: func() -> option<string>;\n\n    /// Get the `headers` associated with the request.\n    ///\n    /// The returned `headers` resource is immutable: `set`, `append`, and\n    /// `delete` operations will fail with `header-error.immutable`.\n    ///\n    /// The `headers` returned are a child resource: it must be dropped before\n    /// the parent `incoming-request` is dropped. Dropping this\n    /// `incoming-request` before all children are dropped will trap.\n    headers: func() -> headers;\n\n    /// Gives the `incoming-body` associated with this request. Will only\n    /// return success at most once, and subsequent calls will return error.\n    consume: func() -> result<incoming-body>;\n  }\n\n  /// Represents an outgoing HTTP Request.\n  resource outgoing-request {\n\n    /// Construct a new `outgoing-request` with a default `method` of `GET`, and\n    /// `none` values for `path-with-query`, `scheme`, and `authority`.\n    ///\n    /// * `headers` is the HTTP Headers for the Request.\n    ///\n    /// It is possible to construct, or manipulate with the accessor functions\n    /// below, an `outgoing-request` with an invalid combination of `scheme`\n    /// and `authority`, or `headers` which are not permitted to be sent.\n    /// It is the obligation of the `outgoing-handler.handle` implementation\n    /// to reject invalid constructions of `outgoing-request`.\n    constructor(\n      headers: headers\n    );\n\n    /// Returns the resource corresponding to the outgoing Body for this\n    /// Request.\n    ///\n    /// Returns success on the first call: the `outgoing-body` resource for\n    /// this `outgoing-request` can be retrieved at most once. Subsequent\n    /// calls will return error.\n    body: func() -> result<outgoing-body>;\n\n    /// Get the Method for the Request.\n    method: func() -> method;\n    /// Set the Method for the Request. Fails if the string present in a\n    /// `method.other` argument is not a syntactically valid method.\n    set-method: func(method: method) -> result;\n\n    /// Get the combination of the HTTP Path and Query for the Request.\n    /// When `none`, this represents an empty Path and empty Query.\n    path-with-query: func() -> option<string>;\n    /// Set the combination of the HTTP Path and Query for the Request.\n    /// When `none`, this represents an empty Path and empty Query. Fails is the\n    /// string given is not a syntactically valid path and query uri component.\n    set-path-with-query: func(path-with-query: option<string>) -> result;\n\n    /// Get the HTTP Related Scheme for the Request. When `none`, the\n    /// implementation may choose an appropriate default scheme.\n    scheme: func() -> option<scheme>;\n    /// Set the HTTP Related Scheme for the Request. When `none`, the\n    /// implementation may choose an appropriate default scheme. Fails if the\n    /// string given is not a syntactically valid uri scheme.\n    set-scheme: func(scheme: option<scheme>) -> result;\n\n    /// Get the HTTP Authority for the Request. A value of `none` may be used\n    /// with Related Schemes which do not require an Authority. The HTTP and\n    /// HTTPS schemes always require an authority.\n    authority: func() -> option<string>;\n    /// Set the HTTP Authority for the Request. A value of `none` may be used\n    /// with Related Schemes which do not require an Authority. The HTTP and\n    /// HTTPS schemes always require an authority. Fails if the string given is\n    /// not a syntactically valid uri authority.\n    set-authority: func(authority: option<string>) -> result;\n\n    /// Get the headers associated with the Request.\n    ///\n    /// The returned `headers` resource is immutable: `set`, `append`, and\n    /// `delete` operations will fail with `header-error.immutable`.\n    ///\n    /// This headers resource is a child: it must be dropped before the parent\n    /// `outgoing-request` is dropped, or its ownership is transfered to\n    /// another component by e.g. `outgoing-handler.handle`.\n    headers: func() -> headers;\n  }\n\n  /// Parameters for making an HTTP Request. Each of these parameters is\n  /// currently an optional timeout applicable to the transport layer of the\n  /// HTTP protocol.\n  ///\n  /// These timeouts are separate from any the user may use to bound a\n  /// blocking call to `wasi:io/poll.poll`.\n  resource request-options {\n    /// Construct a default `request-options` value.\n    constructor();\n\n    /// The timeout for the initial connect to the HTTP Server.\n    connect-timeout: func() -> option<duration>;\n\n    /// Set the timeout for the initial connect to the HTTP Server. An error\n    /// return value indicates that this timeout is not supported.\n    set-connect-timeout: func(duration: option<duration>) -> result;\n\n    /// The timeout for receiving the first byte of the Response body.\n    first-byte-timeout: func() -> option<duration>;\n\n    /// Set the timeout for receiving the first byte of the Response body. An\n    /// error return value indicates that this timeout is not supported.\n    set-first-byte-timeout: func(duration: option<duration>) -> result;\n\n    /// The timeout for receiving subsequent chunks of bytes in the Response\n    /// body stream.\n    between-bytes-timeout: func() -> option<duration>;\n\n    /// Set the timeout for receiving subsequent chunks of bytes in the Response\n    /// body stream. An error return value indicates that this timeout is not\n    /// supported.\n    set-between-bytes-timeout: func(duration: option<duration>) -> result;\n  }\n\n  /// Represents the ability to send an HTTP Response.\n  ///\n  /// This resource is used by the `wasi:http/incoming-handler` interface to\n  /// allow a Response to be sent corresponding to the Request provided as the\n  /// other argument to `incoming-handler.handle`.\n  resource response-outparam {\n\n    /// Set the value of the `response-outparam` to either send a response,\n    /// or indicate an error.\n    ///\n    /// This method consumes the `response-outparam` to ensure that it is\n    /// called at most once. If it is never called, the implementation\n    /// will respond with an error.\n    ///\n    /// The user may provide an `error` to `response` to allow the\n    /// implementation determine how to respond with an HTTP error response.\n    set: static func(\n      param: response-outparam,\n      response: result<outgoing-response, error-code>,\n    );\n  }\n\n  /// This type corresponds to the HTTP standard Status Code.\n  type status-code = u16;\n\n  /// Represents an incoming HTTP Response.\n  resource incoming-response {\n\n    /// Returns the status code from the incoming response.\n    status: func() -> status-code;\n\n    /// Returns the headers from the incoming response.\n    ///\n    /// The returned `headers` resource is immutable: `set`, `append`, and\n    /// `delete` operations will fail with `header-error.immutable`.\n    ///\n    /// This headers resource is a child: it must be dropped before the parent\n    /// `incoming-response` is dropped.\n    headers: func() -> headers;\n\n    /// Returns the incoming body. May be called at most once. Returns error\n    /// if called additional times.\n    consume: func() -> result<incoming-body>;\n  }\n\n  /// Represents an incoming HTTP Request or Response\'s Body.\n  ///\n  /// A body has both its contents - a stream of bytes - and a (possibly\n  /// empty) set of trailers, indicating that the full contents of the\n  /// body have been received. This resource represents the contents as\n  /// an `input-stream` and the delivery of trailers as a `future-trailers`,\n  /// and ensures that the user of this interface may only be consuming either\n  /// the body contents or waiting on trailers at any given time.\n  resource incoming-body {\n\n    /// Returns the contents of the body, as a stream of bytes.\n    ///\n    /// Returns success on first call: the stream representing the contents\n    /// can be retrieved at most once. Subsequent calls will return error.\n    ///\n    /// The returned `input-stream` resource is a child: it must be dropped\n    /// before the parent `incoming-body` is dropped, or consumed by\n    /// `incoming-body.finish`.\n    ///\n    /// This invariant ensures that the implementation can determine whether\n    /// the user is consuming the contents of the body, waiting on the\n    /// `future-trailers` to be ready, or neither. This allows for network\n    /// backpressure is to be applied when the user is consuming the body,\n    /// and for that backpressure to not inhibit delivery of the trailers if\n    /// the user does not read the entire body.\n    %stream: func() -> result<input-stream>;\n\n    /// Takes ownership of `incoming-body`, and returns a `future-trailers`.\n    /// This function will trap if the `input-stream` child is still alive.\n    finish: static func(this: incoming-body) -> future-trailers;\n  }\n\n  /// Represents a future which may eventaully return trailers, or an error.\n  ///\n  /// In the case that the incoming HTTP Request or Response did not have any\n  /// trailers, this future will resolve to the empty set of trailers once the\n  /// complete Request or Response body has been received.\n  resource future-trailers {\n\n    /// Returns a pollable which becomes ready when either the trailers have\n    /// been received, or an error has occured. When this pollable is ready,\n    /// the `get` method will return `some`.\n    //subscribe: func() -> pollable; // Hermes does NOT support `poll`\n\n    /// Returns the contents of the trailers, or an error which occured,\n    /// once the future is ready.\n    ///\n    /// The outer `option` represents future readiness. Users can wait on this\n    /// `option` to become `some` using the `subscribe` method.\n    ///\n    /// The outer `result` is used to retrieve the trailers or error at most\n    /// once. It will be success on the first call in which the outer option\n    /// is `some`, and error on subsequent calls.\n    ///\n    /// The inner `result` represents that either the HTTP Request or Response\n    /// body, as well as any trailers, were received successfully, or that an\n    /// error occured receiving them. The optional `trailers` indicates whether\n    /// or not trailers were present in the body.\n    ///\n    /// When some `trailers` are returned by this method, the `trailers`\n    /// resource is immutable, and a child. Use of the `set`, `append`, or\n    /// `delete` methods will return an error, and the resource must be\n    /// dropped before the parent `future-trailers` is dropped.\n    get: func() -> option<result<result<option<trailers>, error-code>>>;\n  }\n\n  /// Represents an outgoing HTTP Response.\n  resource outgoing-response {\n\n    /// Construct an `outgoing-response`, with a default `status-code` of `200`.\n    /// If a different `status-code` is needed, it must be set via the\n    /// `set-status-code` method.\n    ///\n    /// * `headers` is the HTTP Headers for the Response.\n    constructor(headers: headers);\n\n    /// Get the HTTP Status Code for the Response.\n    status-code: func() -> status-code;\n\n    /// Set the HTTP Status Code for the Response. Fails if the status-code\n    /// given is not a valid http status code.\n    set-status-code: func(status-code: status-code) -> result;\n\n    /// Get the headers associated with the Request.\n    ///\n    /// The returned `headers` resource is immutable: `set`, `append`, and\n    /// `delete` operations will fail with `header-error.immutable`.\n    ///\n    /// This headers resource is a child: it must be dropped before the parent\n    /// `outgoing-request` is dropped, or its ownership is transfered to\n    /// another component by e.g. `outgoing-handler.handle`.\n    headers: func() -> headers;\n\n    /// Returns the resource corresponding to the outgoing Body for this Response.\n    ///\n    /// Returns success on the first call: the `outgoing-body` resource for\n    /// this `outgoing-response` can be retrieved at most once. Subsequent\n    /// calls will return error.\n    body: func() -> result<outgoing-body>;\n  }\n\n  /// Represents an outgoing HTTP Request or Response\'s Body.\n  ///\n  /// A body has both its contents - a stream of bytes - and a (possibly\n  /// empty) set of trailers, inducating the full contents of the body\n  /// have been sent. This resource represents the contents as an\n  /// `output-stream` child resource, and the completion of the body (with\n  /// optional trailers) with a static function that consumes the\n  /// `outgoing-body` resource, and ensures that the user of this interface\n  /// may not write to the body contents after the body has been finished.\n  ///\n  /// If the user code drops this resource, as opposed to calling the static\n  /// method `finish`, the implementation should treat the body as incomplete,\n  /// and that an error has occured. The implementation should propogate this\n  /// error to the HTTP protocol by whatever means it has available,\n  /// including: corrupting the body on the wire, aborting the associated\n  /// Request, or sending a late status code for the Response.\n  resource outgoing-body {\n\n    /// Returns a stream for writing the body contents.\n    ///\n    /// The returned `output-stream` is a child resource: it must be dropped\n    /// before the parent `outgoing-body` resource is dropped (or finished),\n    /// otherwise the `outgoing-body` drop or `finish` will trap.\n    ///\n    /// Returns success on the first call: the `output-stream` resource for\n    /// this `outgoing-body` may be retrieved at most once. Subsequent calls\n    /// will return error.\n    write: func() -> result<output-stream>;\n\n    /// Finalize an outgoing body, optionally providing trailers. This must be\n    /// called to signal that the response is complete. If the `outgoing-body`\n    /// is dropped without calling `outgoing-body.finalize`, the implementation\n    /// should treat the body as corrupted.\n    ///\n    /// Fails if the body\'s `outgoing-request` or `outgoing-response` was\n    /// constructed with a Content-Length header, and the contents written\n    /// to the body (via `write`) does not match the value given in the\n    /// Content-Length.\n    finish: static func(\n      this: outgoing-body,\n      trailers: option<trailers>\n    ) -> result<_, error-code>;\n  }\n\n  /// Represents a future which may eventaully return an incoming HTTP\n  /// Response, or an error.\n  ///\n  /// This resource is returned by the `wasi:http/outgoing-handler` interface to\n  /// provide the HTTP Response corresponding to the sent Request.\n  resource future-incoming-response {\n    /*\n    /// Returns a pollable which becomes ready when either the Response has\n    /// been received, or an error has occured. When this pollable is ready,\n    /// the `get` method will return `some`.\n    subscribe: func() -> pollable;\n    */ \n    \n    /// Returns the incoming HTTP Response, or an error, once one is ready.\n    ///\n    /// The outer `option` represents future readiness. Users can wait on this\n    /// `option` to become `some` using the `subscribe` method.\n    ///\n    /// The outer `result` is used to retrieve the response or error at most\n    /// once. It will be success on the first call in which the outer option\n    /// is `some`, and error on subsequent calls.\n    ///\n    /// The inner `result` represents that either the incoming HTTP Response\n    /// status and headers have recieved successfully, or that an error\n    /// occured. Errors may also occur while consuming the response body,\n    /// but those will be reported by the `incoming-body` and its\n    /// `output-stream` child.\n    get: func() -> option<result<result<incoming-response, error-code>>>;\n\n  }\n}\n";
    const _: &str = "package hermes:wasi;\n\n/// This import every single API and exports every single entrypoint for a module.\n/// Modules ONLY need to import API\'s they actually use.\n/// Modules only need to implement the exports they require.\n/// Take note of any permissions attached to a particular API before using it.\nworld hermes {\n\n  /// All possible WASI compatible Imports/Exports\n  include wasi:cli/imports@0.2.0;\n  include wasi:http/proxy@0.2.0;\n\n  /// All possible Hermes Imports/Exports\n  include hermes:binary/all;\n  include hermes:cardano/all;\n  include hermes:cbor/all;\n  include hermes:cron/all;\n  include hermes:crypto/all;\n  include hermes:hash/all;\n  include hermes:init/all;\n  include hermes:json/all;\n  include hermes:kv-store/all;\n  include hermes:localtime/all;\n  include hermes:logging/all;\n}\n";
}
