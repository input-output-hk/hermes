#![allow(dead_code)]
//! Generic Responses are all contained in their own modules, grouped by response codes.

use code_401_unauthorized::Unauthorized;
use code_403_forbidden::Forbidden;
use code_412_precondition_failed::PreconditionFailed;
use code_429_too_many_requests::TooManyRequests;
use code_503_service_unavailable::ServiceUnavailable;
use log::{debug, error};

mod code_401_unauthorized;
mod code_403_forbidden;
mod code_412_precondition_failed;
mod code_429_too_many_requests;

pub(crate) mod code_500_internal_server_error;
pub(crate) mod code_503_service_unavailable;

use code_500_internal_server_error::InternalServerError;
use utoipa::ToSchema;

use super::types::headers::retry_after::{RetryAfterHeader, RetryAfterOption};

/// Default error responses
#[derive(ToSchema)]
pub enum ErrorResponses {
    /// ## Not Found
    ///
    /// The queried stake address was not found at the requested slot number.
    NotFound,

    /// ## Bad Request
    ///
    /// The client has not sent valid request, could be an invalid HTTP in general or
    /// provided not correct headers, path or query arguments.
    #[allow(dead_code)]
    BadRequest,

    /// ## Unauthorized
    ///
    /// The client has not sent valid authentication credentials for the requested
    /// resource.
    #[allow(dead_code)]
    Unauthorized(Unauthorized),

    /// ## Forbidden
    ///
    /// The client has not sent valid authentication credentials for the requested
    /// resource.
    #[allow(dead_code)]
    Forbidden(Forbidden),

    /// ## URI Too Long
    ///
    /// The client sent a request with the URI is longer than the server is willing to
    /// interpret
    #[allow(dead_code)]
    UriTooLong,

    /// ## Precondition Failed
    ///
    /// The client has not sent valid data in its request, headers, parameters or body.
    PreconditionFailed(PreconditionFailed),

    /// ## Too Many Requests
    ///
    /// The client has sent too many requests in a given amount of time.
    TooManyRequests(TooManyRequests, RetryAfterHeader),

    /// ## Request Header Fields Too Large
    ///
    /// The client sent a request with too large header fields.
    #[allow(dead_code)]
    RequestHeaderFieldsTooLarge,

    /// ## Internal Server Error.
    ///
    /// An internal server error occurred.
    ///
    /// *The contents of this response should be reported to the projects issue tracker.*
    ServerError(InternalServerError),

    /// ## Service Unavailable
    ///
    /// The service is not available, try again later.
    ///
    /// *This is returned when the service either has not started,
    /// or has become unavailable.*
    ServiceUnavailable(ServiceUnavailable, Option<RetryAfterHeader>),
}

impl ErrorResponses {
    /// Handle a 401 unauthorized response.
    ///
    /// Returns a 401 Unauthorized response.
    /// Its OK if we actually never call this.  Required for the API.
    /// May be generated by the ingress.
    #[must_use]
    pub fn unauthorized(text: String) -> Self {
        let error = Unauthorized::new(Some(text));
        ErrorResponses::Unauthorized(error)
    }

    /// Handle a 403 forbidden response.
    ///
    /// Returns a 403 Forbidden response.
    /// Its OK if we actually never call this.  Required for the API.
    /// May be generated by the ingress.
    #[must_use]
    pub fn forbidden(roles: Option<Vec<String>>) -> Self {
        let error = Forbidden::new(None, roles);
        ErrorResponses::Forbidden(error)
    }
}

/// Combine provided responses type with the default responses under one type.
#[derive(ToSchema)]
pub enum WithErrorResponses<T> {
    /// Provided responses
    With(T),
    /// Error responses
    Error(ErrorResponses),
}

impl<T> WithErrorResponses<T> {
    /// Handle a 5xx response.
    /// Returns a Server Error or a Service Unavailable response.
    #[must_use]
    pub fn handle_error(err: &anyhow::Error) -> Self {
        debug!("Handling Response for Internal Error; error={err:?}");
        Self::internal_error(err)
    }

    /// Handle a 503 service unavailable error response with passing a response `msg`.
    /// Its different with the original `service_unavailable` as it does not handles an
    /// error, though its no need to log the id of this response.
    ///
    /// Returns a 503 Service unavailable Error response.
    #[must_use]
    pub fn service_unavailable_with_msg(
        msg: String,
        retry: RetryAfterOption,
    ) -> Self {
        let error = ServiceUnavailable::new(Some(msg));
        let retry = match retry {
            RetryAfterOption::Default => Some(RetryAfterHeader::default()),
            RetryAfterOption::None => None,
            RetryAfterOption::Some(value) => Some(value),
        };
        WithErrorResponses::Error(ErrorResponses::ServiceUnavailable(error, retry))
    }

    /// Handle a 503 service unavailable error response.
    ///
    /// Returns a 503 Service unavailable Error response.
    #[must_use]
    pub fn service_unavailable(
        err: &anyhow::Error,
        retry: RetryAfterOption,
    ) -> Self {
        let error = ServiceUnavailable::new(None);
        error!(
            "id={}, error={:?}, retry_after={:?}",
            error.id(),
            err,
            retry
        );
        let retry = match retry {
            RetryAfterOption::Default => Some(RetryAfterHeader::default()),
            RetryAfterOption::None => None,
            RetryAfterOption::Some(value) => Some(value),
        };
        WithErrorResponses::Error(ErrorResponses::ServiceUnavailable(error, retry))
    }

    /// Handle a 500 internal error response.
    ///
    /// Returns a 500 Internal Error response.
    #[must_use]
    pub fn internal_error(err: &anyhow::Error) -> Self {
        let error = InternalServerError::new(None);
        log::error!("id={}, error={:?}", error.id(), err);
        WithErrorResponses::Error(ErrorResponses::ServerError(error))
    }

    /// Handle a 401 unauthorized response.
    ///
    /// Returns a 401 Unauthorized response.
    /// Its OK if we actually never call this.  Required for the API.
    /// May be generated by the ingress.
    #[must_use]
    pub fn unauthorized(text: String) -> Self {
        WithErrorResponses::Error(ErrorResponses::unauthorized(text))
    }

    /// Handle a 403 forbidden response.
    ///
    /// Returns a 403 Forbidden response.
    /// Its OK if we actually never call this.  Required for the API.
    /// May be generated by the ingress.
    #[must_use]
    pub fn forbidden(roles: Option<Vec<String>>) -> Self {
        WithErrorResponses::Error(ErrorResponses::forbidden(roles))
    }

    /// Handle a 412 precondition failed response.
    ///
    /// Returns a 412 precondition failed response.
    #[allow(dead_code)]
    fn precondition_failed(errors: Vec<anyhow::Error>) -> Self {
        let error = PreconditionFailed::new(errors);
        WithErrorResponses::Error(ErrorResponses::PreconditionFailed(error))
    }

    /// Handle a 429 rate limiting response.
    ///
    /// Returns a 429 Rate limit response.
    /// Its OK if we actually never call this.  Required for the API.
    /// May be generated by the ingress.
    #[must_use]
    pub fn rate_limit(retry_after: Option<RetryAfterHeader>) -> Self {
        let retry_after = retry_after.unwrap_or_default();
        let error = TooManyRequests::new(None);
        WithErrorResponses::Error(ErrorResponses::TooManyRequests(error, retry_after))
    }
}
