// Generated by `wit-bindgen` 0.29.0. DO NOT EDIT!
// Options used:
#[allow(dead_code)]
pub mod hermes {
  #[allow(dead_code)]
  pub mod binary {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      /// Binary String (bstr) is a list of bytes.
      /// This type is used to indicate the data is an arbitrary array of bytes.
      pub type Bstr = _rt::Vec::<u8>;
      /// 256 bit value
      pub type B256 = (u64,u64,u64,u64,);
      /// 512 bit value
      pub type B512 = (u64,u64,u64,u64,u64,u64,u64,u64,);

    }

  }
  #[allow(dead_code)]
  pub mod cardano {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Bstr = super::super::super::hermes::binary::api::Bstr;
      pub type Cbor = super::super::super::hermes::cbor::api::Cbor;
      /// Cardano Blocks are CBOR Data
      pub type CardanoBlock = Cbor;
      /// Cardano Transactions are CBOR Data
      pub type CardanoTxn = Cbor;
      /// The ID of the blockchain to interact with.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum CardanoBlockchainId {
        Mainnet,
        /// Cardano Mainnet
        Preprod,
        /// Cardano Preprod Network
        Preview,
        /// Cardano Preview Network
        LocalTestBlockchain,
      }
      impl ::core::fmt::Debug for CardanoBlockchainId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            CardanoBlockchainId::Mainnet => {
              f.debug_tuple("CardanoBlockchainId::Mainnet").finish()
            }
            CardanoBlockchainId::Preprod => {
              f.debug_tuple("CardanoBlockchainId::Preprod").finish()
            }
            CardanoBlockchainId::Preview => {
              f.debug_tuple("CardanoBlockchainId::Preview").finish()
            }
            CardanoBlockchainId::LocalTestBlockchain => {
              f.debug_tuple("CardanoBlockchainId::LocalTestBlockchain").finish()
            }
          }
        }
      }

      impl CardanoBlockchainId{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> CardanoBlockchainId{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => CardanoBlockchainId::Mainnet,
            1 => CardanoBlockchainId::Preprod,
            2 => CardanoBlockchainId::Preview,
            3 => CardanoBlockchainId::LocalTestBlockchain,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      wit_bindgen::rt::bitflags::bitflags! {
        /// Source information about where the block came from, and if we are at tip or not.
        #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
        pub struct BlockSrc: u8 {
          const TIP = 1 << 0;
          const NODE = 1 << 1;
          const MITHRIL = 1 << 2;
        }
      }
      /// The Slot number to interact with
      #[derive(Clone)]
      pub enum Slot {
        Genesis,
        /// The very start of the blockchain.
        Point((u64,Bstr,)),
        /// A particular slot number.
        Tip,
        /// The TIP of the blockchain.
        Continue,
      }
      impl ::core::fmt::Debug for Slot {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Slot::Genesis => {
              f.debug_tuple("Slot::Genesis").finish()
            }
            Slot::Point(e) => {
              f.debug_tuple("Slot::Point").field(e).finish()
            }
            Slot::Tip => {
              f.debug_tuple("Slot::Tip").finish()
            }
            Slot::Continue => {
              f.debug_tuple("Slot::Continue").finish()
            }
          }
        }
      }
      /// Errors that can happen fetching/subscribing to blocks
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum FetchError {
        BlockchainNotAvailable,
        /// The blockchain requested is not available.
        InvalidSlot,
      }
      impl FetchError{
        pub fn name(&self) -> &'static str {
          match self {
            FetchError::BlockchainNotAvailable => "blockchain-not-available",
            FetchError::InvalidSlot => "invalid-slot",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            FetchError::BlockchainNotAvailable => "",
            FetchError::InvalidSlot => "The blockchain requested is not available.",
          }
        }
      }
      impl ::core::fmt::Debug for FetchError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("FetchError")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for FetchError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl std::error::Error for FetchError {}

      impl FetchError{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> FetchError{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => FetchError::BlockchainNotAvailable,
            1 => FetchError::InvalidSlot,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Errors that can occur when posting transactions.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum TxnError {
        BlockchainNotAvailable,
        /// The blockchain requested is not available.
        MalformedTransaction,
        /// The transaction is not well formed, and can not be posted.
        PostTxnNotAllowed,
      }
      impl TxnError{
        pub fn name(&self) -> &'static str {
          match self {
            TxnError::BlockchainNotAvailable => "blockchain-not-available",
            TxnError::MalformedTransaction => "malformed-transaction",
            TxnError::PostTxnNotAllowed => "post-txn-not-allowed",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            TxnError::BlockchainNotAvailable => "",
            TxnError::MalformedTransaction => "The blockchain requested is not available.",
            TxnError::PostTxnNotAllowed => "The transaction is not well formed, and can not be posted.",
          }
        }
      }
      impl ::core::fmt::Debug for TxnError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("TxnError")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for TxnError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl std::error::Error for TxnError {}

      impl TxnError{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> TxnError{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => TxnError::BlockchainNotAvailable,
            1 => TxnError::MalformedTransaction,
            2 => TxnError::PostTxnNotAllowed,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      wit_bindgen::rt::bitflags::bitflags! {
        /// Options used to unsubscribe from the blockchain data flow.
        #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
        pub struct UnsubscribeOptions: u8 {
          const BLOCK = 1 << 0;
          /// Stop receiving block data
          const TRANSACTION = 1 << 1;
          /// Stop receiving txn data
          const ROLLBACK = 1 << 2;
          /// Stop receiving rollback data
          const STOP = 1 << 3;
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Subscribe to the Blockchain block data.
      ///
      /// **Parameters**
      ///
      /// - `net` : The blockchain network to fetch block from, and subscribe to.
      /// - `whence`: Where to start fetching blocks from.
      ///
      /// **Returns**
      ///
      /// - `ok(u64)` : The slot we are synching from now.
      /// - `error(fetch-error)` : If an error occured.
      ///
      /// **Notes**
      ///
      /// If the blockchain is not yet syncing, it will start, from the requested slot.
      /// If the blockchain is not yet syncing, and `whence` == `continue` then the blockchain will
      /// not be synced from, the calling module will only be subscribed for block events.
      ///
      /// If the blockchain is already syncing, the sync will stop and restart, unless `whence` == `continue`.
      /// When `whence` == `continue` the blockchain will keep syncing from where it is at, and this module
      /// will be subscribed to block updates.
      ///
      /// `whence` == `stop` will prevent the blockchain syncing, and the caller will be unsubscribed.
      pub fn subscribe_blocks(net: CardanoBlockchainId,whence: &Slot,) -> Result<u64,FetchError>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
          let (result2_0,result2_1,result2_2,result2_3,) = match whence {
            Slot::Genesis=> {
              (0i32, 0i64, ::core::ptr::null_mut(), 0usize)
            }
            Slot::Point(e) => {
              let (t0_0, t0_1, ) = e;
              let vec1 = t0_1;
              let ptr1 = vec1.as_ptr().cast::<u8>();
              let len1 = vec1.len();

              (1i32, _rt::as_i64(t0_0), ptr1.cast_mut(), len1)
            },
            Slot::Tip=> {
              (2i32, 0i64, ::core::ptr::null_mut(), 0usize)
            }
            Slot::Continue=> {
              (3i32, 0i64, ::core::ptr::null_mut(), 0usize)
            }
          };
          let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cardano/api")]
          extern "C" {
            #[link_name = "subscribe-blocks"]
            fn wit_import(_: i32, _: i32, _: i64, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i64, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(net.clone() as i32, result2_0, result2_1, result2_2, result2_3, ptr3);
          let l4 = i32::from(*ptr3.add(0).cast::<u8>());
          match l4 {
            0 => {
              let e = {
                let l5 = *ptr3.add(8).cast::<i64>();

                l5 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = i32::from(*ptr3.add(8).cast::<u8>());

                FetchError::_lift(l6 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Unsubscribe from the blockchain events listed.
      ///
      /// **Parameters**
      ///
      /// - `opts` : The events to unsubscribe from (and optionally stop the blockchain follower).
      ///
      /// **Notes**
      ///
      /// This only unsubscribes from the events.
      /// The option `stop` MUST be set to actually stop fetching data from the blockchain once started.
      ///
      /// `stop` can be set without unsubscribing, and this will interrupt the flow of blockchain data.
      /// After `stop`,  `subscribe-blocks(?, continue)` would cause blockchain sync to continue from
      /// the last block received.  This would result in the last block being sent as an event twice,
      /// once before the `stop` and once after the `continue`.
      pub fn unsubscribe(net: CardanoBlockchainId,opts: UnsubscribeOptions,){
        unsafe {
          let flags0 = opts;

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cardano/api")]
          extern "C" {
            #[link_name = "unsubscribe"]
            fn wit_import(_: i32, _: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, ){ unreachable!() }
          wit_import(net.clone() as i32, (flags0.bits() >> 0) as i32);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Subscribe to transaction data events, does not alter the blockchain sync in anyway.
      ///
      /// **Parameters**
      ///
      /// - `net` : The blockchain network to subscribe to txn events from.
      pub fn subscribe_txn(net: CardanoBlockchainId,){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cardano/api")]
          extern "C" {
            #[link_name = "subscribe-txn"]
            fn wit_import(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, ){ unreachable!() }
          wit_import(net.clone() as i32);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Subscribe to blockchain rollback events, does not alter the blockchain sync in anyway.
      ///
      /// **Parameters**
      ///
      /// - `net` : The blockchain network to subscribe to txn events from.
      ///
      /// **Notes**
      ///
      /// After a rollback event, the blockchain sync will AUTOMATICALLY start sending block
      /// data from the rollback point.  No action is required to actually follow the rollback, unless the
      /// default behavior is not desired.
      pub fn subscribe_rollback(net: CardanoBlockchainId,){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cardano/api")]
          extern "C" {
            #[link_name = "subscribe-rollback"]
            fn wit_import(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, ){ unreachable!() }
          wit_import(net.clone() as i32);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Fetch a block from the requested blockchain at the requested slot.
      ///
      /// **Parameters**
      ///
      /// - `net`    : The blockchain network to get a block from.
      /// - `whence` : Which block to get.
      ///
      /// **Returns**
      ///
      /// - `cardano-block` : The block requested.
      /// - `fetch-error` : An error if the block can not be fetched.
      ///
      /// **Notes**
      ///
      /// Fetching a block does not require the blockchain to be subscribed, or for blocks to be
      /// being followed and generating events.
      /// It also will not alter the automatic fetching of blocks in any way, and happens in parallel
      /// to automated block fetch.
      pub fn fetch_block(net: CardanoBlockchainId,whence: &Slot,) -> Result<CardanoBlock,FetchError>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let (result2_0,result2_1,result2_2,result2_3,) = match whence {
            Slot::Genesis=> {
              (0i32, 0i64, ::core::ptr::null_mut(), 0usize)
            }
            Slot::Point(e) => {
              let (t0_0, t0_1, ) = e;
              let vec1 = t0_1;
              let ptr1 = vec1.as_ptr().cast::<u8>();
              let len1 = vec1.len();

              (1i32, _rt::as_i64(t0_0), ptr1.cast_mut(), len1)
            },
            Slot::Tip=> {
              (2i32, 0i64, ::core::ptr::null_mut(), 0usize)
            }
            Slot::Continue=> {
              (3i32, 0i64, ::core::ptr::null_mut(), 0usize)
            }
          };
          let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cardano/api")]
          extern "C" {
            #[link_name = "fetch-block"]
            fn wit_import(_: i32, _: i32, _: i64, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i64, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(net.clone() as i32, result2_0, result2_1, result2_2, result2_3, ptr3);
          let l4 = i32::from(*ptr3.add(0).cast::<u8>());
          match l4 {
            0 => {
              let e = {
                let l5 = *ptr3.add(4).cast::<*mut u8>();
                let l6 = *ptr3.add(8).cast::<usize>();
                let len7 = l6;

                _rt::Vec::from_raw_parts(l5.cast(), len7, len7)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l8 = i32::from(*ptr3.add(4).cast::<u8>());

                FetchError::_lift(l8 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get transactions from a block.
      ///
      /// This can be used to easily extract all transactions from a complete block.
      ///
      /// **Parameters**
      ///
      /// - `block` : The blockchain data to extract transactions from.
      ///
      /// **Returns**
      ///
      /// - a list of all transactions in the block, in the order they appear in the block.
      ///
      /// **Notes**
      ///
      /// This function exists to support `fetch-block`.
      /// Transactions from subscribed block events, should be processed as transaction events.
      pub fn get_txns(block: &CardanoBlock,) -> _rt::Vec::<CardanoTxn>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let vec0 = block;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cardano/api")]
          extern "C" {
            #[link_name = "get-txns"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = *ptr1.add(0).cast::<*mut u8>();
          let l3 = *ptr1.add(4).cast::<usize>();
          let base7 = l2;
          let len7 = l3;
          let mut result7 = _rt::Vec::with_capacity(len7);
          for i in 0..len7 {
            let base = base7.add(i * 8);
            let e7 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(4).cast::<usize>();
              let len6 = l5;

              _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
            };
            result7.push(e7);
          }
          _rt::cabi_dealloc(base7, len7 * 8, 4);
          result7
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Post a transactions to the blockchain.
      ///
      /// This can be used to post a pre-formed transaction to the required blockchain.
      ///
      /// **Parameters**
      ///
      /// - `net` : The blockchain to post the transaction to.
      /// - `txn` : The transaction data, ready to submit.
      ///
      /// **Returns**
      ///
      /// - An error if the transaction can not be posted.
      ///
      /// **Notes**
      ///
      /// This is proposed functionality, and is not yet active.
      /// All calls to this function will return `post-txn-not-allowed` error.
      pub fn post_txn(net: CardanoBlockchainId,txn: &CardanoTxn,) -> Result<(),TxnError>{
        unsafe {
          #[repr(align(1))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
          let vec0 = txn;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cardano/api")]
          extern "C" {
            #[link_name = "post-txn"]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(net.clone() as i32, ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr1.add(1).cast::<u8>());

                TxnError::_lift(l3 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod cbor {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      pub type Bstr = super::super::super::hermes::binary::api::Bstr;
      /// CBOR is a binary cbor data type.
      /// This type is used to indicate the binary array MUST be CBOR data.
      pub type Cbor = Bstr;

    }

  }
  #[allow(dead_code)]
  pub mod cron {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Instant = super::super::super::wasi::clocks::monotonic_clock::Instant;
      /// A Tag used to mark a delivered cron event.
      pub type CronEventTag = _rt::String;
      /// A cron schedule in crontab format.
      pub type CronSched = _rt::String;
      /// A tagged crontab entry
      /// It is valid for multiple crontab entries at the same time to have different tags.
      /// It is valid for crontab entries at different times to have the same tag.
      /// BUT there can only ever be 1 crontab entry at a specified time with a specified tag.
      /// ie, `when` + `tag` is uniquely identifying of every crontab entry.
      /// See: [crontab.5 man page](https://www.man7.org/linux/man-pages/man5/crontab.5.html) for details on cron schedule format.
      #[derive(Clone)]
      pub struct CronTagged {
        /// The crontab entry in standard cron format.
        /// The Time is ALWAYS relative to UTC and does not account for local time.
        /// If Localtime adjustment is required it must be handled by the module.
        pub when: CronSched,
        /// The tag associated with the crontab entry.
        pub tag: CronEventTag,
      }
      impl ::core::fmt::Debug for CronTagged {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("CronTagged").field("when", &self.when).field("tag", &self.tag).finish()
        }
      }
      /// A discreet time entry used to help convert numeric times into crontab entries.
      #[derive(Clone, Copy)]
      pub enum CronComponent {
        /// Maps to `*` in a cron schedule (ie, match all)
        All,
        /// Match an absolute time/date
        At(u8),
        /// Match an inclusive list of time/date values.
        Range((u8,u8,)),
      }
      impl ::core::fmt::Debug for CronComponent {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            CronComponent::All => {
              f.debug_tuple("CronComponent::All").finish()
            }
            CronComponent::At(e) => {
              f.debug_tuple("CronComponent::At").field(e).finish()
            }
            CronComponent::Range(e) => {
              f.debug_tuple("CronComponent::Range").field(e).finish()
            }
          }
        }
      }
      /// A list of cron time components
      pub type CronTime = _rt::Vec::<CronComponent>;
      #[allow(unused_unsafe, clippy::all)]
      /// # Schedule Recurrent CRON event
      ///
      /// Cron events will be delivered to the `on-cron` event handler.
      ///
      /// ## Parameters
      ///
      /// - `entry`: The crontab entry to add.
      /// - `when`: When the event triggers.  Standard crontab format.
      /// - `tag`: A tag which will accompany the triggered event.
      /// - `retrigger`:
      /// - `true`: The event will re-trigger every time the crontab entry matches until cancelled.
      /// - `false`: The event will automatically cancel after it is generated once.
      ///
      /// ## Returns
      ///
      /// - `true`: Crontab added successfully.  (Or the crontab event already exists)
      /// - `false`: Crontab failed to be added.
      ///
      /// ## Note:
      ///
      /// If the crontab entry already exists, the retrigger flag can be changed by calling
      /// this function.  This could be useful where a retriggering crontab event is desired
      /// to be stopped, but ONLY after it has triggered once more.
      pub fn add(entry: &CronTagged,retrigger: bool,) -> bool{
        unsafe {
          let CronTagged{ when:when0, tag:tag0, } = entry;
          let vec1 = when0;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let vec2 = tag0;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cron/api")]
          extern "C" {
            #[link_name = "add"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, ) -> i32{ unreachable!() }
          let ret = wit_import(ptr1.cast_mut(), len1, ptr2.cast_mut(), len2, match &retrigger { true => 1, false => 0 });
          _rt::bool_lift(ret as u8)
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// # Schedule A Single cron event after a fixed delay.
      ///
      /// Allows for easy timed wait events to be delivered without
      /// requiring datetime calculations or formatting cron entries.
      ///
      /// ## Parameters
      ///
      /// - `duration`: How many nanoseconds to delay.  The delay will be AT LEAST this long.
      /// - `tag`: A tag which will accompany the triggered event.
      ///
      /// ## Returns
      ///
      /// - `true`: Crontab added successfully.
      /// - `false`: Crontab failed to be added.
      ///
      /// ## Note:
      ///
      /// This is a convenience function which will automatically calculate the crontab
      /// entry needed to trigger the event after the requested `duration`.
      /// It is added as a non-retriggering event.
      /// Listing the crontabs after this call will list the delay in addition to all other
      /// crontab entries.
      pub fn delay(duration: Instant,tag: &CronEventTag,) -> bool{
        unsafe {
          let vec0 = tag;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cron/api")]
          extern "C" {
            #[link_name = "delay"]
            fn wit_import(_: i64, _: *mut u8, _: usize, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: *mut u8, _: usize, ) -> i32{ unreachable!() }
          let ret = wit_import(_rt::as_i64(duration), ptr0.cast_mut(), len0);
          _rt::bool_lift(ret as u8)
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// # List currently active cron schedule.
      ///
      /// Allows for management of scheduled cron events.
      ///
      /// ## Parameters
      ///
      /// - `tag`: Optional, the tag to limit the list to.  If `none` then all crons listed.
      ///
      /// ## Returns
      ///
      /// - A list of tuples containing the scheduled crontabs and their tags, along with the current retrigger flag.
      /// The list is sorted from most crontab that will trigger soonest to latest.
      /// Crontabs are only listed once, in the case where a crontab may be scheduled
      /// may times before a later one.
      /// - `0` - `cron-tagged` - The Tagged crontab event.
      /// - `1` - `bool` - The state of the retrigger flag.
      pub fn ls(tag: Option<&CronEventTag>,) -> _rt::Vec::<(CronTagged,bool,)>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let (result1_0,result1_1,result1_2,) = match tag {
            Some(e) => {
              let vec0 = e;
              let ptr0 = vec0.as_ptr().cast::<u8>();
              let len0 = vec0.len();

              (1i32, ptr0.cast_mut(), len0)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cron/api")]
          extern "C" {
            #[link_name = "ls"]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(result1_0, result1_1, result1_2, ptr2);
          let l3 = *ptr2.add(0).cast::<*mut u8>();
          let l4 = *ptr2.add(4).cast::<usize>();
          let base12 = l3;
          let len12 = l4;
          let mut result12 = _rt::Vec::with_capacity(len12);
          for i in 0..len12 {
            let base = base12.add(i * 20);
            let e12 = {
              let l5 = *base.add(0).cast::<*mut u8>();
              let l6 = *base.add(4).cast::<usize>();
              let len7 = l6;
              let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
              let l8 = *base.add(8).cast::<*mut u8>();
              let l9 = *base.add(12).cast::<usize>();
              let len10 = l9;
              let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
              let l11 = i32::from(*base.add(16).cast::<u8>());

              (CronTagged{
                when: _rt::string_lift(bytes7),
                tag: _rt::string_lift(bytes10),
              }, _rt::bool_lift(l11 as u8))
            };
            result12.push(e12);
          }
          _rt::cabi_dealloc(base12, len12 * 20, 4);
          result12
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// # Remove the requested crontab.
      ///
      /// Allows for management of scheduled cron events.
      ///
      /// ## Parameters
      ///
      /// - `when`: The crontab entry to add.  Standard crontab format.
      /// - `tag`: A tag which will accompany the triggered event.
      ///
      /// ## Returns
      ///
      /// - `true`: The requested crontab was deleted and will not trigger.
      /// - `false`: The requested crontab does not exist.
      pub fn rm(entry: &CronTagged,) -> bool{
        unsafe {
          let CronTagged{ when:when0, tag:tag0, } = entry;
          let vec1 = when0;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let vec2 = tag0;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cron/api")]
          extern "C" {
            #[link_name = "rm"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, ) -> i32{ unreachable!() }
          let ret = wit_import(ptr1.cast_mut(), len1, ptr2.cast_mut(), len2);
          _rt::bool_lift(ret as u8)
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// # Make a crontab entry from individual time values.
      ///
      /// Crates the properly formatted cron entry
      /// from numeric cron time components.
      /// Convenience function to make building cron strings simpler when they are
      /// calculated from data.
      ///
      /// ## Parameters
      ///
      /// - `dow` - DayOfWeek (0-7, 0 or 7 = Sunday)
      /// - `month` - Month of the year (1-12, 1 = January)
      /// - `day` - Day in the month (1-31)
      /// - `hour` - Hour in the day (0-23)
      /// - `minute` - Minute in the hour (0-59)
      ///
      /// ## Returns
      ///
      /// - A matching `cron-sched` ready for use in the cron functions above.
      ///
      /// ## Note:
      /// No checking is done to determine if the requested date is valid.
      /// If a particular component is out of its allowable range it will be silently
      /// clamped within the allowable range of each parameter.
      /// Redundant entries will be removed.
      /// - For example specifying a `month` as `3` and `2-4` will
      /// remove the individual month and only produce the range.
      pub fn mkcron(dow: &CronTime,month: &CronTime,day: &CronTime,hour: &CronTime,minute: &CronTime,) -> CronSched{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let vec1 = dow;
          let len1 = vec1.len();
          let layout1 = _rt::alloc::Layout::from_size_align_unchecked(vec1.len() * 3, 1);
          let result1 = if layout1.size() != 0 {
            let ptr = _rt::alloc::alloc(layout1).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout1);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec1.into_iter().enumerate() {
            let base = result1.add(i * 3);
            {
              match e {
                CronComponent::All=> {
                  {
                    *base.add(0).cast::<u8>() = (0i32) as u8;
                  }
                }
                CronComponent::At(e) => {
                  *base.add(0).cast::<u8>() = (1i32) as u8;
                  *base.add(1).cast::<u8>() = (_rt::as_i32(e)) as u8;
                },
                CronComponent::Range(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  let (t0_0, t0_1, ) = e;
                  *base.add(1).cast::<u8>() = (_rt::as_i32(t0_0)) as u8;
                  *base.add(2).cast::<u8>() = (_rt::as_i32(t0_1)) as u8;
                },
              }
            }
          }
          let vec3 = month;
          let len3 = vec3.len();
          let layout3 = _rt::alloc::Layout::from_size_align_unchecked(vec3.len() * 3, 1);
          let result3 = if layout3.size() != 0 {
            let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout3);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec3.into_iter().enumerate() {
            let base = result3.add(i * 3);
            {
              match e {
                CronComponent::All=> {
                  {
                    *base.add(0).cast::<u8>() = (0i32) as u8;
                  }
                }
                CronComponent::At(e) => {
                  *base.add(0).cast::<u8>() = (1i32) as u8;
                  *base.add(1).cast::<u8>() = (_rt::as_i32(e)) as u8;
                },
                CronComponent::Range(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  let (t2_0, t2_1, ) = e;
                  *base.add(1).cast::<u8>() = (_rt::as_i32(t2_0)) as u8;
                  *base.add(2).cast::<u8>() = (_rt::as_i32(t2_1)) as u8;
                },
              }
            }
          }
          let vec5 = day;
          let len5 = vec5.len();
          let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 3, 1);
          let result5 = if layout5.size() != 0 {
            let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5.add(i * 3);
            {
              match e {
                CronComponent::All=> {
                  {
                    *base.add(0).cast::<u8>() = (0i32) as u8;
                  }
                }
                CronComponent::At(e) => {
                  *base.add(0).cast::<u8>() = (1i32) as u8;
                  *base.add(1).cast::<u8>() = (_rt::as_i32(e)) as u8;
                },
                CronComponent::Range(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  let (t4_0, t4_1, ) = e;
                  *base.add(1).cast::<u8>() = (_rt::as_i32(t4_0)) as u8;
                  *base.add(2).cast::<u8>() = (_rt::as_i32(t4_1)) as u8;
                },
              }
            }
          }
          let vec7 = hour;
          let len7 = vec7.len();
          let layout7 = _rt::alloc::Layout::from_size_align_unchecked(vec7.len() * 3, 1);
          let result7 = if layout7.size() != 0 {
            let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout7);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec7.into_iter().enumerate() {
            let base = result7.add(i * 3);
            {
              match e {
                CronComponent::All=> {
                  {
                    *base.add(0).cast::<u8>() = (0i32) as u8;
                  }
                }
                CronComponent::At(e) => {
                  *base.add(0).cast::<u8>() = (1i32) as u8;
                  *base.add(1).cast::<u8>() = (_rt::as_i32(e)) as u8;
                },
                CronComponent::Range(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  let (t6_0, t6_1, ) = e;
                  *base.add(1).cast::<u8>() = (_rt::as_i32(t6_0)) as u8;
                  *base.add(2).cast::<u8>() = (_rt::as_i32(t6_1)) as u8;
                },
              }
            }
          }
          let vec9 = minute;
          let len9 = vec9.len();
          let layout9 = _rt::alloc::Layout::from_size_align_unchecked(vec9.len() * 3, 1);
          let result9 = if layout9.size() != 0 {
            let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout9);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec9.into_iter().enumerate() {
            let base = result9.add(i * 3);
            {
              match e {
                CronComponent::All=> {
                  {
                    *base.add(0).cast::<u8>() = (0i32) as u8;
                  }
                }
                CronComponent::At(e) => {
                  *base.add(0).cast::<u8>() = (1i32) as u8;
                  *base.add(1).cast::<u8>() = (_rt::as_i32(e)) as u8;
                },
                CronComponent::Range(e) => {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                  let (t8_0, t8_1, ) = e;
                  *base.add(1).cast::<u8>() = (_rt::as_i32(t8_0)) as u8;
                  *base.add(2).cast::<u8>() = (_rt::as_i32(t8_1)) as u8;
                },
              }
            }
          }
          let ptr10 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:cron/api")]
          extern "C" {
            #[link_name = "mkcron"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(result1, len1, result3, len3, result5, len5, result7, len7, result9, len9, ptr10);
          let l11 = *ptr10.add(0).cast::<*mut u8>();
          let l12 = *ptr10.add(4).cast::<usize>();
          let len13 = l12;
          let bytes13 = _rt::Vec::from_raw_parts(l11.cast(), len13, len13);
          if layout1.size() != 0 {
            _rt::alloc::dealloc(result1.cast(), layout1);
          }
          if layout3.size() != 0 {
            _rt::alloc::dealloc(result3.cast(), layout3);
          }
          if layout5.size() != 0 {
            _rt::alloc::dealloc(result5.cast(), layout5);
          }
          if layout7.size() != 0 {
            _rt::alloc::dealloc(result7.cast(), layout7);
          }
          if layout9.size() != 0 {
            _rt::alloc::dealloc(result9.cast(), layout9);
          }
          _rt::string_lift(bytes13)
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod crypto {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Bstr = super::super::super::hermes::binary::api::Bstr;
      pub type B256 = super::super::super::hermes::binary::api::B256;
      pub type B512 = super::super::super::hermes::binary::api::B512;
      /// Errors that can occurs.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum Errno {
        PrefixTooLong,
        /// The prefix is longer than the maximum allowed length, max is 3.
        InvalidMnemonicLength,
        /// The mnemonic length is not a multiple of 3 or not in the range of 12 - 24.
        WordNotFound,
        /// A word in the mnemonic is not found in the word list.
        InvalidMnemonic,
        /// The mnemonic is invalid.
        InvalidDerivationalPath,
        /// The derivational path is invalid.
        GenerateEntropyFailed,
        /// Failed to generate entropy.
        UnsupportedLanguage,
      }
      impl Errno{
        pub fn name(&self) -> &'static str {
          match self {
            Errno::PrefixTooLong => "prefix-too-long",
            Errno::InvalidMnemonicLength => "invalid-mnemonic-length",
            Errno::WordNotFound => "word-not-found",
            Errno::InvalidMnemonic => "invalid-mnemonic",
            Errno::InvalidDerivationalPath => "invalid-derivational-path",
            Errno::GenerateEntropyFailed => "generate-entropy-failed",
            Errno::UnsupportedLanguage => "unsupported-language",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            Errno::PrefixTooLong => "",
            Errno::InvalidMnemonicLength => "The prefix is longer than the maximum allowed length, max is 3.",
            Errno::WordNotFound => "The mnemonic length is not a multiple of 3 or not in the range of 12 - 24.",
            Errno::InvalidMnemonic => "A word in the mnemonic is not found in the word list.",
            Errno::InvalidDerivationalPath => "The mnemonic is invalid.",
            Errno::GenerateEntropyFailed => "The derivational path is invalid.",
            Errno::UnsupportedLanguage => "Failed to generate entropy.",
          }
        }
      }
      impl ::core::fmt::Debug for Errno{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Errno")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for Errno{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl std::error::Error for Errno {}

      impl Errno{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> Errno{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => Errno::PrefixTooLong,
            1 => Errno::InvalidMnemonicLength,
            2 => Errno::WordNotFound,
            3 => Errno::InvalidMnemonic,
            4 => Errno::InvalidDerivationalPath,
            5 => Errno::GenerateEntropyFailed,
            6 => Errno::UnsupportedLanguage,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// bip32-ed25519 Public Key
      pub type Bip32Ed25519PublicKey = B256;
      /// bip32-ed25519 Signature
      pub type Bip32Ed25519Signature = B512;
      /// Mnemonic
      pub type MnemonicPhrase = _rt::Vec::<_rt::String>;
      /// Passphrase
      pub type Passphrase = _rt::Vec::<_rt::String>;
      /// Derivation path
      pub type Path = _rt::String;
      pub type Prefix = _rt::Vec::<_rt::String>;

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Bip32Ed25519{
        handle: _rt::Resource<Bip32Ed25519>,
      }

      impl Bip32Ed25519{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for Bip32Ed25519{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "hermes:crypto/api")]
            extern "C" {
              #[link_name = "[resource-drop]bip32-ed25519"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      #[allow(unused_unsafe, clippy::all)]
      /// # Generate BIP39 Mnemonic Function
      ///
      /// Generate a new BIP39 mnemonic phrase with the given
      /// size, prefix and language.
      ///
      /// ## Parameters
      ///
      /// `size` : The size of the mnemonic. Must be a multiple of 3 and in the range of 12 - 24.
      /// `prefix` : The prefix for the mnemonic. Must be a list of 1 - 3 words.
      /// `language` : Optional. The language to use for the mnemonic.
      /// If not provided, the default language is used.
      ///
      /// ## Returns
      ///
      /// - Either a list of mnemonic words.
      /// - Or an error if the mnemonic could not be generated:
      /// - `prefix-too-long` : The prefix is longer than the maximum allowed length, max is 3.
      /// - `invalid-mnemonic-length` : The mnemonic length is not a multiple of 3 or not in the range of 12 - 24.
      /// - `word-not-found` : A word in the mnemonic is not found in the word list.
      /// - `generate-entropy-failed` : Failed to generate entropy.
      pub fn generate_mnemonic(size: u8,prefix: &Prefix,language: Option<&str>,) -> Result<MnemonicPhrase,Errno>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let vec1 = prefix;
          let len1 = vec1.len();
          let layout1 = _rt::alloc::Layout::from_size_align_unchecked(vec1.len() * 8, 4);
          let result1 = if layout1.size() != 0 {
            let ptr = _rt::alloc::alloc(layout1).cast::<u8>();
            if ptr.is_null()
            {
              _rt::alloc::handle_alloc_error(layout1);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec1.into_iter().enumerate() {
            let base = result1.add(i * 8);
            {
              let vec0 = e;
              let ptr0 = vec0.as_ptr().cast::<u8>();
              let len0 = vec0.len();
              *base.add(4).cast::<usize>() = len0;
              *base.add(0).cast::<*mut u8>() = ptr0.cast_mut();
            }
          }
          let (result3_0,result3_1,result3_2,) = match language {
            Some(e) => {
              let vec2 = e;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();

              (1i32, ptr2.cast_mut(), len2)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:crypto/api")]
          extern "C" {
            #[link_name = "generate-mnemonic"]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i32(&size), result1, len1, result3_0, result3_1, result3_2, ptr4);
          let l5 = i32::from(*ptr4.add(0).cast::<u8>());
          if layout1.size() != 0 {
            _rt::alloc::dealloc(result1.cast(), layout1);
          }
          match l5 {
            0 => {
              let e = {
                let l6 = *ptr4.add(4).cast::<*mut u8>();
                let l7 = *ptr4.add(8).cast::<usize>();
                let base11 = l6;
                let len11 = l7;
                let mut result11 = _rt::Vec::with_capacity(len11);
                for i in 0..len11 {
                  let base = base11.add(i * 8);
                  let e11 = {
                    let l8 = *base.add(0).cast::<*mut u8>();
                    let l9 = *base.add(4).cast::<usize>();
                    let len10 = l9;
                    let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                    _rt::string_lift(bytes10)
                  };
                  result11.push(e11);
                }
                _rt::cabi_dealloc(base11, len11 * 8, 4);

                result11
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l12 = i32::from(*ptr4.add(4).cast::<u8>());

                Errno::_lift(l12 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      impl Bip32Ed25519 {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a new BIP32-Ed25519 Crypto resource
        ///
        /// **Parameters**
        ///
        /// - `mnemonic-phrase` : BIP39 mnemonic.
        /// - `passphrase` : Optional BIP39 passphrase.
        pub fn new(mnemonic: &MnemonicPhrase,passphrase: Option<&Passphrase>,) -> Self{
          unsafe {
            let mut cleanup_list = _rt::Vec::new();
            let vec1 = mnemonic;
            let len1 = vec1.len();
            let layout1 = _rt::alloc::Layout::from_size_align_unchecked(vec1.len() * 8, 4);
            let result1 = if layout1.size() != 0 {
              let ptr = _rt::alloc::alloc(layout1).cast::<u8>();
              if ptr.is_null()
              {
                _rt::alloc::handle_alloc_error(layout1);
              }
              ptr
            }else {{
              ::core::ptr::null_mut()
            }};
            for (i, e) in vec1.into_iter().enumerate() {
              let base = result1.add(i * 8);
              {
                let vec0 = e;
                let ptr0 = vec0.as_ptr().cast::<u8>();
                let len0 = vec0.len();
                *base.add(4).cast::<usize>() = len0;
                *base.add(0).cast::<*mut u8>() = ptr0.cast_mut();
              }
            }
            let (result4_0,result4_1,result4_2,) = match passphrase {
              Some(e) => {
                let vec3 = e;
                let len3 = vec3.len();
                let layout3 = _rt::alloc::Layout::from_size_align_unchecked(vec3.len() * 8, 4);
                let result3 = if layout3.size() != 0 {
                  let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
                  if ptr.is_null()
                  {
                    _rt::alloc::handle_alloc_error(layout3);
                  }
                  ptr
                }else {{
                  ::core::ptr::null_mut()
                }};
                for (i, e) in vec3.into_iter().enumerate() {
                  let base = result3.add(i * 8);
                  {
                    let vec2 = e;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    *base.add(4).cast::<usize>() = len2;
                    *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                  }
                }
                cleanup_list.extend_from_slice(&[(result3, layout3),]);

                (1i32, result3, len3)
              },
              None => {
                (0i32, ::core::ptr::null_mut(), 0usize)
              },
            };
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:crypto/api")]
            extern "C" {
              #[link_name = "[constructor]bip32-ed25519"]
              fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32{ unreachable!() }
            let ret = wit_import(result1, len1, result4_0, result4_1, result4_2);
            if layout1.size() != 0 {
              _rt::alloc::dealloc(result1.cast(), layout1);
            }
            for (ptr, layout) in cleanup_list {

              if layout.size() != 0 {

                _rt::alloc::dealloc(ptr.cast(), layout);

              }

            }
            Bip32Ed25519::from_handle(ret as u32)
          }
        }
      }
      impl Bip32Ed25519 {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the public key for this private key.
        pub fn public_key(&self,) -> Bip32Ed25519PublicKey{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 32]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:crypto/api")]
            extern "C" {
              #[link_name = "[method]bip32-ed25519.public-key"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = *ptr0.add(0).cast::<i64>();
            let l2 = *ptr0.add(8).cast::<i64>();
            let l3 = *ptr0.add(16).cast::<i64>();
            let l4 = *ptr0.add(24).cast::<i64>();
            (l1 as u64, l2 as u64, l3 as u64, l4 as u64)
          }
        }
      }
      impl Bip32Ed25519 {
        #[allow(unused_unsafe, clippy::all)]
        /// Sign data with the Private key, and return it.
        ///
        /// **Parameters**
        ///
        /// - `data` : The data to sign.
        pub fn sign_data(&self,data: &Bstr,) -> Bip32Ed25519Signature{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 64]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 64]);
            let vec0 = data;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:crypto/api")]
            extern "C" {
              #[link_name = "[method]bip32-ed25519.sign-data"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l2 = *ptr1.add(0).cast::<i64>();
            let l3 = *ptr1.add(8).cast::<i64>();
            let l4 = *ptr1.add(16).cast::<i64>();
            let l5 = *ptr1.add(24).cast::<i64>();
            let l6 = *ptr1.add(32).cast::<i64>();
            let l7 = *ptr1.add(40).cast::<i64>();
            let l8 = *ptr1.add(48).cast::<i64>();
            let l9 = *ptr1.add(56).cast::<i64>();
            (l2 as u64, l3 as u64, l4 as u64, l5 as u64, l6 as u64, l7 as u64, l8 as u64, l9 as u64)
          }
        }
      }
      impl Bip32Ed25519 {
        #[allow(unused_unsafe, clippy::all)]
        /// Check a signature on a set of data.
        ///
        /// **Parameters**
        ///
        /// - `data` : The data to check.
        /// - `sig`  : The signature to check.
        ///
        /// **Returns**
        ///
        /// - `true` : Signature checked OK.
        /// - `false` : Signature check failed.
        pub fn check_sig(&self,data: &Bstr,sig: Bip32Ed25519Signature,) -> bool{
          unsafe {
            let vec0 = data;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let (t1_0, t1_1, t1_2, t1_3, t1_4, t1_5, t1_6, t1_7, ) = sig;

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:crypto/api")]
            extern "C" {
              #[link_name = "[method]bip32-ed25519.check-sig"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, ptr0.cast_mut(), len0, _rt::as_i64(t1_0), _rt::as_i64(t1_1), _rt::as_i64(t1_2), _rt::as_i64(t1_3), _rt::as_i64(t1_4), _rt::as_i64(t1_5), _rt::as_i64(t1_6), _rt::as_i64(t1_7));
            _rt::bool_lift(ret as u8)
          }
        }
      }
      impl Bip32Ed25519 {
        #[allow(unused_unsafe, clippy::all)]
        /// Derive a new private key from the current private key.
        ///
        /// **Parameters**
        ///
        /// - `path` : Derivation path.
        ///
        /// Note: uses BIP32 HD key derivation.
        pub fn derive(&self,path: &Path,) -> Bip32Ed25519{
          unsafe {
            let vec0 = path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:crypto/api")]
            extern "C" {
              #[link_name = "[method]bip32-ed25519.derive"]
              fn wit_import(_: i32, _: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, ptr0.cast_mut(), len0);
            Bip32Ed25519::from_handle(ret as u32)
          }
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod hash {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Bstr = super::super::super::hermes::binary::api::Bstr;
      /// Errors that can occur during hashing.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum Errno {
        KeyTooBig,
        /// The key exceeds the supported size of the hash function.
        HashTooBig,
        /// The hash size requested is larger than supported by the hash function.
        SaltTooBig,
        /// The salt exceeds the supported size of the hash function.
        PersonalTooBig,
        /// The personal exceeds the supported size of the hash function.
        InvalidDigestByteLength,
      }
      impl Errno{
        pub fn name(&self) -> &'static str {
          match self {
            Errno::KeyTooBig => "key-too-big",
            Errno::HashTooBig => "hash-too-big",
            Errno::SaltTooBig => "salt-too-big",
            Errno::PersonalTooBig => "personal-too-big",
            Errno::InvalidDigestByteLength => "invalid-digest-byte-length",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            Errno::KeyTooBig => "",
            Errno::HashTooBig => "The key exceeds the supported size of the hash function.",
            Errno::SaltTooBig => "The hash size requested is larger than supported by the hash function.",
            Errno::PersonalTooBig => "The salt exceeds the supported size of the hash function.",
            Errno::InvalidDigestByteLength => "The personal exceeds the supported size of the hash function.",
          }
        }
      }
      impl ::core::fmt::Debug for Errno{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Errno")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for Errno{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl std::error::Error for Errno {}

      impl Errno{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> Errno{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => Errno::KeyTooBig,
            1 => Errno::HashTooBig,
            2 => Errno::SaltTooBig,
            3 => Errno::PersonalTooBig,
            4 => Errno::InvalidDigestByteLength,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[allow(unused_unsafe, clippy::all)]
      /// # BLAKE2s Hash Function
      ///
      /// Hash a binary buffer with BLAKE2s.
      ///
      /// ## Parameters
      ///
      /// - `buf`: The binary data buffer to hash.
      /// - `outlen`: Optional.  The size of the digest.
      /// If the outlen is not defined, it defaults to 32.
      ///
      /// ## Returns
      ///
      /// - Either a buffer the size requested, with the hash.
      /// - Or an error:
      /// - `hash_too_big` if `outlen` is specified and is > 32 bytes.
      /// - `invalid_digest_byte_length` if `outlen` is specified and is = 0.
      pub fn blake2s(buf: &Bstr,outlen: Option<u8>,) -> Result<Bstr,Errno>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let vec0 = buf;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let (result1_0,result1_1,) = match outlen {
            Some(e) => (1i32, _rt::as_i32(e)),
            None => {
              (0i32, 0i32)
            },
          };let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:hash/api")]
          extern "C" {
            #[link_name = "blake2s"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result1_0, result1_1, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = {
                let l4 = *ptr2.add(4).cast::<*mut u8>();
                let l5 = *ptr2.add(8).cast::<usize>();
                let len6 = l5;

                _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = i32::from(*ptr2.add(4).cast::<u8>());

                Errno::_lift(l7 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// # BLAKE2sMac Hash Function
      ///
      /// Hash a binary buffer with BLAKE2s with MAC (Message Authentication Code) mode.
      ///
      /// ## Parameters
      ///
      /// - `buf`: The binary data buffer to hash.
      /// - `outlen`: Optional.  The size of the digest.
      /// If the outlen is not defined, it defaults to 32.
      /// - `key`: The key to use with the hash.
      /// With MAC mode, key is needed to be defined
      /// Should not be > 32 bytes.
      /// - `salt`: Optional. Salt uses to increase the randomness and
      /// uniqueness of the hash output
      /// Should not be > 8 bytes.
      /// If not defined, salt is not used.
      /// - `personal`: Optional. Personal allows to
      /// add customization to the hash function behavior.
      /// Should not be > 8 bytes.
      /// If not defined, personal is not used.
      ///
      /// ## Returns
      ///
      /// - Either a buffer the size requested, with the hash.
      /// - Or an error:
      /// - `key_too_big` if `key` is > 32 bytes.
      /// - `hash_too_big` if `outlen` is specified and is > 32 bytes.
      /// - `salt_too_big` if `salt` is specified and is > 8 bytes.
      /// - `personal_too_big` if `personal` is specified and is > 8 bytes.
      ///
      /// ## Note:
      ///
      /// `key` length is checked before `outlen` so if both sizes are invalid, only
      /// `key_too_big` will be returned.
      /// If `salt` length exceeds 8 bytes, `salt_too_big` will be returned.
      /// if `personal` length exceeds 8 bytes, `personal_too_big` will be returned.
      pub fn blake2smac(buf: &Bstr,outlen: Option<u8>,key: &Bstr,salt: Option<&Bstr>,personal: Option<&Bstr>,) -> Result<Bstr,Errno>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let vec0 = buf;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let (result1_0,result1_1,) = match outlen {
            Some(e) => (1i32, _rt::as_i32(e)),
            None => {
              (0i32, 0i32)
            },
          };let vec2 = key;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          let (result4_0,result4_1,result4_2,) = match salt {
            Some(e) => {
              let vec3 = e;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();

              (1i32, ptr3.cast_mut(), len3)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let (result6_0,result6_1,result6_2,) = match personal {
            Some(e) => {
              let vec5 = e;
              let ptr5 = vec5.as_ptr().cast::<u8>();
              let len5 = vec5.len();

              (1i32, ptr5.cast_mut(), len5)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:hash/api")]
          extern "C" {
            #[link_name = "blake2smac"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result1_0, result1_1, ptr2.cast_mut(), len2, result4_0, result4_1, result4_2, result6_0, result6_1, result6_2, ptr7);
          let l8 = i32::from(*ptr7.add(0).cast::<u8>());
          match l8 {
            0 => {
              let e = {
                let l9 = *ptr7.add(4).cast::<*mut u8>();
                let l10 = *ptr7.add(8).cast::<usize>();
                let len11 = l10;

                _rt::Vec::from_raw_parts(l9.cast(), len11, len11)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l12 = i32::from(*ptr7.add(4).cast::<u8>());

                Errno::_lift(l12 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// # BLAKE2b Hash Function
      ///
      /// Hash a binary buffer with BLAKE2b.
      ///
      /// ## Parameters
      ///
      /// - `buf`: The binary data buffer to hash.
      /// - `outlen`: Optional. The size of the digest.
      /// If the outlen is not defined, it defaults to 64.
      ///
      /// ## Returns
      ///
      /// - Either a buffer the size requested, with the hash.
      /// - Or an error:
      /// - `hash_too_big` if `outlen` is specified and is > 64 bytes.
      /// - `invalid_digest_byte_length` if `outlen` is specified and is = 0.
      pub fn blake2b(buf: &Bstr,outlen: Option<u8>,) -> Result<Bstr,Errno>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let vec0 = buf;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let (result1_0,result1_1,) = match outlen {
            Some(e) => (1i32, _rt::as_i32(e)),
            None => {
              (0i32, 0i32)
            },
          };let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:hash/api")]
          extern "C" {
            #[link_name = "blake2b"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result1_0, result1_1, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = {
                let l4 = *ptr2.add(4).cast::<*mut u8>();
                let l5 = *ptr2.add(8).cast::<usize>();
                let len6 = l5;

                _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = i32::from(*ptr2.add(4).cast::<u8>());

                Errno::_lift(l7 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// # BLAKE2bMac Hash Function
      ///
      /// Hash a binary buffer with BLAKE2b with MAC (Message Authentication Code) mode.
      ///
      /// ## Parameters
      ///
      /// - `buf`: The binary data buffer to hash.
      /// - `outlen`: Optional.  The size of the digest.
      /// If the outlen is not defined, it defaults to 64.
      /// - `key`: The key to use with the hash.
      /// With MAC mode, key is needed to be defined
      /// Should not be > 64 bytes.
      /// - `salt`: Optional. Salt uses to increase the randomness and
      /// uniqueness of the hash output
      /// Should not be > 16 bytes.
      /// If not defined, salt is not used.
      /// - `personal`: Optional. Personal allows to
      /// add customization to the hash function behavior.
      /// Should not be > 16 bytes.
      /// If not defined, personal is not used.
      ///
      /// ## Returns
      ///
      /// - Either a buffer the size requested, with the hash.
      /// - Or an error:
      /// - `key_too_big` if `key` is specified and is > 64 bytes.
      /// - `hash_too_big` if `outlen` is specified and is > 64 bytes.
      /// - `salt_too_big` if `salt` is specified and is > 16 bytes.
      /// - `personal_too_big` if `personal` is specified and is > 16 bytes.
      ///
      /// ## Note:
      ///
      /// `key` length is checked before `outlen` so if both sizes are invalid, only
      /// `key_too_big` will be returned.
      /// If `salt` length exceeds 16 bytes, `salt_too_big` will be returned.
      /// if `personal` length exceeds 16 bytes, `personal_too_big` will be returned.
      pub fn blake2bmac(buf: &Bstr,outlen: Option<u8>,key: &Bstr,salt: Option<&Bstr>,personal: Option<&Bstr>,) -> Result<Bstr,Errno>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let vec0 = buf;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let (result1_0,result1_1,) = match outlen {
            Some(e) => (1i32, _rt::as_i32(e)),
            None => {
              (0i32, 0i32)
            },
          };let vec2 = key;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          let (result4_0,result4_1,result4_2,) = match salt {
            Some(e) => {
              let vec3 = e;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();

              (1i32, ptr3.cast_mut(), len3)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let (result6_0,result6_1,result6_2,) = match personal {
            Some(e) => {
              let vec5 = e;
              let ptr5 = vec5.as_ptr().cast::<u8>();
              let len5 = vec5.len();

              (1i32, ptr5.cast_mut(), len5)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:hash/api")]
          extern "C" {
            #[link_name = "blake2bmac"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result1_0, result1_1, ptr2.cast_mut(), len2, result4_0, result4_1, result4_2, result6_0, result6_1, result6_2, ptr7);
          let l8 = i32::from(*ptr7.add(0).cast::<u8>());
          match l8 {
            0 => {
              let e = {
                let l9 = *ptr7.add(4).cast::<*mut u8>();
                let l10 = *ptr7.add(8).cast::<usize>();
                let len11 = l10;

                _rt::Vec::from_raw_parts(l9.cast(), len11, len11)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l12 = i32::from(*ptr7.add(4).cast::<u8>());

                Errno::_lift(l12 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// # BLAKE3 Hash Function
      ///
      /// Hash a binary buffer with BLAKE3.
      ///
      /// ## Parameters
      ///
      /// - `buf`: The binary data buffer to hash.
      /// - `outlen`: Optional.  The size of the digest.
      /// If the outlen is not defined, it defaults to 32.
      /// - `key`: Optional. The key to use with the hash.
      /// If not defined, the hash is not keyed.
      /// Should not be > 32 bytes.
      ///
      /// ## Returns
      ///
      /// - Either a buffer the size requested, with the hash.
      /// - Or an error:
      /// - `key_too_big` if `key` is specified and is > 32 bytes.
      /// - `hash_too_big` if `outlen` is specified and is > 32 bytes.
      ///
      /// ## Note:
      ///
      /// `key` length is checked before `outlen` so if both sizes are invalid, only
      /// `key_too_big` will be returned.
      pub fn blake3(buf: &Bstr,outlen: Option<u8>,key: Option<&Bstr>,) -> Result<Bstr,Errno>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let vec0 = buf;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let (result1_0,result1_1,) = match outlen {
            Some(e) => (1i32, _rt::as_i32(e)),
            None => {
              (0i32, 0i32)
            },
          };let (result3_0,result3_1,result3_2,) = match key {
            Some(e) => {
              let vec2 = e;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();

              (1i32, ptr2.cast_mut(), len2)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:hash/api")]
          extern "C" {
            #[link_name = "blake3"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result1_0, result1_1, result3_0, result3_1, result3_2, ptr4);
          let l5 = i32::from(*ptr4.add(0).cast::<u8>());
          match l5 {
            0 => {
              let e = {
                let l6 = *ptr4.add(4).cast::<*mut u8>();
                let l7 = *ptr4.add(8).cast::<usize>();
                let len8 = l7;

                _rt::Vec::from_raw_parts(l6.cast(), len8, len8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l9 = i32::from(*ptr4.add(4).cast::<u8>());

                Errno::_lift(l9 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod http_request {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      /// HTTP request payload (caller manages full body formatting)
      #[derive(Clone)]
      pub struct Payload {
        /// Host URI (scheme + domain, no path), e.g., "http://example.com"
        pub host_uri: _rt::String,
        /// Port (e.g., 80 for HTTP, 443 for HTTPS)
        pub port: u16,
        /// Raw HTTP request (including method, path, headers, and body)
        pub body: _rt::Vec::<u8>,
        /// Optional request identifier for tracking
        pub request_id: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for Payload {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Payload").field("host-uri", &self.host_uri).field("port", &self.port).field("body", &self.body).field("request-id", &self.request_id).finish()
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Send an HTTP request.
      pub fn send(p: &Payload,) -> bool{
        unsafe {
          let Payload{ host_uri:host_uri0, port:port0, body:body0, request_id:request_id0, } = p;
          let vec1 = host_uri0;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let vec2 = body0;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          let (result4_0,result4_1,result4_2,) = match request_id0 {
            Some(e) => {
              let vec3 = e;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();

              (1i32, ptr3.cast_mut(), len3)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:http-request/api")]
          extern "C" {
            #[link_name = "send"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32{ unreachable!() }
          let ret = wit_import(ptr1.cast_mut(), len1, _rt::as_i32(port0), ptr2.cast_mut(), len2, result4_0, result4_1, result4_2);
          _rt::bool_lift(ret as u8)
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod ipfs {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      /// A DHT key.
      pub type DhtKey = _rt::Vec::<u8>;
      /// A DHT value.
      pub type DhtValue = _rt::Vec::<u8>;
      /// The binary contents of an IPFS file.
      pub type IpfsFile = _rt::Vec::<u8>;
      /// A path to an IPFS file.
      pub type IpfsPath = _rt::String;
      /// PubSub Message Data
      pub type MessageData = _rt::Vec::<u8>;
      /// PubSub Message ID
      pub type MessageId = _rt::Vec::<u8>;
      /// The ID of a peer.
      pub type PeerId = _rt::String;
      /// A PubSub topic.
      pub type PubsubTopic = _rt::String;
      /// This is content that can be validated.
      #[derive(Clone)]
      pub enum IpfsContent {
        /// DHT value
        Dht((DhtKey,DhtValue,)),
        Pubsub((PubsubTopic,MessageData,)),
      }
      impl ::core::fmt::Debug for IpfsContent {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            IpfsContent::Dht(e) => {
              f.debug_tuple("IpfsContent::Dht").field(e).finish()
            }
            IpfsContent::Pubsub(e) => {
              f.debug_tuple("IpfsContent::Pubsub").field(e).finish()
            }
          }
        }
      }
      /// A PubSub message from a topic subscription.
      #[derive(Clone)]
      pub struct PubsubMessage {
        /// The topic that the message was received on.
        pub topic: PubsubTopic,
        /// The contents of the message.
        pub message: MessageData,
        /// Optional Peer ID that published the message.
        pub publisher: Option<PeerId>,
      }
      impl ::core::fmt::Debug for PubsubMessage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("PubsubMessage").field("topic", &self.topic).field("message", &self.message).field("publisher", &self.publisher).finish()
        }
      }
      /// Errors that occur in IPFS networking.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum Errno {
        /// Unable to get DHT value.
        DhtGetError,
        /// Unable to put DHT value.
        DhtPutError,
        /// Unable to publish file to IPFS.
        FileAddError,
        /// Unable to get file from IPFS.
        FileGetError,
        /// Unable to pin file.
        FilePinError,
        /// Invalid CID.
        InvalidCid,
        /// Invalid DHT key.
        InvalidDhtKey,
        /// Invalid DHT value.
        InvalidDhtValue,
        /// Unable to parse a valid IPFS path.
        InvalidIpfsPath,
        /// Invalid Peer ID.
        InvalidPeerId,
        /// Invalid PubSub message.
        InvalidPubsubMessage,
        /// Unable to evict peer.
        PeerEvictionError,
        /// Unable to publish to IPFS topic.
        PubsubPublishError,
        /// Unable to subscribe to IPFS topic.
        PubsubSubscribeError,
        /// IPFS service is unavailable.
        ServiceUnavailable,
      }
      impl Errno{
        pub fn name(&self) -> &'static str {
          match self {
            Errno::DhtGetError => "dht-get-error",
            Errno::DhtPutError => "dht-put-error",
            Errno::FileAddError => "file-add-error",
            Errno::FileGetError => "file-get-error",
            Errno::FilePinError => "file-pin-error",
            Errno::InvalidCid => "invalid-cid",
            Errno::InvalidDhtKey => "invalid-dht-key",
            Errno::InvalidDhtValue => "invalid-dht-value",
            Errno::InvalidIpfsPath => "invalid-ipfs-path",
            Errno::InvalidPeerId => "invalid-peer-id",
            Errno::InvalidPubsubMessage => "invalid-pubsub-message",
            Errno::PeerEvictionError => "peer-eviction-error",
            Errno::PubsubPublishError => "pubsub-publish-error",
            Errno::PubsubSubscribeError => "pubsub-subscribe-error",
            Errno::ServiceUnavailable => "service-unavailable",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            Errno::DhtGetError => "Unable to get DHT value.",
            Errno::DhtPutError => "Unable to put DHT value.",
            Errno::FileAddError => "Unable to publish file to IPFS.",
            Errno::FileGetError => "Unable to get file from IPFS.",
            Errno::FilePinError => "Unable to pin file.",
            Errno::InvalidCid => "Invalid CID.",
            Errno::InvalidDhtKey => "Invalid DHT key.",
            Errno::InvalidDhtValue => "Invalid DHT value.",
            Errno::InvalidIpfsPath => "Unable to parse a valid IPFS path.",
            Errno::InvalidPeerId => "Invalid Peer ID.",
            Errno::InvalidPubsubMessage => "Invalid PubSub message.",
            Errno::PeerEvictionError => "Unable to evict peer.",
            Errno::PubsubPublishError => "Unable to publish to IPFS topic.",
            Errno::PubsubSubscribeError => "Unable to subscribe to IPFS topic.",
            Errno::ServiceUnavailable => "IPFS service is unavailable.",
          }
        }
      }
      impl ::core::fmt::Debug for Errno{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Errno")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for Errno{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl std::error::Error for Errno {}

      impl Errno{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> Errno{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => Errno::DhtGetError,
            1 => Errno::DhtPutError,
            2 => Errno::FileAddError,
            3 => Errno::FileGetError,
            4 => Errno::FilePinError,
            5 => Errno::InvalidCid,
            6 => Errno::InvalidDhtKey,
            7 => Errno::InvalidDhtValue,
            8 => Errno::InvalidIpfsPath,
            9 => Errno::InvalidPeerId,
            10 => Errno::InvalidPubsubMessage,
            11 => Errno::PeerEvictionError,
            12 => Errno::PubsubPublishError,
            13 => Errno::PubsubSubscribeError,
            14 => Errno::ServiceUnavailable,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[allow(unused_unsafe, clippy::all)]
      /// Puts a DHT key-value into IPFS.
      pub fn dht_put(key: &DhtKey,value: &DhtValue,) -> Result<bool,Errno>{
        unsafe {
          #[repr(align(1))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = value;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:ipfs/api")]
          extern "C" {
            #[link_name = "dht-put"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = {
                let l4 = i32::from(*ptr2.add(1).cast::<u8>());

                _rt::bool_lift(l4 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = i32::from(*ptr2.add(1).cast::<u8>());

                Errno::_lift(l5 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Gets a DHT key-value from IPFS.
      pub fn dht_get(key: &DhtKey,) -> Result<DhtValue,Errno>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:ipfs/api")]
          extern "C" {
            #[link_name = "dht-get"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = {
                let l3 = *ptr1.add(4).cast::<*mut u8>();
                let l4 = *ptr1.add(8).cast::<usize>();
                let len5 = l4;

                _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = i32::from(*ptr1.add(4).cast::<u8>());

                Errno::_lift(l6 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Validates IPFS content from DHT or PubSub.
      pub fn ipfs_content_validate(content: &IpfsContent,) -> Result<bool,Errno>{
        unsafe {
          #[repr(align(1))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
          let (result6_0,result6_1,result6_2,result6_3,result6_4,) = match content {
            IpfsContent::Dht(e) => {
              let (t0_0, t0_1, ) = e;
              let vec1 = t0_0;
              let ptr1 = vec1.as_ptr().cast::<u8>();
              let len1 = vec1.len();
              let vec2 = t0_1;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();

              (0i32, ptr1.cast_mut(), len1, ptr2.cast_mut(), len2)
            },
            IpfsContent::Pubsub(e) => {
              let (t3_0, t3_1, ) = e;
              let vec4 = t3_0;
              let ptr4 = vec4.as_ptr().cast::<u8>();
              let len4 = vec4.len();
              let vec5 = t3_1;
              let ptr5 = vec5.as_ptr().cast::<u8>();
              let len5 = vec5.len();

              (1i32, ptr4.cast_mut(), len4, ptr5.cast_mut(), len5)
            },
          };
          let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:ipfs/api")]
          extern "C" {
            #[link_name = "ipfs-content-validate"]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(result6_0, result6_1, result6_2, result6_3, result6_4, ptr7);
          let l8 = i32::from(*ptr7.add(0).cast::<u8>());
          match l8 {
            0 => {
              let e = {
                let l9 = i32::from(*ptr7.add(1).cast::<u8>());

                _rt::bool_lift(l9 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l10 = i32::from(*ptr7.add(1).cast::<u8>());

                Errno::_lift(l10 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Uploads a file to IPFS.
      pub fn file_add(contents: &IpfsFile,) -> Result<IpfsPath,Errno>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let vec0 = contents;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:ipfs/api")]
          extern "C" {
            #[link_name = "file-add"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = {
                let l3 = *ptr1.add(4).cast::<*mut u8>();
                let l4 = *ptr1.add(8).cast::<usize>();
                let len5 = l4;
                let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

                _rt::string_lift(bytes5)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = i32::from(*ptr1.add(4).cast::<u8>());

                Errno::_lift(l6 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Retrieves a file from IPFS.
      pub fn file_get(path: &IpfsPath,) -> Result<IpfsFile,Errno>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let vec0 = path;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:ipfs/api")]
          extern "C" {
            #[link_name = "file-get"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = {
                let l3 = *ptr1.add(4).cast::<*mut u8>();
                let l4 = *ptr1.add(8).cast::<usize>();
                let len5 = l4;

                _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = i32::from(*ptr1.add(4).cast::<u8>());

                Errno::_lift(l6 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Pins an IPFS file by path.
      pub fn file_pin(path: &IpfsPath,) -> Result<bool,Errno>{
        unsafe {
          #[repr(align(1))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
          let vec0 = path;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:ipfs/api")]
          extern "C" {
            #[link_name = "file-pin"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = {
                let l3 = i32::from(*ptr1.add(1).cast::<u8>());

                _rt::bool_lift(l3 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = i32::from(*ptr1.add(1).cast::<u8>());

                Errno::_lift(l4 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Un-pins an IPFS file by path.
      pub fn file_unpin(path: &IpfsPath,) -> Result<bool,Errno>{
        unsafe {
          #[repr(align(1))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
          let vec0 = path;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:ipfs/api")]
          extern "C" {
            #[link_name = "file-unpin"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = {
                let l3 = i32::from(*ptr1.add(1).cast::<u8>());

                _rt::bool_lift(l3 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = i32::from(*ptr1.add(1).cast::<u8>());

                Errno::_lift(l4 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Evict peer from network.
      pub fn peer_evict(peer: &PeerId,) -> Result<bool,Errno>{
        unsafe {
          #[repr(align(1))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
          let vec0 = peer;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:ipfs/api")]
          extern "C" {
            #[link_name = "peer-evict"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = {
                let l3 = i32::from(*ptr1.add(1).cast::<u8>());

                _rt::bool_lift(l3 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = i32::from(*ptr1.add(1).cast::<u8>());

                Errno::_lift(l4 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Publish a message to a topic.
      pub fn pubsub_publish(topic: &PubsubTopic,message: &MessageData,) -> Result<MessageId,Errno>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let vec0 = topic;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = message;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:ipfs/api")]
          extern "C" {
            #[link_name = "pubsub-publish"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = {
                let l4 = *ptr2.add(4).cast::<*mut u8>();
                let l5 = *ptr2.add(8).cast::<usize>();
                let len6 = l5;

                _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = i32::from(*ptr2.add(4).cast::<u8>());

                Errno::_lift(l7 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Subscribes to a PubSub topic.
      pub fn pubsub_subscribe(topic: &PubsubTopic,) -> Result<bool,Errno>{
        unsafe {
          #[repr(align(1))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
          let vec0 = topic;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:ipfs/api")]
          extern "C" {
            #[link_name = "pubsub-subscribe"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = {
                let l3 = i32::from(*ptr1.add(1).cast::<u8>());

                _rt::bool_lift(l3 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = i32::from(*ptr1.add(1).cast::<u8>());

                Errno::_lift(l4 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod json {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      /// JSON is just a string.
      /// This type is used to indicate the string MUST be properly formatted JSON.
      pub type Json = _rt::String;

    }

  }
  #[allow(dead_code)]
  pub mod kv_store {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Bstr = super::super::super::hermes::binary::api::Bstr;
      pub type Cbor = super::super::super::hermes::cbor::api::Cbor;
      pub type Json = super::super::super::hermes::json::api::Json;
      /// A time and date in seconds plus nanoseconds.
      #[derive(Clone)]
      pub enum KvValues {
        KvString(_rt::String),
        /// A String
        KvS64(i64),
        /// Just use the largest signed integer type supported
        KvU64(u64),
        /// Just use the largest integer type supported
        KvF64(f64),
        /// Just use the largest float type supported
        KvBstr(Bstr),
        /// A byte string
        KvCbor(Cbor),
        /// CBOR data
        KvJson(Json),
      }
      impl ::core::fmt::Debug for KvValues {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            KvValues::KvString(e) => {
              f.debug_tuple("KvValues::KvString").field(e).finish()
            }
            KvValues::KvS64(e) => {
              f.debug_tuple("KvValues::KvS64").field(e).finish()
            }
            KvValues::KvU64(e) => {
              f.debug_tuple("KvValues::KvU64").field(e).finish()
            }
            KvValues::KvF64(e) => {
              f.debug_tuple("KvValues::KvF64").field(e).finish()
            }
            KvValues::KvBstr(e) => {
              f.debug_tuple("KvValues::KvBstr").field(e).finish()
            }
            KvValues::KvCbor(e) => {
              f.debug_tuple("KvValues::KvCbor").field(e).finish()
            }
            KvValues::KvJson(e) => {
              f.debug_tuple("KvValues::KvJson").field(e).finish()
            }
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Set a value in the local key-value store
      /// Setting None will cause the Key to be deleted from the KV store.
      pub fn kv_set(key: &str,value: Option<&KvValues>,){
        unsafe {
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let (result6_0,result6_1,result6_2,result6_3,) = match value {
            Some(e) => {
              let (result5_0,result5_1,result5_2,) = match e {
                KvValues::KvString(e) => {
                  let vec1 = e;
                  let ptr1 = vec1.as_ptr().cast::<u8>();
                  let len1 = vec1.len();

                  (0i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr1.cast_mut());
                    t
                  }, len1)
                },
                KvValues::KvS64(e) => (1i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvU64(e) => (2i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvF64(e) => (3i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0usize),
                KvValues::KvBstr(e) => {
                  let vec2 = e;
                  let ptr2 = vec2.as_ptr().cast::<u8>();
                  let len2 = vec2.len();

                  (4i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr2.cast_mut());
                    t
                  }, len2)
                },
                KvValues::KvCbor(e) => {
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();

                  (5i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr3.cast_mut());
                    t
                  }, len3)
                },
                KvValues::KvJson(e) => {
                  let vec4 = e;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();

                  (6i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr4.cast_mut());
                    t
                  }, len4)
                },
              };

              (1i32, result5_0, result5_1, result5_2)
            },
            None => {
              (0i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0usize)
            },
          };
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:kv-store/api")]
          extern "C" {
            #[link_name = "kv-set"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result6_0, result6_1, result6_2, result6_3);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get a value from the local key-value store
      /// Returns the default if not set.
      pub fn kv_get_default(key: &str,default: Option<&KvValues>,) -> Option<KvValues>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let (result6_0,result6_1,result6_2,result6_3,) = match default {
            Some(e) => {
              let (result5_0,result5_1,result5_2,) = match e {
                KvValues::KvString(e) => {
                  let vec1 = e;
                  let ptr1 = vec1.as_ptr().cast::<u8>();
                  let len1 = vec1.len();

                  (0i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr1.cast_mut());
                    t
                  }, len1)
                },
                KvValues::KvS64(e) => (1i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvU64(e) => (2i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvF64(e) => (3i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0usize),
                KvValues::KvBstr(e) => {
                  let vec2 = e;
                  let ptr2 = vec2.as_ptr().cast::<u8>();
                  let len2 = vec2.len();

                  (4i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr2.cast_mut());
                    t
                  }, len2)
                },
                KvValues::KvCbor(e) => {
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();

                  (5i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr3.cast_mut());
                    t
                  }, len3)
                },
                KvValues::KvJson(e) => {
                  let vec4 = e;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();

                  (6i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr4.cast_mut());
                    t
                  }, len4)
                },
              };

              (1i32, result5_0, result5_1, result5_2)
            },
            None => {
              (0i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0usize)
            },
          };let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:kv-store/api")]
          extern "C" {
            #[link_name = "kv-get-default"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result6_0, result6_1, result6_2, result6_3, ptr7);
          let l8 = i32::from(*ptr7.add(0).cast::<u8>());
          match l8 {
            0 => None,
            1 => {
              let e = {
                let l9 = i32::from(*ptr7.add(8).cast::<u8>());
                let v25 = match l9 {
                  0 => {
                    let e25 = {
                      let l10 = *ptr7.add(16).cast::<*mut u8>();
                      let l11 = *ptr7.add(20).cast::<usize>();
                      let len12 = l11;
                      let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                      _rt::string_lift(bytes12)
                    };
                    KvValues::KvString(e25)
                  }
                  1 => {
                    let e25 = {
                      let l13 = *ptr7.add(16).cast::<i64>();

                      l13
                    };
                    KvValues::KvS64(e25)
                  }
                  2 => {
                    let e25 = {
                      let l14 = *ptr7.add(16).cast::<i64>();

                      l14 as u64
                    };
                    KvValues::KvU64(e25)
                  }
                  3 => {
                    let e25 = {
                      let l15 = *ptr7.add(16).cast::<f64>();

                      l15
                    };
                    KvValues::KvF64(e25)
                  }
                  4 => {
                    let e25 = {
                      let l16 = *ptr7.add(16).cast::<*mut u8>();
                      let l17 = *ptr7.add(20).cast::<usize>();
                      let len18 = l17;

                      _rt::Vec::from_raw_parts(l16.cast(), len18, len18)
                    };
                    KvValues::KvBstr(e25)
                  }
                  5 => {
                    let e25 = {
                      let l19 = *ptr7.add(16).cast::<*mut u8>();
                      let l20 = *ptr7.add(20).cast::<usize>();
                      let len21 = l20;

                      _rt::Vec::from_raw_parts(l19.cast(), len21, len21)
                    };
                    KvValues::KvCbor(e25)
                  }
                  n => {
                    debug_assert_eq!(n, 6, "invalid enum discriminant");
                    let e25 = {
                      let l22 = *ptr7.add(16).cast::<*mut u8>();
                      let l23 = *ptr7.add(20).cast::<usize>();
                      let len24 = l23;
                      let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);

                      _rt::string_lift(bytes24)
                    };
                    KvValues::KvJson(e25)
                  }
                };

                v25
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get a value from the local key-value store
      /// Returns None if the Key does not exist in the KV Store.
      /// This is a convenience function, and is equivalent to `kv-get-default(key, none)`
      pub fn kv_get(key: &str,) -> Option<KvValues>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:kv-store/api")]
          extern "C" {
            #[link_name = "kv-get"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => None,
            1 => {
              let e = {
                let l3 = i32::from(*ptr1.add(8).cast::<u8>());
                let v19 = match l3 {
                  0 => {
                    let e19 = {
                      let l4 = *ptr1.add(16).cast::<*mut u8>();
                      let l5 = *ptr1.add(20).cast::<usize>();
                      let len6 = l5;
                      let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                      _rt::string_lift(bytes6)
                    };
                    KvValues::KvString(e19)
                  }
                  1 => {
                    let e19 = {
                      let l7 = *ptr1.add(16).cast::<i64>();

                      l7
                    };
                    KvValues::KvS64(e19)
                  }
                  2 => {
                    let e19 = {
                      let l8 = *ptr1.add(16).cast::<i64>();

                      l8 as u64
                    };
                    KvValues::KvU64(e19)
                  }
                  3 => {
                    let e19 = {
                      let l9 = *ptr1.add(16).cast::<f64>();

                      l9
                    };
                    KvValues::KvF64(e19)
                  }
                  4 => {
                    let e19 = {
                      let l10 = *ptr1.add(16).cast::<*mut u8>();
                      let l11 = *ptr1.add(20).cast::<usize>();
                      let len12 = l11;

                      _rt::Vec::from_raw_parts(l10.cast(), len12, len12)
                    };
                    KvValues::KvBstr(e19)
                  }
                  5 => {
                    let e19 = {
                      let l13 = *ptr1.add(16).cast::<*mut u8>();
                      let l14 = *ptr1.add(20).cast::<usize>();
                      let len15 = l14;

                      _rt::Vec::from_raw_parts(l13.cast(), len15, len15)
                    };
                    KvValues::KvCbor(e19)
                  }
                  n => {
                    debug_assert_eq!(n, 6, "invalid enum discriminant");
                    let e19 = {
                      let l16 = *ptr1.add(16).cast::<*mut u8>();
                      let l17 = *ptr1.add(20).cast::<usize>();
                      let len18 = l17;
                      let bytes18 = _rt::Vec::from_raw_parts(l16.cast(), len18, len18);

                      _rt::string_lift(bytes18)
                    };
                    KvValues::KvJson(e19)
                  }
                };

                v19
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get a value, and then set it (Atomic)
      /// Setting None will cause the Key to be deleted from the KV store.
      pub fn kv_get_set(key: &str,value: Option<&KvValues>,) -> Option<KvValues>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let (result6_0,result6_1,result6_2,result6_3,) = match value {
            Some(e) => {
              let (result5_0,result5_1,result5_2,) = match e {
                KvValues::KvString(e) => {
                  let vec1 = e;
                  let ptr1 = vec1.as_ptr().cast::<u8>();
                  let len1 = vec1.len();

                  (0i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr1.cast_mut());
                    t
                  }, len1)
                },
                KvValues::KvS64(e) => (1i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvU64(e) => (2i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvF64(e) => (3i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0usize),
                KvValues::KvBstr(e) => {
                  let vec2 = e;
                  let ptr2 = vec2.as_ptr().cast::<u8>();
                  let len2 = vec2.len();

                  (4i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr2.cast_mut());
                    t
                  }, len2)
                },
                KvValues::KvCbor(e) => {
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();

                  (5i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr3.cast_mut());
                    t
                  }, len3)
                },
                KvValues::KvJson(e) => {
                  let vec4 = e;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();

                  (6i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr4.cast_mut());
                    t
                  }, len4)
                },
              };

              (1i32, result5_0, result5_1, result5_2)
            },
            None => {
              (0i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0usize)
            },
          };let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:kv-store/api")]
          extern "C" {
            #[link_name = "kv-get-set"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result6_0, result6_1, result6_2, result6_3, ptr7);
          let l8 = i32::from(*ptr7.add(0).cast::<u8>());
          match l8 {
            0 => None,
            1 => {
              let e = {
                let l9 = i32::from(*ptr7.add(8).cast::<u8>());
                let v25 = match l9 {
                  0 => {
                    let e25 = {
                      let l10 = *ptr7.add(16).cast::<*mut u8>();
                      let l11 = *ptr7.add(20).cast::<usize>();
                      let len12 = l11;
                      let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                      _rt::string_lift(bytes12)
                    };
                    KvValues::KvString(e25)
                  }
                  1 => {
                    let e25 = {
                      let l13 = *ptr7.add(16).cast::<i64>();

                      l13
                    };
                    KvValues::KvS64(e25)
                  }
                  2 => {
                    let e25 = {
                      let l14 = *ptr7.add(16).cast::<i64>();

                      l14 as u64
                    };
                    KvValues::KvU64(e25)
                  }
                  3 => {
                    let e25 = {
                      let l15 = *ptr7.add(16).cast::<f64>();

                      l15
                    };
                    KvValues::KvF64(e25)
                  }
                  4 => {
                    let e25 = {
                      let l16 = *ptr7.add(16).cast::<*mut u8>();
                      let l17 = *ptr7.add(20).cast::<usize>();
                      let len18 = l17;

                      _rt::Vec::from_raw_parts(l16.cast(), len18, len18)
                    };
                    KvValues::KvBstr(e25)
                  }
                  5 => {
                    let e25 = {
                      let l19 = *ptr7.add(16).cast::<*mut u8>();
                      let l20 = *ptr7.add(20).cast::<usize>();
                      let len21 = l20;

                      _rt::Vec::from_raw_parts(l19.cast(), len21, len21)
                    };
                    KvValues::KvCbor(e25)
                  }
                  n => {
                    debug_assert_eq!(n, 6, "invalid enum discriminant");
                    let e25 = {
                      let l22 = *ptr7.add(16).cast::<*mut u8>();
                      let l23 = *ptr7.add(20).cast::<usize>();
                      let len24 = l23;
                      let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);

                      _rt::string_lift(bytes24)
                    };
                    KvValues::KvJson(e25)
                  }
                };

                v25
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get a value, and then add to it (Atomic)
      /// Adding to a string will concatenate the string.
      /// String concatenation will only occur up to the maximum possible size of a string value.\
      /// Concatenation beyond the maximum size will result in truncation.
      /// Adding to a numeric will have the expected behavior (rounded to nearest if necessary).
      /// The original type does not change, so: `f64 + u64 = f64`.  `s64 + f64 = s64`
      /// If the value overflows or under-flows it will saturate at the limit.
      /// This behavior allows us to decrement values by using the signed version, so `u64(10) + s64(-5) = u64(5))`
      /// If a string is added to a numeric, nothing happens.
      /// If a numeric is added to a string, it is converted to a string first, and then concatenated
      /// Note: There will be no spaces added.  So "My string" + u32(77) = "My string77"
      pub fn kv_add(key: &str,value: Option<&KvValues>,) -> Option<KvValues>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let (result6_0,result6_1,result6_2,result6_3,) = match value {
            Some(e) => {
              let (result5_0,result5_1,result5_2,) = match e {
                KvValues::KvString(e) => {
                  let vec1 = e;
                  let ptr1 = vec1.as_ptr().cast::<u8>();
                  let len1 = vec1.len();

                  (0i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr1.cast_mut());
                    t
                  }, len1)
                },
                KvValues::KvS64(e) => (1i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvU64(e) => (2i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvF64(e) => (3i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0usize),
                KvValues::KvBstr(e) => {
                  let vec2 = e;
                  let ptr2 = vec2.as_ptr().cast::<u8>();
                  let len2 = vec2.len();

                  (4i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr2.cast_mut());
                    t
                  }, len2)
                },
                KvValues::KvCbor(e) => {
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();

                  (5i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr3.cast_mut());
                    t
                  }, len3)
                },
                KvValues::KvJson(e) => {
                  let vec4 = e;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();

                  (6i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr4.cast_mut());
                    t
                  }, len4)
                },
              };

              (1i32, result5_0, result5_1, result5_2)
            },
            None => {
              (0i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0usize)
            },
          };let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:kv-store/api")]
          extern "C" {
            #[link_name = "kv-add"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result6_0, result6_1, result6_2, result6_3, ptr7);
          let l8 = i32::from(*ptr7.add(0).cast::<u8>());
          match l8 {
            0 => None,
            1 => {
              let e = {
                let l9 = i32::from(*ptr7.add(8).cast::<u8>());
                let v25 = match l9 {
                  0 => {
                    let e25 = {
                      let l10 = *ptr7.add(16).cast::<*mut u8>();
                      let l11 = *ptr7.add(20).cast::<usize>();
                      let len12 = l11;
                      let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                      _rt::string_lift(bytes12)
                    };
                    KvValues::KvString(e25)
                  }
                  1 => {
                    let e25 = {
                      let l13 = *ptr7.add(16).cast::<i64>();

                      l13
                    };
                    KvValues::KvS64(e25)
                  }
                  2 => {
                    let e25 = {
                      let l14 = *ptr7.add(16).cast::<i64>();

                      l14 as u64
                    };
                    KvValues::KvU64(e25)
                  }
                  3 => {
                    let e25 = {
                      let l15 = *ptr7.add(16).cast::<f64>();

                      l15
                    };
                    KvValues::KvF64(e25)
                  }
                  4 => {
                    let e25 = {
                      let l16 = *ptr7.add(16).cast::<*mut u8>();
                      let l17 = *ptr7.add(20).cast::<usize>();
                      let len18 = l17;

                      _rt::Vec::from_raw_parts(l16.cast(), len18, len18)
                    };
                    KvValues::KvBstr(e25)
                  }
                  5 => {
                    let e25 = {
                      let l19 = *ptr7.add(16).cast::<*mut u8>();
                      let l20 = *ptr7.add(20).cast::<usize>();
                      let len21 = l20;

                      _rt::Vec::from_raw_parts(l19.cast(), len21, len21)
                    };
                    KvValues::KvCbor(e25)
                  }
                  n => {
                    debug_assert_eq!(n, 6, "invalid enum discriminant");
                    let e25 = {
                      let l22 = *ptr7.add(16).cast::<*mut u8>();
                      let l23 = *ptr7.add(20).cast::<usize>();
                      let len24 = l23;
                      let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);

                      _rt::string_lift(bytes24)
                    };
                    KvValues::KvJson(e25)
                  }
                };

                v25
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Check if the Key equals a test value (exact match) and if it does, store the new value.
      /// In all cases, the current value is returned.
      /// If the types are NOT the same, the comparison will fail, even if the values are equivalent.
      /// For example: `u64(7) != s64(7)`, `f64(-1) != s64(-1)`.
      pub fn kv_cas(key: &str,test: Option<&KvValues>,value: Option<&KvValues>,) -> Option<KvValues>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let (result6_0,result6_1,result6_2,result6_3,) = match test {
            Some(e) => {
              let (result5_0,result5_1,result5_2,) = match e {
                KvValues::KvString(e) => {
                  let vec1 = e;
                  let ptr1 = vec1.as_ptr().cast::<u8>();
                  let len1 = vec1.len();

                  (0i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr1.cast_mut());
                    t
                  }, len1)
                },
                KvValues::KvS64(e) => (1i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvU64(e) => (2i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvF64(e) => (3i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0usize),
                KvValues::KvBstr(e) => {
                  let vec2 = e;
                  let ptr2 = vec2.as_ptr().cast::<u8>();
                  let len2 = vec2.len();

                  (4i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr2.cast_mut());
                    t
                  }, len2)
                },
                KvValues::KvCbor(e) => {
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr().cast::<u8>();
                  let len3 = vec3.len();

                  (5i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr3.cast_mut());
                    t
                  }, len3)
                },
                KvValues::KvJson(e) => {
                  let vec4 = e;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();

                  (6i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr4.cast_mut());
                    t
                  }, len4)
                },
              };

              (1i32, result5_0, result5_1, result5_2)
            },
            None => {
              (0i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0usize)
            },
          };let (result12_0,result12_1,result12_2,result12_3,) = match value {
            Some(e) => {
              let (result11_0,result11_1,result11_2,) = match e {
                KvValues::KvString(e) => {
                  let vec7 = e;
                  let ptr7 = vec7.as_ptr().cast::<u8>();
                  let len7 = vec7.len();

                  (0i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr7.cast_mut());
                    t
                  }, len7)
                },
                KvValues::KvS64(e) => (1i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvU64(e) => (2i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
                KvValues::KvF64(e) => (3i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0usize),
                KvValues::KvBstr(e) => {
                  let vec8 = e;
                  let ptr8 = vec8.as_ptr().cast::<u8>();
                  let len8 = vec8.len();

                  (4i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr8.cast_mut());
                    t
                  }, len8)
                },
                KvValues::KvCbor(e) => {
                  let vec9 = e;
                  let ptr9 = vec9.as_ptr().cast::<u8>();
                  let len9 = vec9.len();

                  (5i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr9.cast_mut());
                    t
                  }, len9)
                },
                KvValues::KvJson(e) => {
                  let vec10 = e;
                  let ptr10 = vec10.as_ptr().cast::<u8>();
                  let len10 = vec10.len();

                  (6i32, {
                    let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                    t.as_mut_ptr().cast::<*mut u8>().write(ptr10.cast_mut());
                    t
                  }, len10)
                },
              };

              (1i32, result11_0, result11_1, result11_2)
            },
            None => {
              (0i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0usize)
            },
          };let ptr13 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:kv-store/api")]
          extern "C" {
            #[link_name = "kv-cas"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, result6_0, result6_1, result6_2, result6_3, result12_0, result12_1, result12_2, result12_3, ptr13);
          let l14 = i32::from(*ptr13.add(0).cast::<u8>());
          match l14 {
            0 => None,
            1 => {
              let e = {
                let l15 = i32::from(*ptr13.add(8).cast::<u8>());
                let v31 = match l15 {
                  0 => {
                    let e31 = {
                      let l16 = *ptr13.add(16).cast::<*mut u8>();
                      let l17 = *ptr13.add(20).cast::<usize>();
                      let len18 = l17;
                      let bytes18 = _rt::Vec::from_raw_parts(l16.cast(), len18, len18);

                      _rt::string_lift(bytes18)
                    };
                    KvValues::KvString(e31)
                  }
                  1 => {
                    let e31 = {
                      let l19 = *ptr13.add(16).cast::<i64>();

                      l19
                    };
                    KvValues::KvS64(e31)
                  }
                  2 => {
                    let e31 = {
                      let l20 = *ptr13.add(16).cast::<i64>();

                      l20 as u64
                    };
                    KvValues::KvU64(e31)
                  }
                  3 => {
                    let e31 = {
                      let l21 = *ptr13.add(16).cast::<f64>();

                      l21
                    };
                    KvValues::KvF64(e31)
                  }
                  4 => {
                    let e31 = {
                      let l22 = *ptr13.add(16).cast::<*mut u8>();
                      let l23 = *ptr13.add(20).cast::<usize>();
                      let len24 = l23;

                      _rt::Vec::from_raw_parts(l22.cast(), len24, len24)
                    };
                    KvValues::KvBstr(e31)
                  }
                  5 => {
                    let e31 = {
                      let l25 = *ptr13.add(16).cast::<*mut u8>();
                      let l26 = *ptr13.add(20).cast::<usize>();
                      let len27 = l26;

                      _rt::Vec::from_raw_parts(l25.cast(), len27, len27)
                    };
                    KvValues::KvCbor(e31)
                  }
                  n => {
                    debug_assert_eq!(n, 6, "invalid enum discriminant");
                    let e31 = {
                      let l28 = *ptr13.add(16).cast::<*mut u8>();
                      let l29 = *ptr13.add(20).cast::<usize>();
                      let len30 = l29;
                      let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);

                      _rt::string_lift(bytes30)
                    };
                    KvValues::KvJson(e31)
                  }
                };

                v31
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Subscribe to any updates made to a particular Key.
      /// After this call, this module will receive Key Update events when a key is written.
      /// It returns the current value of the Key and None if it is not set.
      pub fn kv_subscribe(key: &str,) -> Option<KvValues>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:kv-store/api")]
          extern "C" {
            #[link_name = "kv-subscribe"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => None,
            1 => {
              let e = {
                let l3 = i32::from(*ptr1.add(8).cast::<u8>());
                let v19 = match l3 {
                  0 => {
                    let e19 = {
                      let l4 = *ptr1.add(16).cast::<*mut u8>();
                      let l5 = *ptr1.add(20).cast::<usize>();
                      let len6 = l5;
                      let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                      _rt::string_lift(bytes6)
                    };
                    KvValues::KvString(e19)
                  }
                  1 => {
                    let e19 = {
                      let l7 = *ptr1.add(16).cast::<i64>();

                      l7
                    };
                    KvValues::KvS64(e19)
                  }
                  2 => {
                    let e19 = {
                      let l8 = *ptr1.add(16).cast::<i64>();

                      l8 as u64
                    };
                    KvValues::KvU64(e19)
                  }
                  3 => {
                    let e19 = {
                      let l9 = *ptr1.add(16).cast::<f64>();

                      l9
                    };
                    KvValues::KvF64(e19)
                  }
                  4 => {
                    let e19 = {
                      let l10 = *ptr1.add(16).cast::<*mut u8>();
                      let l11 = *ptr1.add(20).cast::<usize>();
                      let len12 = l11;

                      _rt::Vec::from_raw_parts(l10.cast(), len12, len12)
                    };
                    KvValues::KvBstr(e19)
                  }
                  5 => {
                    let e19 = {
                      let l13 = *ptr1.add(16).cast::<*mut u8>();
                      let l14 = *ptr1.add(20).cast::<usize>();
                      let len15 = l14;

                      _rt::Vec::from_raw_parts(l13.cast(), len15, len15)
                    };
                    KvValues::KvCbor(e19)
                  }
                  n => {
                    debug_assert_eq!(n, 6, "invalid enum discriminant");
                    let e19 = {
                      let l16 = *ptr1.add(16).cast::<*mut u8>();
                      let l17 = *ptr1.add(20).cast::<usize>();
                      let len18 = l17;
                      let bytes18 = _rt::Vec::from_raw_parts(l16.cast(), len18, len18);

                      _rt::string_lift(bytes18)
                    };
                    KvValues::KvJson(e19)
                  }
                };

                v19
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Unsubscribe to any updates made to a particular Key.
      /// After this call, this module will no longer receive Key Update events when a key is written.
      /// It returns the current value of the Key and None if it is not set.
      pub fn kv_unsubscribe(key: &str,) -> Option<KvValues>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
          let vec0 = key;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:kv-store/api")]
          extern "C" {
            #[link_name = "kv-unsubscribe"]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => None,
            1 => {
              let e = {
                let l3 = i32::from(*ptr1.add(8).cast::<u8>());
                let v19 = match l3 {
                  0 => {
                    let e19 = {
                      let l4 = *ptr1.add(16).cast::<*mut u8>();
                      let l5 = *ptr1.add(20).cast::<usize>();
                      let len6 = l5;
                      let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                      _rt::string_lift(bytes6)
                    };
                    KvValues::KvString(e19)
                  }
                  1 => {
                    let e19 = {
                      let l7 = *ptr1.add(16).cast::<i64>();

                      l7
                    };
                    KvValues::KvS64(e19)
                  }
                  2 => {
                    let e19 = {
                      let l8 = *ptr1.add(16).cast::<i64>();

                      l8 as u64
                    };
                    KvValues::KvU64(e19)
                  }
                  3 => {
                    let e19 = {
                      let l9 = *ptr1.add(16).cast::<f64>();

                      l9
                    };
                    KvValues::KvF64(e19)
                  }
                  4 => {
                    let e19 = {
                      let l10 = *ptr1.add(16).cast::<*mut u8>();
                      let l11 = *ptr1.add(20).cast::<usize>();
                      let len12 = l11;

                      _rt::Vec::from_raw_parts(l10.cast(), len12, len12)
                    };
                    KvValues::KvBstr(e19)
                  }
                  5 => {
                    let e19 = {
                      let l13 = *ptr1.add(16).cast::<*mut u8>();
                      let l14 = *ptr1.add(20).cast::<usize>();
                      let len15 = l14;

                      _rt::Vec::from_raw_parts(l13.cast(), len15, len15)
                    };
                    KvValues::KvCbor(e19)
                  }
                  n => {
                    debug_assert_eq!(n, 6, "invalid enum discriminant");
                    let e19 = {
                      let l16 = *ptr1.add(16).cast::<*mut u8>();
                      let l17 = *ptr1.add(20).cast::<usize>();
                      let len18 = l17;
                      let bytes18 = _rt::Vec::from_raw_parts(l16.cast(), len18, len18);

                      _rt::string_lift(bytes18)
                    };
                    KvValues::KvJson(e19)
                  }
                };

                v19
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod localtime {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
      /// The timezone we are localized for.
      pub type Timezone = _rt::String;
      /// Time in localtime format.
      #[derive(Clone)]
      pub struct Localtime {
        pub year: u64,
        /// Year
        pub month: u8,
        /// Month (0-11)
        pub dow: u8,
        /// Day of week (0-6)
        pub day: u8,
        /// Day (1-31)
        pub hh: u8,
        /// Hour (0-23)
        pub mm: u8,
        /// Minute (0-59)
        pub ss: u8,
        /// Second (0-59)
        pub ns: u32,
        /// Nanoseconds
        pub tz: Timezone,
      }
      impl ::core::fmt::Debug for Localtime {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Localtime").field("year", &self.year).field("month", &self.month).field("dow", &self.dow).field("day", &self.day).field("hh", &self.hh).field("mm", &self.mm).field("ss", &self.ss).field("ns", &self.ns).field("tz", &self.tz).finish()
        }
      }
      /// Errors that can occur converting times
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum Errno {
        InvalidLocaltime,
        UnknownTimezone,
        YearOutOfRange,
      }
      impl Errno{
        pub fn name(&self) -> &'static str {
          match self {
            Errno::InvalidLocaltime => "invalid-localtime",
            Errno::UnknownTimezone => "unknown-timezone",
            Errno::YearOutOfRange => "year-out-of-range",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            Errno::InvalidLocaltime => "",
            Errno::UnknownTimezone => "",
            Errno::YearOutOfRange => "",
          }
        }
      }
      impl ::core::fmt::Debug for Errno{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Errno")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for Errno{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl std::error::Error for Errno {}

      impl Errno{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> Errno{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => Errno::InvalidLocaltime,
            1 => Errno::UnknownTimezone,
            2 => Errno::YearOutOfRange,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[allow(unused_unsafe, clippy::all)]
      /// Get localtime from a datetime or now.
      ///
      /// **Parameters**
      ///
      /// `when` : The datetime we want to convert (Optional, if not set it will convert `now`).
      /// `tz` : The timezone to use. (Optional, if not set uses the local machines configured local timezone.)
      ///
      /// **Returns**
      ///
      /// `localtime` : the converted time.
      /// `errno`     : An error indicating why conversion failed.
      pub fn get_localtime(when: Option<Datetime>,tz: Option<&Timezone>,) -> Result<Localtime,Errno>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 40]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 40]);
          let (result1_0,result1_1,result1_2,) = match when {
            Some(e) => {
              let super::super::super::wasi::clocks::wall_clock::Datetime{ seconds:seconds0, nanoseconds:nanoseconds0, } = e;

              (1i32, _rt::as_i64(seconds0), _rt::as_i32(nanoseconds0))
            },
            None => {
              (0i32, 0i64, 0i32)
            },
          };let (result3_0,result3_1,result3_2,) = match tz {
            Some(e) => {
              let vec2 = e;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();

              (1i32, ptr2.cast_mut(), len2)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:localtime/api")]
          extern "C" {
            #[link_name = "get-localtime"]
            fn wit_import(_: i32, _: i64, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i64, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(result1_0, result1_1, result1_2, result3_0, result3_1, result3_2, ptr4);
          let l5 = i32::from(*ptr4.add(0).cast::<u8>());
          match l5 {
            0 => {
              let e = {
                let l6 = *ptr4.add(8).cast::<i64>();
                let l7 = i32::from(*ptr4.add(16).cast::<u8>());
                let l8 = i32::from(*ptr4.add(17).cast::<u8>());
                let l9 = i32::from(*ptr4.add(18).cast::<u8>());
                let l10 = i32::from(*ptr4.add(19).cast::<u8>());
                let l11 = i32::from(*ptr4.add(20).cast::<u8>());
                let l12 = i32::from(*ptr4.add(21).cast::<u8>());
                let l13 = *ptr4.add(24).cast::<i32>();
                let l14 = *ptr4.add(28).cast::<*mut u8>();
                let l15 = *ptr4.add(32).cast::<usize>();
                let len16 = l15;
                let bytes16 = _rt::Vec::from_raw_parts(l14.cast(), len16, len16);

                Localtime{
                  year: l6 as u64,
                  month: l7 as u8,
                  dow: l8 as u8,
                  day: l9 as u8,
                  hh: l10 as u8,
                  mm: l11 as u8,
                  ss: l12 as u8,
                  ns: l13 as u32,
                  tz: _rt::string_lift(bytes16),
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l17 = i32::from(*ptr4.add(8).cast::<u8>());

                Errno::_lift(l17 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get a new localtime from a localtime, by recalculating time for a new timezone.
      ///
      /// **Parameters**
      ///
      /// `time` : The localtime to convert.
      /// `tz` : The timezone to use. (Optional, if not set uses the local machines configured local timezone.)
      ///
      /// **Returns**
      ///
      /// `localtime` : the converted time.
      /// `errno`     : An error indicating why conversion failed.
      pub fn alt_localtime(time: &Localtime,tz: Option<&Timezone>,) -> Result<Localtime,Errno>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 40]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 40]);
          let Localtime{ year:year0, month:month0, dow:dow0, day:day0, hh:hh0, mm:mm0, ss:ss0, ns:ns0, tz:tz0, } = time;
          let vec1 = tz0;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let (result3_0,result3_1,result3_2,) = match tz {
            Some(e) => {
              let vec2 = e;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();

              (1i32, ptr2.cast_mut(), len2)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:localtime/api")]
          extern "C" {
            #[link_name = "alt-localtime"]
            fn wit_import(_: i64, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i64(year0), _rt::as_i32(month0), _rt::as_i32(dow0), _rt::as_i32(day0), _rt::as_i32(hh0), _rt::as_i32(mm0), _rt::as_i32(ss0), _rt::as_i32(ns0), ptr1.cast_mut(), len1, result3_0, result3_1, result3_2, ptr4);
          let l5 = i32::from(*ptr4.add(0).cast::<u8>());
          match l5 {
            0 => {
              let e = {
                let l6 = *ptr4.add(8).cast::<i64>();
                let l7 = i32::from(*ptr4.add(16).cast::<u8>());
                let l8 = i32::from(*ptr4.add(17).cast::<u8>());
                let l9 = i32::from(*ptr4.add(18).cast::<u8>());
                let l10 = i32::from(*ptr4.add(19).cast::<u8>());
                let l11 = i32::from(*ptr4.add(20).cast::<u8>());
                let l12 = i32::from(*ptr4.add(21).cast::<u8>());
                let l13 = *ptr4.add(24).cast::<i32>();
                let l14 = *ptr4.add(28).cast::<*mut u8>();
                let l15 = *ptr4.add(32).cast::<usize>();
                let len16 = l15;
                let bytes16 = _rt::Vec::from_raw_parts(l14.cast(), len16, len16);

                Localtime{
                  year: l6 as u64,
                  month: l7 as u8,
                  dow: l8 as u8,
                  day: l9 as u8,
                  hh: l10 as u8,
                  mm: l11 as u8,
                  ss: l12 as u8,
                  ns: l13 as u32,
                  tz: _rt::string_lift(bytes16),
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l17 = i32::from(*ptr4.add(8).cast::<u8>());

                Errno::_lift(l17 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get a datetime from a localtime.
      ///
      /// **Parameters**
      ///
      /// `time` : The localtime to convert.
      ///
      /// **Returns**
      ///
      /// `datetime`  : the converted time.
      /// `errno`     : An error indicating why conversion failed.
      pub fn get_datetime(time: &Localtime,) -> Result<Datetime,Errno>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
          let Localtime{ year:year0, month:month0, dow:dow0, day:day0, hh:hh0, mm:mm0, ss:ss0, ns:ns0, tz:tz0, } = time;
          let vec1 = tz0;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:localtime/api")]
          extern "C" {
            #[link_name = "get-datetime"]
            fn wit_import(_: i64, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i64(year0), _rt::as_i32(month0), _rt::as_i32(dow0), _rt::as_i32(day0), _rt::as_i32(hh0), _rt::as_i32(mm0), _rt::as_i32(ss0), _rt::as_i32(ns0), ptr1.cast_mut(), len1, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = {
                let l4 = *ptr2.add(8).cast::<i64>();
                let l5 = *ptr2.add(16).cast::<i32>();

                super::super::super::wasi::clocks::wall_clock::Datetime{
                  seconds: l4 as u64,
                  nanoseconds: l5 as u32,
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = i32::from(*ptr2.add(8).cast::<u8>());

                Errno::_lift(l6 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod logging {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Json = super::super::super::hermes::json::api::Json;
      /// The supported logging levels
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum Level {
        /// Debug Log Level
        Debug,
        /// Tracing Log level
        Trace,
        /// General Informational Log Level
        Info,
        /// Warning about something that might be a problem.
        Warn,
        /// A very serious error
        Error,
      }
      impl ::core::fmt::Debug for Level {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Level::Debug => {
              f.debug_tuple("Level::Debug").finish()
            }
            Level::Trace => {
              f.debug_tuple("Level::Trace").finish()
            }
            Level::Info => {
              f.debug_tuple("Level::Info").finish()
            }
            Level::Warn => {
              f.debug_tuple("Level::Warn").finish()
            }
            Level::Error => {
              f.debug_tuple("Level::Error").finish()
            }
          }
        }
      }

      impl Level{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> Level{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => Level::Debug,
            1 => Level::Trace,
            2 => Level::Info,
            3 => Level::Warn,
            4 => Level::Error,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[allow(unused_unsafe, clippy::all)]
      /// Generate a Log
      ///
      /// The Hermes API will add extra information to the log, such as the instance of the webasm
      /// module being logged.
      /// The Webasm module does not need to concern itself with this kind of information, and should
      /// log as if it is the only instance.
      /// It also should not log any webasm shared context, except where it is relevant to the log message itself.
      /// The log level will be forced to INFO level.
      ///
      /// **Parameters**
      ///
      /// - `level` : The log level this message is for.
      /// - `file`  : The name of the src file being logged from. (Optional)
      /// - `function`    : The function within the file being logged from. (Optional)
      /// - `line`  : The line of code the log was generated from. (Optional)
      /// - `col`   : The column of code the log was generated from. (Optional)
      /// - `ctx`   : The logging context.  (Should have no newlines or formatting).
      /// - `msg`   : A Single line message to be logged. (Should have no newlines or formatting).
      /// - `data`  : A Free form json payload that will be logged with the msg.  This must be valid JSON.
      ///
      /// *Notes*
      ///
      /// The `data` parameter may contain a record of the format:
      /// ```json
      /// {
      /// "bt" : [ <string> , <string> ]
      /// }
      /// ```
      /// The logger will interpret this as a backtrace where each entry in the array is one line of the backtrace.
      /// The format of the backtrace lines is up to the webasm module generating the log.
      /// The individual backtrace entries may contain line breaks if the backtrace entry is
      /// multiline.
      /// * Multiline backtrace entries should be de-dented, relative to the first line.
      /// * This is to allow the display to properly format multiline entries.
      /// This format is designed to keep the broadest flexibility for multiple languages capabilities.
      /// The backtrace must be sorted with most recent lines of the backtrace occurring first in the array.
      /// Backtrace must be contained in a single `log` call.  Multiple log calls will be considered independent logs.
      pub fn log(level: Level,file: Option<&str>,function: Option<&str>,line: Option<u32>,col: Option<u32>,ctx: Option<&str>,msg: &str,data: Option<&Json>,){
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 76]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 76]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<u8>() = (level.clone() as i32) as u8;
          match file {
            Some(e) => {
              *ptr0.add(4).cast::<u8>() = (1i32) as u8;
              let vec1 = e;
              let ptr1 = vec1.as_ptr().cast::<u8>();
              let len1 = vec1.len();
              *ptr0.add(12).cast::<usize>() = len1;
              *ptr0.add(8).cast::<*mut u8>() = ptr1.cast_mut();
            },
            None => {
              {
                *ptr0.add(4).cast::<u8>() = (0i32) as u8;
              }
            },
          };match function {
            Some(e) => {
              *ptr0.add(16).cast::<u8>() = (1i32) as u8;
              let vec2 = e;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *ptr0.add(24).cast::<usize>() = len2;
              *ptr0.add(20).cast::<*mut u8>() = ptr2.cast_mut();
            },
            None => {
              {
                *ptr0.add(16).cast::<u8>() = (0i32) as u8;
              }
            },
          };match line {
            Some(e) => {
              *ptr0.add(28).cast::<u8>() = (1i32) as u8;
              *ptr0.add(32).cast::<i32>() = _rt::as_i32(e);
            },
            None => {
              {
                *ptr0.add(28).cast::<u8>() = (0i32) as u8;
              }
            },
          };match col {
            Some(e) => {
              *ptr0.add(36).cast::<u8>() = (1i32) as u8;
              *ptr0.add(40).cast::<i32>() = _rt::as_i32(e);
            },
            None => {
              {
                *ptr0.add(36).cast::<u8>() = (0i32) as u8;
              }
            },
          };match ctx {
            Some(e) => {
              *ptr0.add(44).cast::<u8>() = (1i32) as u8;
              let vec3 = e;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();
              *ptr0.add(52).cast::<usize>() = len3;
              *ptr0.add(48).cast::<*mut u8>() = ptr3.cast_mut();
            },
            None => {
              {
                *ptr0.add(44).cast::<u8>() = (0i32) as u8;
              }
            },
          };let vec4 = msg;
          let ptr4 = vec4.as_ptr().cast::<u8>();
          let len4 = vec4.len();
          *ptr0.add(60).cast::<usize>() = len4;
          *ptr0.add(56).cast::<*mut u8>() = ptr4.cast_mut();
          match data {
            Some(e) => {
              *ptr0.add(64).cast::<u8>() = (1i32) as u8;
              let vec5 = e;
              let ptr5 = vec5.as_ptr().cast::<u8>();
              let len5 = vec5.len();
              *ptr0.add(72).cast::<usize>() = len5;
              *ptr0.add(68).cast::<*mut u8>() = ptr5.cast_mut();
            },
            None => {
              {
                *ptr0.add(64).cast::<u8>() = (0i32) as u8;
              }
            },
          };
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:logging/api")]
          extern "C" {
            #[link_name = "log"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod sqlite {
    #[allow(dead_code, clippy::all)]
    pub mod api {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      /// Represents an error with a code and a message.
      #[derive(Clone)]
      pub struct ErrorInfo {
        /// The numeric result code of the error.
        pub code: i32,
        /// The error message associated with the error code.
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for ErrorInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ErrorInfo").field("code", &self.code).field("message", &self.message).finish()
        }
      }
      /// Errors that indicate that something has gone wrong.
      #[derive(Clone, Copy)]
      pub enum Errno {
        /// An error caused from internal SQLite engine.
        Sqlite(i32),
        /// An error caused during the conversion of a CString.
        ConvertingCString,
        /// The in-memory configuration provided is invalid.
        InvalidInMemoryConfig,
        /// The persistent configuration provided is invalid.
        InvalidPersistentConfig,
        /// The database name is missing in the persistent configuration.
        MissingDatabaseNameForPersistentConfig,
        /// Failed to open the database.
        FailedOpeningDatabase,
        /// Failed to set the database size limit.
        FailedSettingDatabaseSize,
        /// Unknown column type is retrieved.
        UnknownColumnType,
        /// `PRAGMA` commands are not allowed to execute inside Hermes.
        ForbiddenPragmaCommand,
        /// Unhandled null pointer is returned while interacting with the database.
        ReturnedNullPointer,
        /// The numeric value is truncated or improperly converted during the execution.
        ConvertingNumeric,
      }
      impl ::core::fmt::Debug for Errno {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Errno::Sqlite(e) => {
              f.debug_tuple("Errno::Sqlite").field(e).finish()
            }
            Errno::ConvertingCString => {
              f.debug_tuple("Errno::ConvertingCString").finish()
            }
            Errno::InvalidInMemoryConfig => {
              f.debug_tuple("Errno::InvalidInMemoryConfig").finish()
            }
            Errno::InvalidPersistentConfig => {
              f.debug_tuple("Errno::InvalidPersistentConfig").finish()
            }
            Errno::MissingDatabaseNameForPersistentConfig => {
              f.debug_tuple("Errno::MissingDatabaseNameForPersistentConfig").finish()
            }
            Errno::FailedOpeningDatabase => {
              f.debug_tuple("Errno::FailedOpeningDatabase").finish()
            }
            Errno::FailedSettingDatabaseSize => {
              f.debug_tuple("Errno::FailedSettingDatabaseSize").finish()
            }
            Errno::UnknownColumnType => {
              f.debug_tuple("Errno::UnknownColumnType").finish()
            }
            Errno::ForbiddenPragmaCommand => {
              f.debug_tuple("Errno::ForbiddenPragmaCommand").finish()
            }
            Errno::ReturnedNullPointer => {
              f.debug_tuple("Errno::ReturnedNullPointer").finish()
            }
            Errno::ConvertingNumeric => {
              f.debug_tuple("Errno::ConvertingNumeric").finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for Errno {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }

      impl std::error::Error for Errno {}
      /// The value of a column in a specific data format.
      #[derive(Clone)]
      pub enum Value {
        /// A blob or a UTF-8 text in bytes.
        Blob(_rt::Vec::<u8>),
        /// Real number.
        Double(f64),
        /// 32-bit integer.
        Int32(i32),
        /// 64-bit integer.
        Int64(i64),
        /// Null value.
        Null,
        /// UTF-8 text.
        Text(_rt::String),
      }
      impl ::core::fmt::Debug for Value {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Value::Blob(e) => {
              f.debug_tuple("Value::Blob").field(e).finish()
            }
            Value::Double(e) => {
              f.debug_tuple("Value::Double").field(e).finish()
            }
            Value::Int32(e) => {
              f.debug_tuple("Value::Int32").field(e).finish()
            }
            Value::Int64(e) => {
              f.debug_tuple("Value::Int64").field(e).finish()
            }
            Value::Null => {
              f.debug_tuple("Value::Null").finish()
            }
            Value::Text(e) => {
              f.debug_tuple("Value::Text").field(e).finish()
            }
          }
        }
      }
      /// The database connection object.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Sqlite{
        handle: _rt::Resource<Sqlite>,
      }

      impl Sqlite{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for Sqlite{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "hermes:sqlite/api")]
            extern "C" {
              #[link_name = "[resource-drop]sqlite"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// The prepared statement object.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Statement{
        handle: _rt::Resource<Statement>,
      }

      impl Statement{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for Statement{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "hermes:sqlite/api")]
            extern "C" {
              #[link_name = "[resource-drop]statement"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      impl Sqlite {
        #[allow(unused_unsafe, clippy::all)]
        /// Closes a database connection, destructor for `sqlite3`.
        ///
        /// Ideally, applications should finalize all prepared statements associated with the `sqlite3` object prior to attempting to close the object.
        /// If the database connection is associated with unfinalized prepared statements,
        /// then the function will leave the database connection open and return the `busy` error code.
        ///
        /// If an `sqlite3` object is destroyed while a transaction is open, the transaction is automatically rolled back.
        pub fn close(&self,) -> Result<(),Errno>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:sqlite/api")]
            extern "C" {
              #[link_name = "[method]sqlite.close"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v4 = match l2 {
                    0 => {
                      let e4 = {
                        let l3 = *ptr0.add(8).cast::<i32>();

                        l3
                      };
                      Errno::Sqlite(e4)
                    }
                    1 => {
                      Errno::ConvertingCString
                    }
                    2 => {
                      Errno::InvalidInMemoryConfig
                    }
                    3 => {
                      Errno::InvalidPersistentConfig
                    }
                    4 => {
                      Errno::MissingDatabaseNameForPersistentConfig
                    }
                    5 => {
                      Errno::FailedOpeningDatabase
                    }
                    6 => {
                      Errno::FailedSettingDatabaseSize
                    }
                    7 => {
                      Errno::UnknownColumnType
                    }
                    8 => {
                      Errno::ForbiddenPragmaCommand
                    }
                    9 => {
                      Errno::ReturnedNullPointer
                    }
                    n => {
                      debug_assert_eq!(n, 10, "invalid enum discriminant");
                      Errno::ConvertingNumeric
                    }
                  };

                  v4
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Sqlite {
        #[allow(unused_unsafe, clippy::all)]
        /// Retrieves the numeric result code for the most recent failed SQLite operation on a database connection.
        ///
        /// # Returns
        ///
        /// The error object containing numeric code and detail message for the most recent failed SQLite operation. If there is no recent failed, none is returned.
        pub fn errcode(&self,) -> Option<ErrorInfo>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:sqlite/api")]
            extern "C" {
              #[link_name = "[method]sqlite.errcode"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();
                  let l3 = *ptr0.add(8).cast::<*mut u8>();
                  let l4 = *ptr0.add(12).cast::<usize>();
                  let len5 = l4;
                  let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

                  ErrorInfo{
                    code: l2,
                    message: _rt::string_lift(bytes5),
                  }
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Sqlite {
        #[allow(unused_unsafe, clippy::all)]
        /// Compiles SQL text into byte-code that will do the work of querying or updating the database.
        ///
        /// ## Parameters
        ///
        /// - `db`: Database handle.
        /// - `sql`: SQL statement, UTF-8 encoded.
        ///
        /// ## Returns
        ///
        /// A compiled prepared statement that can be executed using `sqlite3_step()`.
        /// If there is an error or the input text contains no SQL (if the input is an empty string or a comment) then an error code is returned.
        pub fn prepare(&self,sql: &str,) -> Result<Statement,Errno>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let vec0 = sql;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:sqlite/api")]
            extern "C" {
              #[link_name = "[method]sqlite.prepare"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = {
                  let l3 = *ptr1.add(4).cast::<i32>();

                  Statement::from_handle(l3 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr1.add(4).cast::<u8>());
                  let v6 = match l4 {
                    0 => {
                      let e6 = {
                        let l5 = *ptr1.add(8).cast::<i32>();

                        l5
                      };
                      Errno::Sqlite(e6)
                    }
                    1 => {
                      Errno::ConvertingCString
                    }
                    2 => {
                      Errno::InvalidInMemoryConfig
                    }
                    3 => {
                      Errno::InvalidPersistentConfig
                    }
                    4 => {
                      Errno::MissingDatabaseNameForPersistentConfig
                    }
                    5 => {
                      Errno::FailedOpeningDatabase
                    }
                    6 => {
                      Errno::FailedSettingDatabaseSize
                    }
                    7 => {
                      Errno::UnknownColumnType
                    }
                    8 => {
                      Errno::ForbiddenPragmaCommand
                    }
                    9 => {
                      Errno::ReturnedNullPointer
                    }
                    n => {
                      debug_assert_eq!(n, 10, "invalid enum discriminant");
                      Errno::ConvertingNumeric
                    }
                  };

                  v6
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Sqlite {
        #[allow(unused_unsafe, clippy::all)]
        /// Executes an SQL query directly without preparing it into a statement and returns the result.
        ///
        /// ## Parameters
        ///
        /// - `sql`: SQL statement, UTF-8 encoded.
        pub fn execute(&self,sql: &str,) -> Result<(),Errno>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let vec0 = sql;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:sqlite/api")]
            extern "C" {
              #[link_name = "[method]sqlite.execute"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr1.add(4).cast::<u8>());
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *ptr1.add(8).cast::<i32>();

                        l4
                      };
                      Errno::Sqlite(e5)
                    }
                    1 => {
                      Errno::ConvertingCString
                    }
                    2 => {
                      Errno::InvalidInMemoryConfig
                    }
                    3 => {
                      Errno::InvalidPersistentConfig
                    }
                    4 => {
                      Errno::MissingDatabaseNameForPersistentConfig
                    }
                    5 => {
                      Errno::FailedOpeningDatabase
                    }
                    6 => {
                      Errno::FailedSettingDatabaseSize
                    }
                    7 => {
                      Errno::UnknownColumnType
                    }
                    8 => {
                      Errno::ForbiddenPragmaCommand
                    }
                    9 => {
                      Errno::ReturnedNullPointer
                    }
                    n => {
                      debug_assert_eq!(n, 10, "invalid enum discriminant");
                      Errno::ConvertingNumeric
                    }
                  };

                  v5
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Statement {
        #[allow(unused_unsafe, clippy::all)]
        /// Stores application data into parameters of the original SQL.
        ///
        /// ## Parameters
        ///
        /// - `index`: The index of the SQL parameter to be set.
        /// - `value`: The value to bind to the parameter.
        pub fn bind(&self,index: u32,value: &Value,) -> Result<(),Errno>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let (result2_0,result2_1,result2_2,) = match value {
              Value::Blob(e) => {
                let vec0 = e;
                let ptr0 = vec0.as_ptr().cast::<u8>();
                let len0 = vec0.len();

                (0i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(ptr0.cast_mut());
                  t
                }, len0)
              },
              Value::Double(e) => (1i32, ::core::mem::MaybeUninit::new((_rt::as_f64(e)).to_bits() as i64 as u64), 0usize),
              Value::Int32(e) => (2i32, ::core::mem::MaybeUninit::new(i64::from(_rt::as_i32(e)) as u64), 0usize),
              Value::Int64(e) => (3i32, ::core::mem::MaybeUninit::new(_rt::as_i64(e) as u64), 0usize),
              Value::Null=> {
                (4i32, ::core::mem::MaybeUninit::<u64>::zeroed(), 0usize)
              }
              Value::Text(e) => {
                let vec1 = e;
                let ptr1 = vec1.as_ptr().cast::<u8>();
                let len1 = vec1.len();

                (5i32, {
                  let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                  t.as_mut_ptr().cast::<*mut u8>().write(ptr1.cast_mut());
                  t
                }, len1)
              },
            };
            let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:sqlite/api")]
            extern "C" {
              #[link_name = "[method]statement.bind"]
              fn wit_import(_: i32, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i32(&index), result2_0, result2_1, result2_2, ptr3);
            let l4 = i32::from(*ptr3.add(0).cast::<u8>());
            match l4 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*ptr3.add(4).cast::<u8>());
                  let v7 = match l5 {
                    0 => {
                      let e7 = {
                        let l6 = *ptr3.add(8).cast::<i32>();

                        l6
                      };
                      Errno::Sqlite(e7)
                    }
                    1 => {
                      Errno::ConvertingCString
                    }
                    2 => {
                      Errno::InvalidInMemoryConfig
                    }
                    3 => {
                      Errno::InvalidPersistentConfig
                    }
                    4 => {
                      Errno::MissingDatabaseNameForPersistentConfig
                    }
                    5 => {
                      Errno::FailedOpeningDatabase
                    }
                    6 => {
                      Errno::FailedSettingDatabaseSize
                    }
                    7 => {
                      Errno::UnknownColumnType
                    }
                    8 => {
                      Errno::ForbiddenPragmaCommand
                    }
                    9 => {
                      Errno::ReturnedNullPointer
                    }
                    n => {
                      debug_assert_eq!(n, 10, "invalid enum discriminant");
                      Errno::ConvertingNumeric
                    }
                  };

                  v7
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Statement {
        #[allow(unused_unsafe, clippy::all)]
        /// Advances a statement to the next result row or to completion.
        ///
        /// After a prepared statement has been prepared, this function must be called one or more times to evaluate the statement.
        pub fn step(&self,) -> Result<(),Errno>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:sqlite/api")]
            extern "C" {
              #[link_name = "[method]statement.step"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v4 = match l2 {
                    0 => {
                      let e4 = {
                        let l3 = *ptr0.add(8).cast::<i32>();

                        l3
                      };
                      Errno::Sqlite(e4)
                    }
                    1 => {
                      Errno::ConvertingCString
                    }
                    2 => {
                      Errno::InvalidInMemoryConfig
                    }
                    3 => {
                      Errno::InvalidPersistentConfig
                    }
                    4 => {
                      Errno::MissingDatabaseNameForPersistentConfig
                    }
                    5 => {
                      Errno::FailedOpeningDatabase
                    }
                    6 => {
                      Errno::FailedSettingDatabaseSize
                    }
                    7 => {
                      Errno::UnknownColumnType
                    }
                    8 => {
                      Errno::ForbiddenPragmaCommand
                    }
                    9 => {
                      Errno::ReturnedNullPointer
                    }
                    n => {
                      debug_assert_eq!(n, 10, "invalid enum discriminant");
                      Errno::ConvertingNumeric
                    }
                  };

                  v4
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Statement {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns information about a single column of the current result row of a query.
        ///
        /// If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined.
        ///
        /// ## Parameters
        ///
        /// - `index`: The index of the column for which information should be returned. The leftmost column of the result set has the index 0.
        ///
        /// ## Returns
        ///
        /// The value of a result column in a specific data format.
        pub fn column(&self,index: u32,) -> Result<Value,Errno>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:sqlite/api")]
            extern "C" {
              #[link_name = "[method]statement.column"]
              fn wit_import(_: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i32(&index), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(8).cast::<u8>());
                  let v12 = match l2 {
                    0 => {
                      let e12 = {
                        let l3 = *ptr0.add(16).cast::<*mut u8>();
                        let l4 = *ptr0.add(20).cast::<usize>();
                        let len5 = l4;

                        _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                      };
                      Value::Blob(e12)
                    }
                    1 => {
                      let e12 = {
                        let l6 = *ptr0.add(16).cast::<f64>();

                        l6
                      };
                      Value::Double(e12)
                    }
                    2 => {
                      let e12 = {
                        let l7 = *ptr0.add(16).cast::<i32>();

                        l7
                      };
                      Value::Int32(e12)
                    }
                    3 => {
                      let e12 = {
                        let l8 = *ptr0.add(16).cast::<i64>();

                        l8
                      };
                      Value::Int64(e12)
                    }
                    4 => {
                      Value::Null
                    }
                    n => {
                      debug_assert_eq!(n, 5, "invalid enum discriminant");
                      let e12 = {
                        let l9 = *ptr0.add(16).cast::<*mut u8>();
                        let l10 = *ptr0.add(20).cast::<usize>();
                        let len11 = l10;
                        let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);

                        _rt::string_lift(bytes11)
                      };
                      Value::Text(e12)
                    }
                  };

                  v12
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l13 = i32::from(*ptr0.add(8).cast::<u8>());
                  let v15 = match l13 {
                    0 => {
                      let e15 = {
                        let l14 = *ptr0.add(12).cast::<i32>();

                        l14
                      };
                      Errno::Sqlite(e15)
                    }
                    1 => {
                      Errno::ConvertingCString
                    }
                    2 => {
                      Errno::InvalidInMemoryConfig
                    }
                    3 => {
                      Errno::InvalidPersistentConfig
                    }
                    4 => {
                      Errno::MissingDatabaseNameForPersistentConfig
                    }
                    5 => {
                      Errno::FailedOpeningDatabase
                    }
                    6 => {
                      Errno::FailedSettingDatabaseSize
                    }
                    7 => {
                      Errno::UnknownColumnType
                    }
                    8 => {
                      Errno::ForbiddenPragmaCommand
                    }
                    9 => {
                      Errno::ReturnedNullPointer
                    }
                    n => {
                      debug_assert_eq!(n, 10, "invalid enum discriminant");
                      Errno::ConvertingNumeric
                    }
                  };

                  v15
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Statement {
        #[allow(unused_unsafe, clippy::all)]
        /// Destroys a prepared statement object. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated,
        /// then the function results without errors. If the most recent evaluation of statement failed, then the function results the appropriate error code.
        ///
        /// The application must finalize every prepared statement in order to avoid resource leaks.
        /// It is a grievous error for the application to try to use a prepared statement after it has been finalized.
        /// Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.
        pub fn finalize(&self,) -> Result<(),Errno>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "hermes:sqlite/api")]
            extern "C" {
              #[link_name = "[method]statement.finalize"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v4 = match l2 {
                    0 => {
                      let e4 = {
                        let l3 = *ptr0.add(8).cast::<i32>();

                        l3
                      };
                      Errno::Sqlite(e4)
                    }
                    1 => {
                      Errno::ConvertingCString
                    }
                    2 => {
                      Errno::InvalidInMemoryConfig
                    }
                    3 => {
                      Errno::InvalidPersistentConfig
                    }
                    4 => {
                      Errno::MissingDatabaseNameForPersistentConfig
                    }
                    5 => {
                      Errno::FailedOpeningDatabase
                    }
                    6 => {
                      Errno::FailedSettingDatabaseSize
                    }
                    7 => {
                      Errno::UnknownColumnType
                    }
                    8 => {
                      Errno::ForbiddenPragmaCommand
                    }
                    9 => {
                      Errno::ReturnedNullPointer
                    }
                    n => {
                      debug_assert_eq!(n, 10, "invalid enum discriminant");
                      Errno::ConvertingNumeric
                    }
                  };

                  v4
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Opens a connection to a new or existing SQLite database.
      ///
      /// ## Parameters
      ///
      /// - `readonly`: If set to true, the database is opened in read-only mode. An error is returned if the database doesn't already exist.
      /// - `memory`: If set to true, the database will be opened as an in-memory database.
      ///
      /// ## Returns
      ///
      /// If the database is opened (and/or created) successfully, then the `sqlite3` object is returned. Otherwise an error code is returned.
      pub fn open(readonly: bool,memory: bool,) -> Result<Sqlite,Errno>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "hermes:sqlite/api")]
          extern "C" {
            #[link_name = "open"]
            fn wit_import(_: i32, _: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: *mut u8, ){ unreachable!() }
          wit_import(match &readonly { true => 1, false => 0 }, match &memory { true => 1, false => 0 }, ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => {
              let e = {
                let l2 = *ptr0.add(4).cast::<i32>();

                Sqlite::from_handle(l2 as u32)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = i32::from(*ptr0.add(4).cast::<u8>());
                let v5 = match l3 {
                  0 => {
                    let e5 = {
                      let l4 = *ptr0.add(8).cast::<i32>();

                      l4
                    };
                    Errno::Sqlite(e5)
                  }
                  1 => {
                    Errno::ConvertingCString
                  }
                  2 => {
                    Errno::InvalidInMemoryConfig
                  }
                  3 => {
                    Errno::InvalidPersistentConfig
                  }
                  4 => {
                    Errno::MissingDatabaseNameForPersistentConfig
                  }
                  5 => {
                    Errno::FailedOpeningDatabase
                  }
                  6 => {
                    Errno::FailedSettingDatabaseSize
                  }
                  7 => {
                    Errno::UnknownColumnType
                  }
                  8 => {
                    Errno::ForbiddenPragmaCommand
                  }
                  9 => {
                    Errno::ReturnedNullPointer
                  }
                  n => {
                    debug_assert_eq!(n, 10, "invalid enum discriminant");
                    Errno::ConvertingNumeric
                  }
                };

                v5
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

  }
}
#[allow(dead_code)]
pub mod wasi {
  #[allow(dead_code)]
  pub mod cli {
    #[allow(dead_code, clippy::all)]
    pub mod environment {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      /// Get the POSIX-style environment variables.
      ///
      /// Each environment variable is provided as a pair of string variable names
      /// and string value.
      ///
      /// Morally, these are a value import, but until value imports are available
      /// in the component model, this import function should return the same
      /// values each time it is called.
      pub fn get_environment() -> _rt::Vec::<(_rt::String,_rt::String,)>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/environment@0.2.0")]
          extern "C" {
            #[link_name = "get-environment"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = *ptr0.add(0).cast::<*mut u8>();
          let l2 = *ptr0.add(4).cast::<usize>();
          let base9 = l1;
          let len9 = l2;
          let mut result9 = _rt::Vec::with_capacity(len9);
          for i in 0..len9 {
            let base = base9.add(i * 16);
            let e9 = {
              let l3 = *base.add(0).cast::<*mut u8>();
              let l4 = *base.add(4).cast::<usize>();
              let len5 = l4;
              let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
              let l6 = *base.add(8).cast::<*mut u8>();
              let l7 = *base.add(12).cast::<usize>();
              let len8 = l7;
              let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);

              (_rt::string_lift(bytes5), _rt::string_lift(bytes8))
            };
            result9.push(e9);
          }
          _rt::cabi_dealloc(base9, len9 * 16, 4);
          result9
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get the POSIX-style arguments to the program.
      pub fn get_arguments() -> _rt::Vec::<_rt::String>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/environment@0.2.0")]
          extern "C" {
            #[link_name = "get-arguments"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = *ptr0.add(0).cast::<*mut u8>();
          let l2 = *ptr0.add(4).cast::<usize>();
          let base6 = l1;
          let len6 = l2;
          let mut result6 = _rt::Vec::with_capacity(len6);
          for i in 0..len6 {
            let base = base6.add(i * 8);
            let e6 = {
              let l3 = *base.add(0).cast::<*mut u8>();
              let l4 = *base.add(4).cast::<usize>();
              let len5 = l4;
              let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

              _rt::string_lift(bytes5)
            };
            result6.push(e6);
          }
          _rt::cabi_dealloc(base6, len6 * 8, 4);
          result6
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Return a path that programs should use as their initial current working
      /// directory, interpreting `.` as shorthand for this.
      pub fn initial_cwd() -> Option<_rt::String>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/environment@0.2.0")]
          extern "C" {
            #[link_name = "initial-cwd"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => None,
            1 => {
              let e = {
                let l2 = *ptr0.add(4).cast::<*mut u8>();
                let l3 = *ptr0.add(8).cast::<usize>();
                let len4 = l3;
                let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                _rt::string_lift(bytes4)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod exit {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      #[allow(unused_unsafe, clippy::all)]
      /// Exit the current instance and any linked instances.
      pub fn exit(status: Result<(),()>,){
        unsafe {
          let result0 = match status {
            Ok(_) => { 0i32 },
            Err(_) => { 1i32 },
          };
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/exit@0.2.0")]
          extern "C" {
            #[link_name = "exit"]
            fn wit_import(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, ){ unreachable!() }
          wit_import(result0);
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod stdin {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      pub type InputStream = super::super::super::wasi::io::streams::InputStream;
      #[allow(unused_unsafe, clippy::all)]
      pub fn get_stdin() -> InputStream{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/stdin@0.2.0")]
          extern "C" {
            #[link_name = "get-stdin"]
            fn wit_import() -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import() -> i32{ unreachable!() }
          let ret = wit_import();
          super::super::super::wasi::io::streams::InputStream::from_handle(ret as u32)
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod stdout {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
      #[allow(unused_unsafe, clippy::all)]
      pub fn get_stdout() -> OutputStream{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/stdout@0.2.0")]
          extern "C" {
            #[link_name = "get-stdout"]
            fn wit_import() -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import() -> i32{ unreachable!() }
          let ret = wit_import();
          super::super::super::wasi::io::streams::OutputStream::from_handle(ret as u32)
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod stderr {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
      #[allow(unused_unsafe, clippy::all)]
      pub fn get_stderr() -> OutputStream{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/stderr@0.2.0")]
          extern "C" {
            #[link_name = "get-stderr"]
            fn wit_import() -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import() -> i32{ unreachable!() }
          let ret = wit_import();
          super::super::super::wasi::io::streams::OutputStream::from_handle(ret as u32)
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod clocks {
    #[allow(dead_code, clippy::all)]
    pub mod monotonic_clock {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      /// Hermes does not support `poll`
      /// use wasi:io/poll@0.2.0.{pollable};
      /// An instant in time, in nanoseconds. An instant is relative to an
      /// unspecified initial value, and can only be compared to instances from
      /// the same monotonic-clock.
      pub type Instant = u64;
      /// A duration of time, in nanoseconds.
      pub type Duration = u64;
      #[allow(unused_unsafe, clippy::all)]
      /// Read the current value of the clock.
      ///
      /// The clock is monotonic, therefore calling this function repeatedly will
      /// produce a sequence of non-decreasing values.
      pub fn now() -> Instant{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.0")]
          extern "C" {
            #[link_name = "now"]
            fn wit_import() -> i64;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import() -> i64{ unreachable!() }
          let ret = wit_import();
          ret as u64
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Query the resolution of the clock. Returns the duration of time
      /// corresponding to a clock tick.
      pub fn resolution() -> Duration{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.0")]
          extern "C" {
            #[link_name = "resolution"]
            fn wit_import() -> i64;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import() -> i64{ unreachable!() }
          let ret = wit_import();
          ret as u64
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod wall_clock {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      /// A time and date in seconds plus nanoseconds.
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct Datetime {
        pub seconds: u64,
        pub nanoseconds: u32,
      }
      impl ::core::fmt::Debug for Datetime {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Datetime").field("seconds", &self.seconds).field("nanoseconds", &self.nanoseconds).finish()
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Read the current value of the clock.
      ///
      /// This clock is not monotonic, therefore calling this function repeatedly
      /// will not necessarily produce a sequence of non-decreasing values.
      ///
      /// The returned timestamps represent the number of seconds since
      /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
      /// also known as [Unix Time].
      ///
      /// The nanoseconds field of the output is always less than 1000000000.
      ///
      /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
      /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
      pub fn now() -> Datetime{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:clocks/wall-clock@0.2.0")]
          extern "C" {
            #[link_name = "now"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = *ptr0.add(0).cast::<i64>();
          let l2 = *ptr0.add(8).cast::<i32>();
          Datetime{
            seconds: l1 as u64,
            nanoseconds: l2 as u32,
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Query the resolution of the clock.
      ///
      /// The nanoseconds field of the output is always less than 1000000000.
      pub fn resolution() -> Datetime{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:clocks/wall-clock@0.2.0")]
          extern "C" {
            #[link_name = "resolution"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = *ptr0.add(0).cast::<i64>();
          let l2 = *ptr0.add(8).cast::<i32>();
          Datetime{
            seconds: l1 as u64,
            nanoseconds: l2 as u32,
          }
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod filesystem {
    #[allow(dead_code, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type InputStream = super::super::super::wasi::io::streams::InputStream;
      pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
      pub type Error = super::super::super::wasi::io::streams::Error;
      pub type Datetime = super::super::super::wasi::clocks::wall_clock::Datetime;
      /// File size or length of a region within a file.
      pub type Filesize = u64;
      /// The type of a filesystem object referenced by a descriptor.
      ///
      /// Note: This was called `filetype` in earlier versions of WASI.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum DescriptorType {
        /// The type of the descriptor or file is unknown or is different from
        /// any of the other types specified.
        Unknown,
        /// The descriptor refers to a block device inode.
        BlockDevice,
        /// The descriptor refers to a character device inode.
        CharacterDevice,
        /// The descriptor refers to a directory inode.
        Directory,
        /// The descriptor refers to a named pipe.
        Fifo,
        /// The file refers to a symbolic link inode.
        SymbolicLink,
        /// The descriptor refers to a regular file inode.
        RegularFile,
        /// The descriptor refers to a socket.
        Socket,
      }
      impl ::core::fmt::Debug for DescriptorType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            DescriptorType::Unknown => {
              f.debug_tuple("DescriptorType::Unknown").finish()
            }
            DescriptorType::BlockDevice => {
              f.debug_tuple("DescriptorType::BlockDevice").finish()
            }
            DescriptorType::CharacterDevice => {
              f.debug_tuple("DescriptorType::CharacterDevice").finish()
            }
            DescriptorType::Directory => {
              f.debug_tuple("DescriptorType::Directory").finish()
            }
            DescriptorType::Fifo => {
              f.debug_tuple("DescriptorType::Fifo").finish()
            }
            DescriptorType::SymbolicLink => {
              f.debug_tuple("DescriptorType::SymbolicLink").finish()
            }
            DescriptorType::RegularFile => {
              f.debug_tuple("DescriptorType::RegularFile").finish()
            }
            DescriptorType::Socket => {
              f.debug_tuple("DescriptorType::Socket").finish()
            }
          }
        }
      }

      impl DescriptorType{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> DescriptorType{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => DescriptorType::Unknown,
            1 => DescriptorType::BlockDevice,
            2 => DescriptorType::CharacterDevice,
            3 => DescriptorType::Directory,
            4 => DescriptorType::Fifo,
            5 => DescriptorType::SymbolicLink,
            6 => DescriptorType::RegularFile,
            7 => DescriptorType::Socket,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      wit_bindgen::rt::bitflags::bitflags! {
        /// Descriptor flags.
        ///
        /// Note: This was called `fdflags` in earlier versions of WASI.
        #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
        pub struct DescriptorFlags: u8 {
          /// Read mode: Data can be read.
          const READ = 1 << 0;
          /// Write mode: Data can be written to.
          const WRITE = 1 << 1;
          /// Request that writes be performed according to synchronized I/O file
          /// integrity completion. The data stored in the file and the file's
          /// metadata are synchronized. This is similar to `O_SYNC` in POSIX.
          ///
          /// The precise semantics of this operation have not yet been defined for
          /// WASI. At this time, it should be interpreted as a request, and not a
          /// requirement.
          const FILE_INTEGRITY_SYNC = 1 << 2;
          /// Request that writes be performed according to synchronized I/O data
          /// integrity completion. Only the data stored in the file is
          /// synchronized. This is similar to `O_DSYNC` in POSIX.
          ///
          /// The precise semantics of this operation have not yet been defined for
          /// WASI. At this time, it should be interpreted as a request, and not a
          /// requirement.
          const DATA_INTEGRITY_SYNC = 1 << 3;
          /// Requests that reads be performed at the same level of integrety
          /// requested for writes. This is similar to `O_RSYNC` in POSIX.
          ///
          /// The precise semantics of this operation have not yet been defined for
          /// WASI. At this time, it should be interpreted as a request, and not a
          /// requirement.
          const REQUESTED_WRITE_SYNC = 1 << 4;
          /// Mutating directories mode: Directory contents may be mutated.
          ///
          /// When this flag is unset on a descriptor, operations using the
          /// descriptor which would create, rename, delete, modify the data or
          /// metadata of filesystem objects, or obtain another handle which
          /// would permit any of those, shall fail with `error-code::read-only` if
          /// they would otherwise succeed.
          ///
          /// This may only be set on directories.
          const MUTATE_DIRECTORY = 1 << 5;
        }
      }
      wit_bindgen::rt::bitflags::bitflags! {
        /// Flags determining the method of how paths are resolved.
        #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
        pub struct PathFlags: u8 {
          /// As long as the resolved path corresponds to a symbolic link, it is
          /// expanded.
          const SYMLINK_FOLLOW = 1 << 0;
        }
      }
      wit_bindgen::rt::bitflags::bitflags! {
        /// Open flags used by `open-at`.
        #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
        pub struct OpenFlags: u8 {
          /// Create file if it does not exist, similar to `O_CREAT` in POSIX.
          const CREATE = 1 << 0;
          /// Fail if not a directory, similar to `O_DIRECTORY` in POSIX.
          const DIRECTORY = 1 << 1;
          /// Fail if file already exists, similar to `O_EXCL` in POSIX.
          const EXCLUSIVE = 1 << 2;
          /// Truncate file to size 0, similar to `O_TRUNC` in POSIX.
          const TRUNCATE = 1 << 3;
        }
      }
      /// Number of hard links to an inode.
      pub type LinkCount = u64;
      /// File attributes.
      ///
      /// Note: This was called `filestat` in earlier versions of WASI.
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct DescriptorStat {
        /// File type.
        pub type_: DescriptorType,
        /// Number of hard links to the file.
        pub link_count: LinkCount,
        /// For regular files, the file size in bytes. For symbolic links, the
        /// length in bytes of the pathname contained in the symbolic link.
        pub size: Filesize,
        /// Last data access timestamp.
        ///
        /// If the `option` is none, the platform doesn't maintain an access
        /// timestamp for this file.
        pub data_access_timestamp: Option<Datetime>,
        /// Last data modification timestamp.
        ///
        /// If the `option` is none, the platform doesn't maintain a
        /// modification timestamp for this file.
        pub data_modification_timestamp: Option<Datetime>,
        /// Last file status-change timestamp.
        ///
        /// If the `option` is none, the platform doesn't maintain a
        /// status-change timestamp for this file.
        pub status_change_timestamp: Option<Datetime>,
      }
      impl ::core::fmt::Debug for DescriptorStat {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DescriptorStat").field("type", &self.type_).field("link-count", &self.link_count).field("size", &self.size).field("data-access-timestamp", &self.data_access_timestamp).field("data-modification-timestamp", &self.data_modification_timestamp).field("status-change-timestamp", &self.status_change_timestamp).finish()
        }
      }
      /// When setting a timestamp, this gives the value to set it to.
      #[derive(Clone, Copy)]
      pub enum NewTimestamp {
        /// Leave the timestamp set to its previous value.
        NoChange,
        /// Set the timestamp to the current time of the system clock associated
        /// with the filesystem.
        Now,
        /// Set the timestamp to the given value.
        Timestamp(Datetime),
      }
      impl ::core::fmt::Debug for NewTimestamp {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            NewTimestamp::NoChange => {
              f.debug_tuple("NewTimestamp::NoChange").finish()
            }
            NewTimestamp::Now => {
              f.debug_tuple("NewTimestamp::Now").finish()
            }
            NewTimestamp::Timestamp(e) => {
              f.debug_tuple("NewTimestamp::Timestamp").field(e).finish()
            }
          }
        }
      }
      /// A directory entry.
      #[derive(Clone)]
      pub struct DirectoryEntry {
        /// The type of the file referred to by this directory entry.
        pub type_: DescriptorType,
        /// The name of the object.
        pub name: _rt::String,
      }
      impl ::core::fmt::Debug for DirectoryEntry {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DirectoryEntry").field("type", &self.type_).field("name", &self.name).finish()
        }
      }
      /// Error codes returned by functions, similar to `errno` in POSIX.
      /// Not all of these error codes are returned by the functions provided by this
      /// API; some are used in higher-level library layers, and others are provided
      /// merely for alignment with POSIX.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum ErrorCode {
        /// Permission denied, similar to `EACCES` in POSIX.
        Access,
        /// Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX.
        WouldBlock,
        /// Connection already in progress, similar to `EALREADY` in POSIX.
        Already,
        /// Bad descriptor, similar to `EBADF` in POSIX.
        BadDescriptor,
        /// Device or resource busy, similar to `EBUSY` in POSIX.
        Busy,
        /// Resource deadlock would occur, similar to `EDEADLK` in POSIX.
        Deadlock,
        /// Storage quota exceeded, similar to `EDQUOT` in POSIX.
        Quota,
        /// File exists, similar to `EEXIST` in POSIX.
        Exist,
        /// File too large, similar to `EFBIG` in POSIX.
        FileTooLarge,
        /// Illegal byte sequence, similar to `EILSEQ` in POSIX.
        IllegalByteSequence,
        /// Operation in progress, similar to `EINPROGRESS` in POSIX.
        InProgress,
        /// Interrupted function, similar to `EINTR` in POSIX.
        Interrupted,
        /// Invalid argument, similar to `EINVAL` in POSIX.
        Invalid,
        /// I/O error, similar to `EIO` in POSIX.
        Io,
        /// Is a directory, similar to `EISDIR` in POSIX.
        IsDirectory,
        /// Too many levels of symbolic links, similar to `ELOOP` in POSIX.
        Loop,
        /// Too many links, similar to `EMLINK` in POSIX.
        TooManyLinks,
        /// Message too large, similar to `EMSGSIZE` in POSIX.
        MessageSize,
        /// Filename too long, similar to `ENAMETOOLONG` in POSIX.
        NameTooLong,
        /// No such device, similar to `ENODEV` in POSIX.
        NoDevice,
        /// No such file or directory, similar to `ENOENT` in POSIX.
        NoEntry,
        /// No locks available, similar to `ENOLCK` in POSIX.
        NoLock,
        /// Not enough space, similar to `ENOMEM` in POSIX.
        InsufficientMemory,
        /// No space left on device, similar to `ENOSPC` in POSIX.
        InsufficientSpace,
        /// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.
        NotDirectory,
        /// Directory not empty, similar to `ENOTEMPTY` in POSIX.
        NotEmpty,
        /// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.
        NotRecoverable,
        /// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.
        Unsupported,
        /// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.
        NoTty,
        /// No such device or address, similar to `ENXIO` in POSIX.
        NoSuchDevice,
        /// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.
        Overflow,
        /// Operation not permitted, similar to `EPERM` in POSIX.
        NotPermitted,
        /// Broken pipe, similar to `EPIPE` in POSIX.
        Pipe,
        /// Read-only file system, similar to `EROFS` in POSIX.
        ReadOnly,
        /// Invalid seek, similar to `ESPIPE` in POSIX.
        InvalidSeek,
        /// Text file busy, similar to `ETXTBSY` in POSIX.
        TextFileBusy,
        /// Cross-device link, similar to `EXDEV` in POSIX.
        CrossDevice,
      }
      impl ErrorCode{
        pub fn name(&self) -> &'static str {
          match self {
            ErrorCode::Access => "access",
            ErrorCode::WouldBlock => "would-block",
            ErrorCode::Already => "already",
            ErrorCode::BadDescriptor => "bad-descriptor",
            ErrorCode::Busy => "busy",
            ErrorCode::Deadlock => "deadlock",
            ErrorCode::Quota => "quota",
            ErrorCode::Exist => "exist",
            ErrorCode::FileTooLarge => "file-too-large",
            ErrorCode::IllegalByteSequence => "illegal-byte-sequence",
            ErrorCode::InProgress => "in-progress",
            ErrorCode::Interrupted => "interrupted",
            ErrorCode::Invalid => "invalid",
            ErrorCode::Io => "io",
            ErrorCode::IsDirectory => "is-directory",
            ErrorCode::Loop => "loop",
            ErrorCode::TooManyLinks => "too-many-links",
            ErrorCode::MessageSize => "message-size",
            ErrorCode::NameTooLong => "name-too-long",
            ErrorCode::NoDevice => "no-device",
            ErrorCode::NoEntry => "no-entry",
            ErrorCode::NoLock => "no-lock",
            ErrorCode::InsufficientMemory => "insufficient-memory",
            ErrorCode::InsufficientSpace => "insufficient-space",
            ErrorCode::NotDirectory => "not-directory",
            ErrorCode::NotEmpty => "not-empty",
            ErrorCode::NotRecoverable => "not-recoverable",
            ErrorCode::Unsupported => "unsupported",
            ErrorCode::NoTty => "no-tty",
            ErrorCode::NoSuchDevice => "no-such-device",
            ErrorCode::Overflow => "overflow",
            ErrorCode::NotPermitted => "not-permitted",
            ErrorCode::Pipe => "pipe",
            ErrorCode::ReadOnly => "read-only",
            ErrorCode::InvalidSeek => "invalid-seek",
            ErrorCode::TextFileBusy => "text-file-busy",
            ErrorCode::CrossDevice => "cross-device",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            ErrorCode::Access => "Permission denied, similar to `EACCES` in POSIX.",
            ErrorCode::WouldBlock => "Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX.",
            ErrorCode::Already => "Connection already in progress, similar to `EALREADY` in POSIX.",
            ErrorCode::BadDescriptor => "Bad descriptor, similar to `EBADF` in POSIX.",
            ErrorCode::Busy => "Device or resource busy, similar to `EBUSY` in POSIX.",
            ErrorCode::Deadlock => "Resource deadlock would occur, similar to `EDEADLK` in POSIX.",
            ErrorCode::Quota => "Storage quota exceeded, similar to `EDQUOT` in POSIX.",
            ErrorCode::Exist => "File exists, similar to `EEXIST` in POSIX.",
            ErrorCode::FileTooLarge => "File too large, similar to `EFBIG` in POSIX.",
            ErrorCode::IllegalByteSequence => "Illegal byte sequence, similar to `EILSEQ` in POSIX.",
            ErrorCode::InProgress => "Operation in progress, similar to `EINPROGRESS` in POSIX.",
            ErrorCode::Interrupted => "Interrupted function, similar to `EINTR` in POSIX.",
            ErrorCode::Invalid => "Invalid argument, similar to `EINVAL` in POSIX.",
            ErrorCode::Io => "I/O error, similar to `EIO` in POSIX.",
            ErrorCode::IsDirectory => "Is a directory, similar to `EISDIR` in POSIX.",
            ErrorCode::Loop => "Too many levels of symbolic links, similar to `ELOOP` in POSIX.",
            ErrorCode::TooManyLinks => "Too many links, similar to `EMLINK` in POSIX.",
            ErrorCode::MessageSize => "Message too large, similar to `EMSGSIZE` in POSIX.",
            ErrorCode::NameTooLong => "Filename too long, similar to `ENAMETOOLONG` in POSIX.",
            ErrorCode::NoDevice => "No such device, similar to `ENODEV` in POSIX.",
            ErrorCode::NoEntry => "No such file or directory, similar to `ENOENT` in POSIX.",
            ErrorCode::NoLock => "No locks available, similar to `ENOLCK` in POSIX.",
            ErrorCode::InsufficientMemory => "Not enough space, similar to `ENOMEM` in POSIX.",
            ErrorCode::InsufficientSpace => "No space left on device, similar to `ENOSPC` in POSIX.",
            ErrorCode::NotDirectory => "Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.",
            ErrorCode::NotEmpty => "Directory not empty, similar to `ENOTEMPTY` in POSIX.",
            ErrorCode::NotRecoverable => "State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.",
            ErrorCode::Unsupported => "Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.",
            ErrorCode::NoTty => "Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.",
            ErrorCode::NoSuchDevice => "No such device or address, similar to `ENXIO` in POSIX.",
            ErrorCode::Overflow => "Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.",
            ErrorCode::NotPermitted => "Operation not permitted, similar to `EPERM` in POSIX.",
            ErrorCode::Pipe => "Broken pipe, similar to `EPIPE` in POSIX.",
            ErrorCode::ReadOnly => "Read-only file system, similar to `EROFS` in POSIX.",
            ErrorCode::InvalidSeek => "Invalid seek, similar to `ESPIPE` in POSIX.",
            ErrorCode::TextFileBusy => "Text file busy, similar to `ETXTBSY` in POSIX.",
            ErrorCode::CrossDevice => "Cross-device link, similar to `EXDEV` in POSIX.",
          }
        }
      }
      impl ::core::fmt::Debug for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ErrorCode")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl std::error::Error for ErrorCode {}

      impl ErrorCode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ErrorCode{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => ErrorCode::Access,
            1 => ErrorCode::WouldBlock,
            2 => ErrorCode::Already,
            3 => ErrorCode::BadDescriptor,
            4 => ErrorCode::Busy,
            5 => ErrorCode::Deadlock,
            6 => ErrorCode::Quota,
            7 => ErrorCode::Exist,
            8 => ErrorCode::FileTooLarge,
            9 => ErrorCode::IllegalByteSequence,
            10 => ErrorCode::InProgress,
            11 => ErrorCode::Interrupted,
            12 => ErrorCode::Invalid,
            13 => ErrorCode::Io,
            14 => ErrorCode::IsDirectory,
            15 => ErrorCode::Loop,
            16 => ErrorCode::TooManyLinks,
            17 => ErrorCode::MessageSize,
            18 => ErrorCode::NameTooLong,
            19 => ErrorCode::NoDevice,
            20 => ErrorCode::NoEntry,
            21 => ErrorCode::NoLock,
            22 => ErrorCode::InsufficientMemory,
            23 => ErrorCode::InsufficientSpace,
            24 => ErrorCode::NotDirectory,
            25 => ErrorCode::NotEmpty,
            26 => ErrorCode::NotRecoverable,
            27 => ErrorCode::Unsupported,
            28 => ErrorCode::NoTty,
            29 => ErrorCode::NoSuchDevice,
            30 => ErrorCode::Overflow,
            31 => ErrorCode::NotPermitted,
            32 => ErrorCode::Pipe,
            33 => ErrorCode::ReadOnly,
            34 => ErrorCode::InvalidSeek,
            35 => ErrorCode::TextFileBusy,
            36 => ErrorCode::CrossDevice,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// File or memory access pattern advisory information.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum Advice {
        /// The application has no advice to give on its behavior with respect
        /// to the specified data.
        Normal,
        /// The application expects to access the specified data sequentially
        /// from lower offsets to higher offsets.
        Sequential,
        /// The application expects to access the specified data in a random
        /// order.
        Random,
        /// The application expects to access the specified data in the near
        /// future.
        WillNeed,
        /// The application expects that it will not access the specified data
        /// in the near future.
        DontNeed,
        /// The application expects to access the specified data once and then
        /// not reuse it thereafter.
        NoReuse,
      }
      impl ::core::fmt::Debug for Advice {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Advice::Normal => {
              f.debug_tuple("Advice::Normal").finish()
            }
            Advice::Sequential => {
              f.debug_tuple("Advice::Sequential").finish()
            }
            Advice::Random => {
              f.debug_tuple("Advice::Random").finish()
            }
            Advice::WillNeed => {
              f.debug_tuple("Advice::WillNeed").finish()
            }
            Advice::DontNeed => {
              f.debug_tuple("Advice::DontNeed").finish()
            }
            Advice::NoReuse => {
              f.debug_tuple("Advice::NoReuse").finish()
            }
          }
        }
      }

      impl Advice{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> Advice{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }

          match val {
            0 => Advice::Normal,
            1 => Advice::Sequential,
            2 => Advice::Random,
            3 => Advice::WillNeed,
            4 => Advice::DontNeed,
            5 => Advice::NoReuse,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// A 128-bit hash value, split into parts because wasm doesn't have a
      /// 128-bit integer type.
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct MetadataHashValue {
        /// 64 bits of a 128-bit hash value.
        pub lower: u64,
        /// Another 64 bits of a 128-bit hash value.
        pub upper: u64,
      }
      impl ::core::fmt::Debug for MetadataHashValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("MetadataHashValue").field("lower", &self.lower).field("upper", &self.upper).finish()
        }
      }
      /// A descriptor is a reference to a filesystem object, which may be a file,
      /// directory, named pipe, special file, or other object on which filesystem
      /// calls may be made.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Descriptor{
        handle: _rt::Resource<Descriptor>,
      }

      impl Descriptor{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for Descriptor{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]descriptor"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// A stream of directory entries.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct DirectoryEntryStream{
        handle: _rt::Resource<DirectoryEntryStream>,
      }

      impl DirectoryEntryStream{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for DirectoryEntryStream{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]directory-entry-stream"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return a stream for reading from a file, if available.
        ///
        /// May fail with an error-code describing why the file cannot be read.
        ///
        /// Multiple read, write, and append streams may be active on the same open
        /// file and they do not interfere with each other.
        ///
        /// Note: This allows using `read-stream`, which is similar to `read` in POSIX.
        pub fn read_via_stream(&self,offset: Filesize,) -> Result<InputStream,ErrorCode>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.read-via-stream"]
              fn wit_import(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(offset), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  super::super::super::wasi::io::streams::InputStream::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return a stream for writing to a file, if available.
        ///
        /// May fail with an error-code describing why the file cannot be written.
        ///
        /// Note: This allows using `write-stream`, which is similar to `write` in
        /// POSIX.
        pub fn write_via_stream(&self,offset: Filesize,) -> Result<OutputStream,ErrorCode>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.write-via-stream"]
              fn wit_import(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(offset), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  super::super::super::wasi::io::streams::OutputStream::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return a stream for appending to a file, if available.
        ///
        /// May fail with an error-code describing why the file cannot be appended.
        ///
        /// Note: This allows using `write-stream`, which is similar to `write` with
        /// `O_APPEND` in in POSIX.
        pub fn append_via_stream(&self,) -> Result<OutputStream,ErrorCode>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.append-via-stream"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  super::super::super::wasi::io::streams::OutputStream::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Provide file advisory information on a descriptor.
        ///
        /// This is similar to `posix_fadvise` in POSIX.
        pub fn advise(&self,offset: Filesize,length: Filesize,advice: Advice,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.advise"]
              fn wit_import(_: i32, _: i64, _: i64, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i64, _: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(offset), _rt::as_i64(length), advice.clone() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l2 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Synchronize the data of a file to disk.
        ///
        /// This function succeeds with no effect if the file descriptor is not
        /// opened for writing.
        ///
        /// Note: This is similar to `fdatasync` in POSIX.
        pub fn sync_data(&self,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.sync-data"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l2 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Get flags associated with a descriptor.
        ///
        /// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
        ///
        /// Note: This returns the value that was the `fs_flags` value returned
        /// from `fdstat_get` in earlier versions of WASI.
        pub fn get_flags(&self,) -> Result<DescriptorFlags,ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.get-flags"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(1).cast::<u8>());

                  DescriptorFlags::empty() | DescriptorFlags::from_bits_retain(((l2 as u8) << 0) as _)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the dynamic type of a descriptor.
        ///
        /// Note: This returns the same value as the `type` field of the `fd-stat`
        /// returned by `stat`, `stat-at` and similar.
        ///
        /// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
        /// by `fstat` in POSIX.
        ///
        /// Note: This returns the value that was the `fs_filetype` value returned
        /// from `fdstat_get` in earlier versions of WASI.
        pub fn get_type(&self,) -> Result<DescriptorType,ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.get-type"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(1).cast::<u8>());

                  DescriptorType::_lift(l2 as u8)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Adjust the size of an open file. If this increases the file's size, the
        /// extra bytes are filled with zeros.
        ///
        /// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
        pub fn set_size(&self,size: Filesize,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.set-size"]
              fn wit_import(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(size), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l2 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Adjust the timestamps of an open file or directory.
        ///
        /// Note: This is similar to `futimens` in POSIX.
        ///
        /// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
        pub fn set_times(&self,data_access_timestamp: NewTimestamp,data_modification_timestamp: NewTimestamp,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let (result1_0,result1_1,result1_2,) = match data_access_timestamp {
              NewTimestamp::NoChange=> {
                (0i32, 0i64, 0i32)
              }
              NewTimestamp::Now=> {
                (1i32, 0i64, 0i32)
              }
              NewTimestamp::Timestamp(e) => {
                let super::super::super::wasi::clocks::wall_clock::Datetime{ seconds:seconds0, nanoseconds:nanoseconds0, } = e;

                (2i32, _rt::as_i64(seconds0), _rt::as_i32(nanoseconds0))
              },
            };
            let (result3_0,result3_1,result3_2,) = match data_modification_timestamp {
              NewTimestamp::NoChange=> {
                (0i32, 0i64, 0i32)
              }
              NewTimestamp::Now=> {
                (1i32, 0i64, 0i32)
              }
              NewTimestamp::Timestamp(e) => {
                let super::super::super::wasi::clocks::wall_clock::Datetime{ seconds:seconds2, nanoseconds:nanoseconds2, } = e;

                (2i32, _rt::as_i64(seconds2), _rt::as_i32(nanoseconds2))
              },
            };
            let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.set-times"]
              fn wit_import(_: i32, _: i32, _: i64, _: i32, _: i32, _: i64, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i64, _: i32, _: i32, _: i64, _: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, result1_0, result1_1, result1_2, result3_0, result3_1, result3_2, ptr4);
            let l5 = i32::from(*ptr4.add(0).cast::<u8>());
            match l5 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*ptr4.add(1).cast::<u8>());

                  ErrorCode::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Read from a descriptor, without using and updating the descriptor's offset.
        ///
        /// This function returns a list of bytes containing the data that was
        /// read, along with a bool which, when true, indicates that the end of the
        /// file was reached. The returned list will contain up to `length` bytes; it
        /// may return fewer than requested, if the end of the file is reached or
        /// if the I/O operation is interrupted.
        ///
        /// In the future, this may change to return a `stream<u8, error-code>`.
        ///
        /// Note: This is similar to `pread` in POSIX.
        pub fn read(&self,length: Filesize,offset: Filesize,) -> Result<(_rt::Vec::<u8>,bool,),ErrorCode>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.read"]
              fn wit_import(_: i32, _: i64, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(length), _rt::as_i64(offset), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let len4 = l3;
                  let l5 = i32::from(*ptr0.add(12).cast::<u8>());

                  (_rt::Vec::from_raw_parts(l2.cast(), len4, len4), _rt::bool_lift(l5 as u8))
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Write to a descriptor, without using and updating the descriptor's offset.
        ///
        /// It is valid to write past the end of a file; the file is extended to the
        /// extent of the write, with bytes between the previous end and the start of
        /// the write set to zero.
        ///
        /// In the future, this may change to take a `stream<u8, error-code>`.
        ///
        /// Note: This is similar to `pwrite` in POSIX.
        pub fn write(&self,buffer: &[u8],offset: Filesize,) -> Result<Filesize,ErrorCode>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let vec0 = buffer;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.write"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, _rt::as_i64(offset), ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = {
                  let l3 = *ptr1.add(8).cast::<i64>();

                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr1.add(8).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Read directory entries from a directory.
        ///
        /// On filesystems where directories contain entries referring to themselves
        /// and their parents, often named `.` and `..` respectively, these entries
        /// are omitted.
        ///
        /// This always returns a new stream which starts at the beginning of the
        /// directory. Multiple streams may be active on the same directory, and they
        /// do not interfere with each other.
        pub fn read_directory(&self,) -> Result<DirectoryEntryStream,ErrorCode>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.read-directory"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  DirectoryEntryStream::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Synchronize the data and metadata of a file to disk.
        ///
        /// This function succeeds with no effect if the file descriptor is not
        /// opened for writing.
        ///
        /// Note: This is similar to `fsync` in POSIX.
        pub fn sync(&self,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.sync"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(1).cast::<u8>());

                  ErrorCode::_lift(l2 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a directory.
        ///
        /// Note: This is similar to `mkdirat` in POSIX.
        pub fn create_directory_at(&self,path: &str,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.create-directory-at"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr1.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return the attributes of an open file or directory.
        ///
        /// Note: This is similar to `fstat` in POSIX, except that it does not return
        /// device and inode information. For testing whether two descriptors refer to
        /// the same underlying filesystem object, use `is-same-object`. To obtain
        /// additional data that can be used do determine whether a file has been
        /// modified, use `metadata-hash`.
        ///
        /// Note: This was called `fd_filestat_get` in earlier versions of WASI.
        pub fn stat(&self,) -> Result<DescriptorStat,ErrorCode>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 104]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 104]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.stat"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(8).cast::<u8>());
                  let l3 = *ptr0.add(16).cast::<i64>();
                  let l4 = *ptr0.add(24).cast::<i64>();
                  let l5 = i32::from(*ptr0.add(32).cast::<u8>());
                  let l8 = i32::from(*ptr0.add(56).cast::<u8>());
                  let l11 = i32::from(*ptr0.add(80).cast::<u8>());

                  DescriptorStat{
                    type_: DescriptorType::_lift(l2 as u8),
                    link_count: l3 as u64,
                    size: l4 as u64,
                    data_access_timestamp: match l5 {
                      0 => None,
                      1 => {
                        let e = {
                          let l6 = *ptr0.add(40).cast::<i64>();
                          let l7 = *ptr0.add(48).cast::<i32>();

                          super::super::super::wasi::clocks::wall_clock::Datetime{
                            seconds: l6 as u64,
                            nanoseconds: l7 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    data_modification_timestamp: match l8 {
                      0 => None,
                      1 => {
                        let e = {
                          let l9 = *ptr0.add(64).cast::<i64>();
                          let l10 = *ptr0.add(72).cast::<i32>();

                          super::super::super::wasi::clocks::wall_clock::Datetime{
                            seconds: l9 as u64,
                            nanoseconds: l10 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    status_change_timestamp: match l11 {
                      0 => None,
                      1 => {
                        let e = {
                          let l12 = *ptr0.add(88).cast::<i64>();
                          let l13 = *ptr0.add(96).cast::<i32>();

                          super::super::super::wasi::clocks::wall_clock::Datetime{
                            seconds: l12 as u64,
                            nanoseconds: l13 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l14 = i32::from(*ptr0.add(8).cast::<u8>());

                  ErrorCode::_lift(l14 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return the attributes of a file or directory.
        ///
        /// Note: This is similar to `fstatat` in POSIX, except that it does not
        /// return device and inode information. See the `stat` description for a
        /// discussion of alternatives.
        ///
        /// Note: This was called `path_filestat_get` in earlier versions of WASI.
        pub fn stat_at(&self,path_flags: PathFlags,path: &str,) -> Result<DescriptorStat,ErrorCode>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 104]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 104]);
            let flags0 = path_flags;
            let vec1 = path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.stat-at"]
              fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1, ptr2);
            let l3 = i32::from(*ptr2.add(0).cast::<u8>());
            match l3 {
              0 => {
                let e = {
                  let l4 = i32::from(*ptr2.add(8).cast::<u8>());
                  let l5 = *ptr2.add(16).cast::<i64>();
                  let l6 = *ptr2.add(24).cast::<i64>();
                  let l7 = i32::from(*ptr2.add(32).cast::<u8>());
                  let l10 = i32::from(*ptr2.add(56).cast::<u8>());
                  let l13 = i32::from(*ptr2.add(80).cast::<u8>());

                  DescriptorStat{
                    type_: DescriptorType::_lift(l4 as u8),
                    link_count: l5 as u64,
                    size: l6 as u64,
                    data_access_timestamp: match l7 {
                      0 => None,
                      1 => {
                        let e = {
                          let l8 = *ptr2.add(40).cast::<i64>();
                          let l9 = *ptr2.add(48).cast::<i32>();

                          super::super::super::wasi::clocks::wall_clock::Datetime{
                            seconds: l8 as u64,
                            nanoseconds: l9 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    data_modification_timestamp: match l10 {
                      0 => None,
                      1 => {
                        let e = {
                          let l11 = *ptr2.add(64).cast::<i64>();
                          let l12 = *ptr2.add(72).cast::<i32>();

                          super::super::super::wasi::clocks::wall_clock::Datetime{
                            seconds: l11 as u64,
                            nanoseconds: l12 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    status_change_timestamp: match l13 {
                      0 => None,
                      1 => {
                        let e = {
                          let l14 = *ptr2.add(88).cast::<i64>();
                          let l15 = *ptr2.add(96).cast::<i32>();

                          super::super::super::wasi::clocks::wall_clock::Datetime{
                            seconds: l14 as u64,
                            nanoseconds: l15 as u32,
                          }
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l16 = i32::from(*ptr2.add(8).cast::<u8>());

                  ErrorCode::_lift(l16 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Adjust the timestamps of a file or directory.
        ///
        /// Note: This is similar to `utimensat` in POSIX.
        ///
        /// Note: This was called `path_filestat_set_times` in earlier versions of
        /// WASI.
        pub fn set_times_at(&self,path_flags: PathFlags,path: &str,data_access_timestamp: NewTimestamp,data_modification_timestamp: NewTimestamp,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let flags0 = path_flags;
            let vec1 = path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let (result3_0,result3_1,result3_2,) = match data_access_timestamp {
              NewTimestamp::NoChange=> {
                (0i32, 0i64, 0i32)
              }
              NewTimestamp::Now=> {
                (1i32, 0i64, 0i32)
              }
              NewTimestamp::Timestamp(e) => {
                let super::super::super::wasi::clocks::wall_clock::Datetime{ seconds:seconds2, nanoseconds:nanoseconds2, } = e;

                (2i32, _rt::as_i64(seconds2), _rt::as_i32(nanoseconds2))
              },
            };
            let (result5_0,result5_1,result5_2,) = match data_modification_timestamp {
              NewTimestamp::NoChange=> {
                (0i32, 0i64, 0i32)
              }
              NewTimestamp::Now=> {
                (1i32, 0i64, 0i32)
              }
              NewTimestamp::Timestamp(e) => {
                let super::super::super::wasi::clocks::wall_clock::Datetime{ seconds:seconds4, nanoseconds:nanoseconds4, } = e;

                (2i32, _rt::as_i64(seconds4), _rt::as_i32(nanoseconds4))
              },
            };
            let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.set-times-at"]
              fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i32, _: i64, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i32, _: i64, _: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1, result3_0, result3_1, result3_2, result5_0, result5_1, result5_2, ptr6);
            let l7 = i32::from(*ptr6.add(0).cast::<u8>());
            match l7 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l8 = i32::from(*ptr6.add(1).cast::<u8>());

                  ErrorCode::_lift(l8 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a hard link.
        ///
        /// Note: This is similar to `linkat` in POSIX.
        pub fn link_at(&self,old_path_flags: PathFlags,old_path: &str,new_descriptor: &Descriptor,new_path: &str,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let flags0 = old_path_flags;
            let vec1 = old_path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let vec2 = new_path;
            let ptr2 = vec2.as_ptr().cast::<u8>();
            let len2 = vec2.len();
            let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.link-at"]
              fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1, (new_descriptor).handle() as i32, ptr2.cast_mut(), len2, ptr3);
            let l4 = i32::from(*ptr3.add(0).cast::<u8>());
            match l4 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*ptr3.add(1).cast::<u8>());

                  ErrorCode::_lift(l5 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Open a file or directory.
        ///
        /// The returned descriptor is not guaranteed to be the lowest-numbered
        /// descriptor not currently open/ it is randomized to prevent applications
        /// from depending on making assumptions about indexes, since this is
        /// error-prone in multi-threaded contexts. The returned descriptor is
        /// guaranteed to be less than 2**31.
        ///
        /// If `flags` contains `descriptor-flags::mutate-directory`, and the base
        /// descriptor doesn't have `descriptor-flags::mutate-directory` set,
        /// `open-at` fails with `error-code::read-only`.
        ///
        /// If `flags` contains `write` or `mutate-directory`, or `open-flags`
        /// contains `truncate` or `create`, and the base descriptor doesn't have
        /// `descriptor-flags::mutate-directory` set, `open-at` fails with
        /// `error-code::read-only`.
        ///
        /// Note: This is similar to `openat` in POSIX.
        pub fn open_at(&self,path_flags: PathFlags,path: &str,open_flags: OpenFlags,flags: DescriptorFlags,) -> Result<Descriptor,ErrorCode>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let flags0 = path_flags;
            let vec1 = path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let flags2 = open_flags;
            let flags3 = flags;
            let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.open-at"]
              fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1, (flags2.bits() >> 0) as i32, (flags3.bits() >> 0) as i32, ptr4);
            let l5 = i32::from(*ptr4.add(0).cast::<u8>());
            match l5 {
              0 => {
                let e = {
                  let l6 = *ptr4.add(4).cast::<i32>();

                  Descriptor::from_handle(l6 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l7 = i32::from(*ptr4.add(4).cast::<u8>());

                  ErrorCode::_lift(l7 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Read the contents of a symbolic link.
        ///
        /// If the contents contain an absolute or rooted path in the underlying
        /// filesystem, this function fails with `error-code::not-permitted`.
        ///
        /// Note: This is similar to `readlinkat` in POSIX.
        pub fn readlink_at(&self,path: &str,) -> Result<_rt::String,ErrorCode>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let vec0 = path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.readlink-at"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = {
                  let l3 = *ptr1.add(4).cast::<*mut u8>();
                  let l4 = *ptr1.add(8).cast::<usize>();
                  let len5 = l4;
                  let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

                  _rt::string_lift(bytes5)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*ptr1.add(4).cast::<u8>());

                  ErrorCode::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Remove a directory.
        ///
        /// Return `error-code::not-empty` if the directory is not empty.
        ///
        /// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
        pub fn remove_directory_at(&self,path: &str,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.remove-directory-at"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr1.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Rename a filesystem object.
        ///
        /// Note: This is similar to `renameat` in POSIX.
        pub fn rename_at(&self,old_path: &str,new_descriptor: &Descriptor,new_path: &str,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = old_path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let vec1 = new_path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.rename-at"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, (new_descriptor).handle() as i32, ptr1.cast_mut(), len1, ptr2);
            let l3 = i32::from(*ptr2.add(0).cast::<u8>());
            match l3 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr2.add(1).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a symbolic link (also known as a "symlink").
        ///
        /// If `old-path` starts with `/`, the function fails with
        /// `error-code::not-permitted`.
        ///
        /// Note: This is similar to `symlinkat` in POSIX.
        pub fn symlink_at(&self,old_path: &str,new_path: &str,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = old_path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let vec1 = new_path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.symlink-at"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
            let l3 = i32::from(*ptr2.add(0).cast::<u8>());
            match l3 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr2.add(1).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Unlink a filesystem object that is not a directory.
        ///
        /// Return `error-code::is-directory` if the path refers to a directory.
        /// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
        pub fn unlink_file_at(&self,path: &str,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = path;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.unlink-file-at"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr1.add(1).cast::<u8>());

                  ErrorCode::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Test whether two descriptors refer to the same filesystem object.
        ///
        /// In POSIX, this corresponds to testing whether the two descriptors have the
        /// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
        /// wasi-filesystem does not expose device and inode numbers, so this function
        /// may be used instead.
        pub fn is_same_object(&self,other: &Descriptor,) -> bool{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.is-same-object"]
              fn wit_import(_: i32, _: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, (other).handle() as i32);
            _rt::bool_lift(ret as u8)
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return a hash of the metadata associated with a filesystem object referred
        /// to by a descriptor.
        ///
        /// This returns a hash of the last-modification timestamp and file size, and
        /// may also include the inode number, device number, birth timestamp, and
        /// other metadata fields that may change when the file is modified or
        /// replaced. It may also include a secret value chosen by the
        /// implementation and not otherwise exposed.
        ///
        /// Implementations are encourated to provide the following properties:
        ///
        /// - If the file is not modified or replaced, the computed hash value should
        /// usually not change.
        /// - If the object is modified or replaced, the computed hash value should
        /// usually change.
        /// - The inputs to the hash should not be easily computable from the
        /// computed hash.
        ///
        /// However, none of these is required.
        pub fn metadata_hash(&self,) -> Result<MetadataHashValue,ErrorCode>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.metadata-hash"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();
                  let l3 = *ptr0.add(16).cast::<i64>();

                  MetadataHashValue{
                    lower: l2 as u64,
                    upper: l3 as u64,
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u8>());

                  ErrorCode::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Descriptor {
        #[allow(unused_unsafe, clippy::all)]
        /// Return a hash of the metadata associated with a filesystem object referred
        /// to by a directory descriptor and a relative path.
        ///
        /// This performs the same hash computation as `metadata-hash`.
        pub fn metadata_hash_at(&self,path_flags: PathFlags,path: &str,) -> Result<MetadataHashValue,ErrorCode>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            let flags0 = path_flags;
            let vec1 = path;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]descriptor.metadata-hash-at"]
              fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, (flags0.bits() >> 0) as i32, ptr1.cast_mut(), len1, ptr2);
            let l3 = i32::from(*ptr2.add(0).cast::<u8>());
            match l3 {
              0 => {
                let e = {
                  let l4 = *ptr2.add(8).cast::<i64>();
                  let l5 = *ptr2.add(16).cast::<i64>();

                  MetadataHashValue{
                    lower: l4 as u64,
                    upper: l5 as u64,
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*ptr2.add(8).cast::<u8>());

                  ErrorCode::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DirectoryEntryStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Read a single directory entry from a `directory-entry-stream`.
        pub fn read_directory_entry(&self,) -> Result<Option<DirectoryEntry>,ErrorCode>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 20]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]directory-entry-stream.read-directory-entry"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(4).cast::<u8>());

                  match l2 {
                    0 => None,
                    1 => {
                      let e = {
                        let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                        let l4 = *ptr0.add(12).cast::<*mut u8>();
                        let l5 = *ptr0.add(16).cast::<usize>();
                        let len6 = l5;
                        let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                        DirectoryEntry{
                          type_: DescriptorType::_lift(l3 as u8),
                          name: _rt::string_lift(bytes6),
                        }
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l7 = i32::from(*ptr0.add(4).cast::<u8>());

                  ErrorCode::_lift(l7 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Attempts to extract a filesystem-related `error-code` from the stream
      /// `error` provided.
      ///
      /// Stream operations which return `stream-error::last-operation-failed`
      /// have a payload with more information about the operation that failed.
      /// This payload can be passed through to this function to see if there's
      /// filesystem-related information about the error to return.
      ///
      /// Note that this function is fallible because not all stream-related
      /// errors are filesystem-related errors.
      pub fn filesystem_error_code(err: &Error,) -> Option<ErrorCode>{
        unsafe {
          #[repr(align(1))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/types@0.2.0")]
          extern "C" {
            #[link_name = "filesystem-error-code"]
            fn wit_import(_: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
          wit_import((err).handle() as i32, ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => None,
            1 => {
              let e = {
                let l2 = i32::from(*ptr0.add(1).cast::<u8>());

                ErrorCode::_lift(l2 as u8)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod preopens {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Descriptor = super::super::super::wasi::filesystem::types::Descriptor;
      #[allow(unused_unsafe, clippy::all)]
      /// Return the set of preopened directories, and their path.
      pub fn get_directories() -> _rt::Vec::<(Descriptor,_rt::String,)>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:filesystem/preopens@0.2.0")]
          extern "C" {
            #[link_name = "get-directories"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = *ptr0.add(0).cast::<*mut u8>();
          let l2 = *ptr0.add(4).cast::<usize>();
          let base7 = l1;
          let len7 = l2;
          let mut result7 = _rt::Vec::with_capacity(len7);
          for i in 0..len7 {
            let base = base7.add(i * 12);
            let e7 = {
              let l3 = *base.add(0).cast::<i32>();
              let l4 = *base.add(4).cast::<*mut u8>();
              let l5 = *base.add(8).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

              (super::super::super::wasi::filesystem::types::Descriptor::from_handle(l3 as u32), _rt::string_lift(bytes6))
            };
            result7.push(e7);
          }
          _rt::cabi_dealloc(base7, len7 * 12, 4);
          result7
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod http {
    #[allow(dead_code, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Duration = super::super::super::wasi::clocks::monotonic_clock::Duration;
      pub type InputStream = super::super::super::wasi::io::streams::InputStream;
      pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
      pub type IoError = super::super::super::wasi::io::error::Error;
      /// Hermes doews not support `poll`
      /// use wasi:io/poll@0.2.0.{pollable};
      /// This type corresponds to HTTP standard Methods.
      #[derive(Clone)]
      pub enum Method {
        Get,
        Head,
        Post,
        Put,
        Delete,
        Connect,
        Options,
        Trace,
        Patch,
        Other(_rt::String),
      }
      impl ::core::fmt::Debug for Method {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Method::Get => {
              f.debug_tuple("Method::Get").finish()
            }
            Method::Head => {
              f.debug_tuple("Method::Head").finish()
            }
            Method::Post => {
              f.debug_tuple("Method::Post").finish()
            }
            Method::Put => {
              f.debug_tuple("Method::Put").finish()
            }
            Method::Delete => {
              f.debug_tuple("Method::Delete").finish()
            }
            Method::Connect => {
              f.debug_tuple("Method::Connect").finish()
            }
            Method::Options => {
              f.debug_tuple("Method::Options").finish()
            }
            Method::Trace => {
              f.debug_tuple("Method::Trace").finish()
            }
            Method::Patch => {
              f.debug_tuple("Method::Patch").finish()
            }
            Method::Other(e) => {
              f.debug_tuple("Method::Other").field(e).finish()
            }
          }
        }
      }
      /// This type corresponds to HTTP standard Related Schemes.
      #[derive(Clone)]
      pub enum Scheme {
        Http,
        Https,
        Other(_rt::String),
      }
      impl ::core::fmt::Debug for Scheme {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Scheme::Http => {
              f.debug_tuple("Scheme::Http").finish()
            }
            Scheme::Https => {
              f.debug_tuple("Scheme::Https").finish()
            }
            Scheme::Other(e) => {
              f.debug_tuple("Scheme::Other").field(e).finish()
            }
          }
        }
      }
      /// Defines the case payload type for `DNS-error` above:
      #[derive(Clone)]
      pub struct DnsErrorPayload {
        pub rcode: Option<_rt::String>,
        pub info_code: Option<u16>,
      }
      impl ::core::fmt::Debug for DnsErrorPayload {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DnsErrorPayload").field("rcode", &self.rcode).field("info-code", &self.info_code).finish()
        }
      }
      /// Defines the case payload type for `TLS-alert-received` above:
      #[derive(Clone)]
      pub struct TlsAlertReceivedPayload {
        pub alert_id: Option<u8>,
        pub alert_message: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for TlsAlertReceivedPayload {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("TlsAlertReceivedPayload").field("alert-id", &self.alert_id).field("alert-message", &self.alert_message).finish()
        }
      }
      /// Defines the case payload type for `HTTP-response-{header,trailer}-size` above:
      #[derive(Clone)]
      pub struct FieldSizePayload {
        pub field_name: Option<_rt::String>,
        pub field_size: Option<u32>,
      }
      impl ::core::fmt::Debug for FieldSizePayload {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("FieldSizePayload").field("field-name", &self.field_name).field("field-size", &self.field_size).finish()
        }
      }
      /// These cases are inspired by the IANA HTTP Proxy Error Types:
      /// https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types
      #[derive(Clone)]
      pub enum ErrorCode {
        DnsTimeout,
        DnsError(DnsErrorPayload),
        DestinationNotFound,
        DestinationUnavailable,
        DestinationIpProhibited,
        DestinationIpUnroutable,
        ConnectionRefused,
        ConnectionTerminated,
        ConnectionTimeout,
        ConnectionReadTimeout,
        ConnectionWriteTimeout,
        ConnectionLimitReached,
        TlsProtocolError,
        TlsCertificateError,
        TlsAlertReceived(TlsAlertReceivedPayload),
        HttpRequestDenied,
        HttpRequestLengthRequired,
        HttpRequestBodySize(Option<u64>),
        HttpRequestMethodInvalid,
        HttpRequestUriInvalid,
        HttpRequestUriTooLong,
        HttpRequestHeaderSectionSize(Option<u32>),
        HttpRequestHeaderSize(Option<FieldSizePayload>),
        HttpRequestTrailerSectionSize(Option<u32>),
        HttpRequestTrailerSize(FieldSizePayload),
        HttpResponseIncomplete,
        HttpResponseHeaderSectionSize(Option<u32>),
        HttpResponseHeaderSize(FieldSizePayload),
        HttpResponseBodySize(Option<u64>),
        HttpResponseTrailerSectionSize(Option<u32>),
        HttpResponseTrailerSize(FieldSizePayload),
        HttpResponseTransferCoding(Option<_rt::String>),
        HttpResponseContentCoding(Option<_rt::String>),
        HttpResponseTimeout,
        HttpUpgradeFailed,
        HttpProtocolError,
        LoopDetected,
        ConfigurationError,
        /// This is a catch-all error for anything that doesn't fit cleanly into a
        /// more specific case. It also includes an optional string for an
        /// unstructured description of the error. Users should not depend on the
        /// string for diagnosing errors, as it's not required to be consistent
        /// between implementations.
        InternalError(Option<_rt::String>),
      }
      impl ::core::fmt::Debug for ErrorCode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            ErrorCode::DnsTimeout => {
              f.debug_tuple("ErrorCode::DnsTimeout").finish()
            }
            ErrorCode::DnsError(e) => {
              f.debug_tuple("ErrorCode::DnsError").field(e).finish()
            }
            ErrorCode::DestinationNotFound => {
              f.debug_tuple("ErrorCode::DestinationNotFound").finish()
            }
            ErrorCode::DestinationUnavailable => {
              f.debug_tuple("ErrorCode::DestinationUnavailable").finish()
            }
            ErrorCode::DestinationIpProhibited => {
              f.debug_tuple("ErrorCode::DestinationIpProhibited").finish()
            }
            ErrorCode::DestinationIpUnroutable => {
              f.debug_tuple("ErrorCode::DestinationIpUnroutable").finish()
            }
            ErrorCode::ConnectionRefused => {
              f.debug_tuple("ErrorCode::ConnectionRefused").finish()
            }
            ErrorCode::ConnectionTerminated => {
              f.debug_tuple("ErrorCode::ConnectionTerminated").finish()
            }
            ErrorCode::ConnectionTimeout => {
              f.debug_tuple("ErrorCode::ConnectionTimeout").finish()
            }
            ErrorCode::ConnectionReadTimeout => {
              f.debug_tuple("ErrorCode::ConnectionReadTimeout").finish()
            }
            ErrorCode::ConnectionWriteTimeout => {
              f.debug_tuple("ErrorCode::ConnectionWriteTimeout").finish()
            }
            ErrorCode::ConnectionLimitReached => {
              f.debug_tuple("ErrorCode::ConnectionLimitReached").finish()
            }
            ErrorCode::TlsProtocolError => {
              f.debug_tuple("ErrorCode::TlsProtocolError").finish()
            }
            ErrorCode::TlsCertificateError => {
              f.debug_tuple("ErrorCode::TlsCertificateError").finish()
            }
            ErrorCode::TlsAlertReceived(e) => {
              f.debug_tuple("ErrorCode::TlsAlertReceived").field(e).finish()
            }
            ErrorCode::HttpRequestDenied => {
              f.debug_tuple("ErrorCode::HttpRequestDenied").finish()
            }
            ErrorCode::HttpRequestLengthRequired => {
              f.debug_tuple("ErrorCode::HttpRequestLengthRequired").finish()
            }
            ErrorCode::HttpRequestBodySize(e) => {
              f.debug_tuple("ErrorCode::HttpRequestBodySize").field(e).finish()
            }
            ErrorCode::HttpRequestMethodInvalid => {
              f.debug_tuple("ErrorCode::HttpRequestMethodInvalid").finish()
            }
            ErrorCode::HttpRequestUriInvalid => {
              f.debug_tuple("ErrorCode::HttpRequestUriInvalid").finish()
            }
            ErrorCode::HttpRequestUriTooLong => {
              f.debug_tuple("ErrorCode::HttpRequestUriTooLong").finish()
            }
            ErrorCode::HttpRequestHeaderSectionSize(e) => {
              f.debug_tuple("ErrorCode::HttpRequestHeaderSectionSize").field(e).finish()
            }
            ErrorCode::HttpRequestHeaderSize(e) => {
              f.debug_tuple("ErrorCode::HttpRequestHeaderSize").field(e).finish()
            }
            ErrorCode::HttpRequestTrailerSectionSize(e) => {
              f.debug_tuple("ErrorCode::HttpRequestTrailerSectionSize").field(e).finish()
            }
            ErrorCode::HttpRequestTrailerSize(e) => {
              f.debug_tuple("ErrorCode::HttpRequestTrailerSize").field(e).finish()
            }
            ErrorCode::HttpResponseIncomplete => {
              f.debug_tuple("ErrorCode::HttpResponseIncomplete").finish()
            }
            ErrorCode::HttpResponseHeaderSectionSize(e) => {
              f.debug_tuple("ErrorCode::HttpResponseHeaderSectionSize").field(e).finish()
            }
            ErrorCode::HttpResponseHeaderSize(e) => {
              f.debug_tuple("ErrorCode::HttpResponseHeaderSize").field(e).finish()
            }
            ErrorCode::HttpResponseBodySize(e) => {
              f.debug_tuple("ErrorCode::HttpResponseBodySize").field(e).finish()
            }
            ErrorCode::HttpResponseTrailerSectionSize(e) => {
              f.debug_tuple("ErrorCode::HttpResponseTrailerSectionSize").field(e).finish()
            }
            ErrorCode::HttpResponseTrailerSize(e) => {
              f.debug_tuple("ErrorCode::HttpResponseTrailerSize").field(e).finish()
            }
            ErrorCode::HttpResponseTransferCoding(e) => {
              f.debug_tuple("ErrorCode::HttpResponseTransferCoding").field(e).finish()
            }
            ErrorCode::HttpResponseContentCoding(e) => {
              f.debug_tuple("ErrorCode::HttpResponseContentCoding").field(e).finish()
            }
            ErrorCode::HttpResponseTimeout => {
              f.debug_tuple("ErrorCode::HttpResponseTimeout").finish()
            }
            ErrorCode::HttpUpgradeFailed => {
              f.debug_tuple("ErrorCode::HttpUpgradeFailed").finish()
            }
            ErrorCode::HttpProtocolError => {
              f.debug_tuple("ErrorCode::HttpProtocolError").finish()
            }
            ErrorCode::LoopDetected => {
              f.debug_tuple("ErrorCode::LoopDetected").finish()
            }
            ErrorCode::ConfigurationError => {
              f.debug_tuple("ErrorCode::ConfigurationError").finish()
            }
            ErrorCode::InternalError(e) => {
              f.debug_tuple("ErrorCode::InternalError").field(e).finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for ErrorCode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }

      impl std::error::Error for ErrorCode {}
      /// This type enumerates the different kinds of errors that may occur when
      /// setting or appending to a `fields` resource.
      #[derive(Clone, Copy)]
      pub enum HeaderError {
        /// This error indicates that a `field-key` or `field-value` was
        /// syntactically invalid when used with an operation that sets headers in a
        /// `fields`.
        InvalidSyntax,
        /// This error indicates that a forbidden `field-key` was used when trying
        /// to set a header in a `fields`.
        Forbidden,
        /// This error indicates that the operation on the `fields` was not
        /// permitted because the fields are immutable.
        Immutable,
      }
      impl ::core::fmt::Debug for HeaderError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            HeaderError::InvalidSyntax => {
              f.debug_tuple("HeaderError::InvalidSyntax").finish()
            }
            HeaderError::Forbidden => {
              f.debug_tuple("HeaderError::Forbidden").finish()
            }
            HeaderError::Immutable => {
              f.debug_tuple("HeaderError::Immutable").finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for HeaderError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }

      impl std::error::Error for HeaderError {}
      /// Field keys are always strings.
      pub type FieldKey = _rt::String;
      /// Field values should always be ASCII strings. However, in
      /// reality, HTTP implementations often have to interpret malformed values,
      /// so they are provided as a list of bytes.
      pub type FieldValue = _rt::Vec::<u8>;
      /// This following block defines the `fields` resource which corresponds to
      /// HTTP standard Fields. Fields are a common representation used for both
      /// Headers and Trailers.
      ///
      /// A `fields` may be mutable or immutable. A `fields` created using the
      /// constructor, `from-list`, or `clone` will be mutable, but a `fields`
      /// resource given by other means (including, but not limited to,
      /// `incoming-request.headers`, `outgoing-request.headers`) might be be
      /// immutable. In an immutable fields, the `set`, `append`, and `delete`
      /// operations will fail with `header-error.immutable`.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Fields{
        handle: _rt::Resource<Fields>,
      }

      impl Fields{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for Fields{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]fields"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// Headers is an alias for Fields.
      pub type Headers = Fields;
      /// Trailers is an alias for Fields.
      pub type Trailers = Fields;
      /// Represents an incoming HTTP Request.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct IncomingRequest{
        handle: _rt::Resource<IncomingRequest>,
      }

      impl IncomingRequest{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for IncomingRequest{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]incoming-request"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// Represents an outgoing HTTP Request.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct OutgoingRequest{
        handle: _rt::Resource<OutgoingRequest>,
      }

      impl OutgoingRequest{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for OutgoingRequest{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]outgoing-request"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// Parameters for making an HTTP Request. Each of these parameters is
      /// currently an optional timeout applicable to the transport layer of the
      /// HTTP protocol.
      ///
      /// These timeouts are separate from any the user may use to bound a
      /// blocking call to `wasi:io/poll.poll`.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct RequestOptions{
        handle: _rt::Resource<RequestOptions>,
      }

      impl RequestOptions{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for RequestOptions{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]request-options"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// Represents the ability to send an HTTP Response.
      ///
      /// This resource is used by the `wasi:http/incoming-handler` interface to
      /// allow a Response to be sent corresponding to the Request provided as the
      /// other argument to `incoming-handler.handle`.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct ResponseOutparam{
        handle: _rt::Resource<ResponseOutparam>,
      }

      impl ResponseOutparam{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for ResponseOutparam{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]response-outparam"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// This type corresponds to the HTTP standard Status Code.
      pub type StatusCode = u16;
      /// Represents an incoming HTTP Response.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct IncomingResponse{
        handle: _rt::Resource<IncomingResponse>,
      }

      impl IncomingResponse{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for IncomingResponse{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]incoming-response"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// Represents an incoming HTTP Request or Response's Body.
      ///
      /// A body has both its contents - a stream of bytes - and a (possibly
      /// empty) set of trailers, indicating that the full contents of the
      /// body have been received. This resource represents the contents as
      /// an `input-stream` and the delivery of trailers as a `future-trailers`,
      /// and ensures that the user of this interface may only be consuming either
      /// the body contents or waiting on trailers at any given time.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct IncomingBody{
        handle: _rt::Resource<IncomingBody>,
      }

      impl IncomingBody{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for IncomingBody{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]incoming-body"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// Represents a future which may eventaully return trailers, or an error.
      ///
      /// In the case that the incoming HTTP Request or Response did not have any
      /// trailers, this future will resolve to the empty set of trailers once the
      /// complete Request or Response body has been received.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct FutureTrailers{
        handle: _rt::Resource<FutureTrailers>,
      }

      impl FutureTrailers{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for FutureTrailers{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]future-trailers"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// Represents an outgoing HTTP Response.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct OutgoingResponse{
        handle: _rt::Resource<OutgoingResponse>,
      }

      impl OutgoingResponse{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for OutgoingResponse{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]outgoing-response"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// Represents an outgoing HTTP Request or Response's Body.
      ///
      /// A body has both its contents - a stream of bytes - and a (possibly
      /// empty) set of trailers, inducating the full contents of the body
      /// have been sent. This resource represents the contents as an
      /// `output-stream` child resource, and the completion of the body (with
      /// optional trailers) with a static function that consumes the
      /// `outgoing-body` resource, and ensures that the user of this interface
      /// may not write to the body contents after the body has been finished.
      ///
      /// If the user code drops this resource, as opposed to calling the static
      /// method `finish`, the implementation should treat the body as incomplete,
      /// and that an error has occured. The implementation should propogate this
      /// error to the HTTP protocol by whatever means it has available,
      /// including: corrupting the body on the wire, aborting the associated
      /// Request, or sending a late status code for the Response.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct OutgoingBody{
        handle: _rt::Resource<OutgoingBody>,
      }

      impl OutgoingBody{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for OutgoingBody{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]outgoing-body"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// Represents a future which may eventaully return an incoming HTTP
      /// Response, or an error.
      ///
      /// This resource is returned by the `wasi:http/outgoing-handler` interface to
      /// provide the HTTP Response corresponding to the sent Request.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct FutureIncomingResponse{
        handle: _rt::Resource<FutureIncomingResponse>,
      }

      impl FutureIncomingResponse{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for FutureIncomingResponse{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]future-incoming-response"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      #[allow(unused_unsafe, clippy::all)]
      /// Attempts to extract a http-related `error` from the wasi:io `error`
      /// provided.
      ///
      /// Stream operations which return
      /// `wasi:io/stream/stream-error::last-operation-failed` have a payload of
      /// type `wasi:io/error/error` with more information about the operation
      /// that failed. This payload can be passed through to this function to see
      /// if there's http-related information about the error to return.
      ///
      /// Note that this function is fallible because not all io-errors are
      /// http-related errors.
      pub fn http_error_code(err: &IoError,) -> Option<ErrorCode>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 40]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 40]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:http/types@0.2.0")]
          extern "C" {
            #[link_name = "http-error-code"]
            fn wit_import(_: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
          wit_import((err).handle() as i32, ptr0);
          let l1 = i32::from(*ptr0.add(0).cast::<u8>());
          match l1 {
            0 => None,
            1 => {
              let e = {
                let l2 = i32::from(*ptr0.add(8).cast::<u8>());
                let v64 = match l2 {
                  0 => {
                    ErrorCode::DnsTimeout
                  }
                  1 => {
                    let e64 = {
                      let l3 = i32::from(*ptr0.add(16).cast::<u8>());
                      let l7 = i32::from(*ptr0.add(28).cast::<u8>());

                      DnsErrorPayload{
                        rcode: match l3 {
                          0 => None,
                          1 => {
                            let e = {
                              let l4 = *ptr0.add(20).cast::<*mut u8>();
                              let l5 = *ptr0.add(24).cast::<usize>();
                              let len6 = l5;
                              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                              _rt::string_lift(bytes6)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        info_code: match l7 {
                          0 => None,
                          1 => {
                            let e = {
                              let l8 = i32::from(*ptr0.add(30).cast::<u16>());

                              l8 as u16
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    ErrorCode::DnsError(e64)
                  }
                  2 => {
                    ErrorCode::DestinationNotFound
                  }
                  3 => {
                    ErrorCode::DestinationUnavailable
                  }
                  4 => {
                    ErrorCode::DestinationIpProhibited
                  }
                  5 => {
                    ErrorCode::DestinationIpUnroutable
                  }
                  6 => {
                    ErrorCode::ConnectionRefused
                  }
                  7 => {
                    ErrorCode::ConnectionTerminated
                  }
                  8 => {
                    ErrorCode::ConnectionTimeout
                  }
                  9 => {
                    ErrorCode::ConnectionReadTimeout
                  }
                  10 => {
                    ErrorCode::ConnectionWriteTimeout
                  }
                  11 => {
                    ErrorCode::ConnectionLimitReached
                  }
                  12 => {
                    ErrorCode::TlsProtocolError
                  }
                  13 => {
                    ErrorCode::TlsCertificateError
                  }
                  14 => {
                    let e64 = {
                      let l9 = i32::from(*ptr0.add(16).cast::<u8>());
                      let l11 = i32::from(*ptr0.add(20).cast::<u8>());

                      TlsAlertReceivedPayload{
                        alert_id: match l9 {
                          0 => None,
                          1 => {
                            let e = {
                              let l10 = i32::from(*ptr0.add(17).cast::<u8>());

                              l10 as u8
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        alert_message: match l11 {
                          0 => None,
                          1 => {
                            let e = {
                              let l12 = *ptr0.add(24).cast::<*mut u8>();
                              let l13 = *ptr0.add(28).cast::<usize>();
                              let len14 = l13;
                              let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);

                              _rt::string_lift(bytes14)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    ErrorCode::TlsAlertReceived(e64)
                  }
                  15 => {
                    ErrorCode::HttpRequestDenied
                  }
                  16 => {
                    ErrorCode::HttpRequestLengthRequired
                  }
                  17 => {
                    let e64 = {
                      let l15 = i32::from(*ptr0.add(16).cast::<u8>());

                      match l15 {
                        0 => None,
                        1 => {
                          let e = {
                            let l16 = *ptr0.add(24).cast::<i64>();

                            l16 as u64
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    ErrorCode::HttpRequestBodySize(e64)
                  }
                  18 => {
                    ErrorCode::HttpRequestMethodInvalid
                  }
                  19 => {
                    ErrorCode::HttpRequestUriInvalid
                  }
                  20 => {
                    ErrorCode::HttpRequestUriTooLong
                  }
                  21 => {
                    let e64 = {
                      let l17 = i32::from(*ptr0.add(16).cast::<u8>());

                      match l17 {
                        0 => None,
                        1 => {
                          let e = {
                            let l18 = *ptr0.add(20).cast::<i32>();

                            l18 as u32
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    ErrorCode::HttpRequestHeaderSectionSize(e64)
                  }
                  22 => {
                    let e64 = {
                      let l19 = i32::from(*ptr0.add(16).cast::<u8>());

                      match l19 {
                        0 => None,
                        1 => {
                          let e = {
                            let l20 = i32::from(*ptr0.add(20).cast::<u8>());
                            let l24 = i32::from(*ptr0.add(32).cast::<u8>());

                            FieldSizePayload{
                              field_name: match l20 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l21 = *ptr0.add(24).cast::<*mut u8>();
                                    let l22 = *ptr0.add(28).cast::<usize>();
                                    let len23 = l22;
                                    let bytes23 = _rt::Vec::from_raw_parts(l21.cast(), len23, len23);

                                    _rt::string_lift(bytes23)
                                  };
                                  Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                              },
                              field_size: match l24 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l25 = *ptr0.add(36).cast::<i32>();

                                    l25 as u32
                                  };
                                  Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                              },
                            }
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    ErrorCode::HttpRequestHeaderSize(e64)
                  }
                  23 => {
                    let e64 = {
                      let l26 = i32::from(*ptr0.add(16).cast::<u8>());

                      match l26 {
                        0 => None,
                        1 => {
                          let e = {
                            let l27 = *ptr0.add(20).cast::<i32>();

                            l27 as u32
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    ErrorCode::HttpRequestTrailerSectionSize(e64)
                  }
                  24 => {
                    let e64 = {
                      let l28 = i32::from(*ptr0.add(16).cast::<u8>());
                      let l32 = i32::from(*ptr0.add(28).cast::<u8>());

                      FieldSizePayload{
                        field_name: match l28 {
                          0 => None,
                          1 => {
                            let e = {
                              let l29 = *ptr0.add(20).cast::<*mut u8>();
                              let l30 = *ptr0.add(24).cast::<usize>();
                              let len31 = l30;
                              let bytes31 = _rt::Vec::from_raw_parts(l29.cast(), len31, len31);

                              _rt::string_lift(bytes31)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        field_size: match l32 {
                          0 => None,
                          1 => {
                            let e = {
                              let l33 = *ptr0.add(32).cast::<i32>();

                              l33 as u32
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    ErrorCode::HttpRequestTrailerSize(e64)
                  }
                  25 => {
                    ErrorCode::HttpResponseIncomplete
                  }
                  26 => {
                    let e64 = {
                      let l34 = i32::from(*ptr0.add(16).cast::<u8>());

                      match l34 {
                        0 => None,
                        1 => {
                          let e = {
                            let l35 = *ptr0.add(20).cast::<i32>();

                            l35 as u32
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    ErrorCode::HttpResponseHeaderSectionSize(e64)
                  }
                  27 => {
                    let e64 = {
                      let l36 = i32::from(*ptr0.add(16).cast::<u8>());
                      let l40 = i32::from(*ptr0.add(28).cast::<u8>());

                      FieldSizePayload{
                        field_name: match l36 {
                          0 => None,
                          1 => {
                            let e = {
                              let l37 = *ptr0.add(20).cast::<*mut u8>();
                              let l38 = *ptr0.add(24).cast::<usize>();
                              let len39 = l38;
                              let bytes39 = _rt::Vec::from_raw_parts(l37.cast(), len39, len39);

                              _rt::string_lift(bytes39)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        field_size: match l40 {
                          0 => None,
                          1 => {
                            let e = {
                              let l41 = *ptr0.add(32).cast::<i32>();

                              l41 as u32
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    ErrorCode::HttpResponseHeaderSize(e64)
                  }
                  28 => {
                    let e64 = {
                      let l42 = i32::from(*ptr0.add(16).cast::<u8>());

                      match l42 {
                        0 => None,
                        1 => {
                          let e = {
                            let l43 = *ptr0.add(24).cast::<i64>();

                            l43 as u64
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    ErrorCode::HttpResponseBodySize(e64)
                  }
                  29 => {
                    let e64 = {
                      let l44 = i32::from(*ptr0.add(16).cast::<u8>());

                      match l44 {
                        0 => None,
                        1 => {
                          let e = {
                            let l45 = *ptr0.add(20).cast::<i32>();

                            l45 as u32
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    ErrorCode::HttpResponseTrailerSectionSize(e64)
                  }
                  30 => {
                    let e64 = {
                      let l46 = i32::from(*ptr0.add(16).cast::<u8>());
                      let l50 = i32::from(*ptr0.add(28).cast::<u8>());

                      FieldSizePayload{
                        field_name: match l46 {
                          0 => None,
                          1 => {
                            let e = {
                              let l47 = *ptr0.add(20).cast::<*mut u8>();
                              let l48 = *ptr0.add(24).cast::<usize>();
                              let len49 = l48;
                              let bytes49 = _rt::Vec::from_raw_parts(l47.cast(), len49, len49);

                              _rt::string_lift(bytes49)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        field_size: match l50 {
                          0 => None,
                          1 => {
                            let e = {
                              let l51 = *ptr0.add(32).cast::<i32>();

                              l51 as u32
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    ErrorCode::HttpResponseTrailerSize(e64)
                  }
                  31 => {
                    let e64 = {
                      let l52 = i32::from(*ptr0.add(16).cast::<u8>());

                      match l52 {
                        0 => None,
                        1 => {
                          let e = {
                            let l53 = *ptr0.add(20).cast::<*mut u8>();
                            let l54 = *ptr0.add(24).cast::<usize>();
                            let len55 = l54;
                            let bytes55 = _rt::Vec::from_raw_parts(l53.cast(), len55, len55);

                            _rt::string_lift(bytes55)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    ErrorCode::HttpResponseTransferCoding(e64)
                  }
                  32 => {
                    let e64 = {
                      let l56 = i32::from(*ptr0.add(16).cast::<u8>());

                      match l56 {
                        0 => None,
                        1 => {
                          let e = {
                            let l57 = *ptr0.add(20).cast::<*mut u8>();
                            let l58 = *ptr0.add(24).cast::<usize>();
                            let len59 = l58;
                            let bytes59 = _rt::Vec::from_raw_parts(l57.cast(), len59, len59);

                            _rt::string_lift(bytes59)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    ErrorCode::HttpResponseContentCoding(e64)
                  }
                  33 => {
                    ErrorCode::HttpResponseTimeout
                  }
                  34 => {
                    ErrorCode::HttpUpgradeFailed
                  }
                  35 => {
                    ErrorCode::HttpProtocolError
                  }
                  36 => {
                    ErrorCode::LoopDetected
                  }
                  37 => {
                    ErrorCode::ConfigurationError
                  }
                  n => {
                    debug_assert_eq!(n, 38, "invalid enum discriminant");
                    let e64 = {
                      let l60 = i32::from(*ptr0.add(16).cast::<u8>());

                      match l60 {
                        0 => None,
                        1 => {
                          let e = {
                            let l61 = *ptr0.add(20).cast::<*mut u8>();
                            let l62 = *ptr0.add(24).cast::<usize>();
                            let len63 = l62;
                            let bytes63 = _rt::Vec::from_raw_parts(l61.cast(), len63, len63);

                            _rt::string_lift(bytes63)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    ErrorCode::InternalError(e64)
                  }
                };

                v64
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }
      impl Fields {
        #[allow(unused_unsafe, clippy::all)]
        /// Construct an empty HTTP Fields.
        ///
        /// The resulting `fields` is mutable.
        pub fn new() -> Self{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[constructor]fields"]
              fn wit_import() -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import() -> i32{ unreachable!() }
            let ret = wit_import();
            Fields::from_handle(ret as u32)
          }
        }
      }
      impl Fields {
        #[allow(unused_unsafe, clippy::all)]
        /// Construct an HTTP Fields.
        ///
        /// The resulting `fields` is mutable.
        ///
        /// The list represents each key-value pair in the Fields. Keys
        /// which have multiple values are represented by multiple entries in this
        /// list with the same key.
        ///
        /// The tuple is a pair of the field key, represented as a string, and
        /// Value, represented as a list of bytes. In a valid Fields, all keys
        /// and values are valid UTF-8 strings. However, values are not always
        /// well-formed, so they are represented as a raw list of bytes.
        ///
        /// An error result will be returned if any header or value was
        /// syntactically invalid, or if a header was forbidden.
        pub fn from_list(entries: &[(FieldKey,FieldValue,)],) -> Result<Fields,HeaderError>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let vec3 = entries;
            let len3 = vec3.len();
            let layout3 = _rt::alloc::Layout::from_size_align_unchecked(vec3.len() * 16, 4);
            let result3 = if layout3.size() != 0 {
              let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
              if ptr.is_null()
              {
                _rt::alloc::handle_alloc_error(layout3);
              }
              ptr
            }else {{
              ::core::ptr::null_mut()
            }};
            for (i, e) in vec3.into_iter().enumerate() {
              let base = result3.add(i * 16);
              {
                let (t0_0, t0_1, ) = e;
                let vec1 = t0_0;
                let ptr1 = vec1.as_ptr().cast::<u8>();
                let len1 = vec1.len();
                *base.add(4).cast::<usize>() = len1;
                *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                let vec2 = t0_1;
                let ptr2 = vec2.as_ptr().cast::<u8>();
                let len2 = vec2.len();
                *base.add(12).cast::<usize>() = len2;
                *base.add(8).cast::<*mut u8>() = ptr2.cast_mut();
              }
            }
            let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[static]fields.from-list"]
              fn wit_import(_: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import(result3, len3, ptr4);
            let l5 = i32::from(*ptr4.add(0).cast::<u8>());
            if layout3.size() != 0 {
              _rt::alloc::dealloc(result3.cast(), layout3);
            }
            match l5 {
              0 => {
                let e = {
                  let l6 = *ptr4.add(4).cast::<i32>();

                  Fields::from_handle(l6 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l7 = i32::from(*ptr4.add(4).cast::<u8>());
                  let v8 = match l7 {
                    0 => {
                      HeaderError::InvalidSyntax
                    }
                    1 => {
                      HeaderError::Forbidden
                    }
                    n => {
                      debug_assert_eq!(n, 2, "invalid enum discriminant");
                      HeaderError::Immutable
                    }
                  };

                  v8
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Fields {
        #[allow(unused_unsafe, clippy::all)]
        /// Get all of the values corresponding to a key. If the key is not present
        /// in this `fields`, an empty list is returned. However, if the key is
        /// present but empty, this is represented by a list with one or more
        /// empty field-values present.
        pub fn get(&self,name: &FieldKey,) -> _rt::Vec::<FieldValue>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let vec0 = name;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]fields.get"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l2 = *ptr1.add(0).cast::<*mut u8>();
            let l3 = *ptr1.add(4).cast::<usize>();
            let base7 = l2;
            let len7 = l3;
            let mut result7 = _rt::Vec::with_capacity(len7);
            for i in 0..len7 {
              let base = base7.add(i * 8);
              let e7 = {
                let l4 = *base.add(0).cast::<*mut u8>();
                let l5 = *base.add(4).cast::<usize>();
                let len6 = l5;

                _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
              };
              result7.push(e7);
            }
            _rt::cabi_dealloc(base7, len7 * 8, 4);
            result7
          }
        }
      }
      impl Fields {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns `true` when the key is present in this `fields`. If the key is
        /// syntactically invalid, `false` is returned.
        pub fn has(&self,name: &FieldKey,) -> bool{
          unsafe {
            let vec0 = name;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]fields.has"]
              fn wit_import(_: i32, _: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, ptr0.cast_mut(), len0);
            _rt::bool_lift(ret as u8)
          }
        }
      }
      impl Fields {
        #[allow(unused_unsafe, clippy::all)]
        /// Set all of the values for a key. Clears any existing values for that
        /// key, if they have been set.
        ///
        /// Fails with `header-error.immutable` if the `fields` are immutable.
        pub fn set(&self,name: &FieldKey,value: &[FieldValue],) -> Result<(),HeaderError>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = name;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let vec2 = value;
            let len2 = vec2.len();
            let layout2 = _rt::alloc::Layout::from_size_align_unchecked(vec2.len() * 8, 4);
            let result2 = if layout2.size() != 0 {
              let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
              if ptr.is_null()
              {
                _rt::alloc::handle_alloc_error(layout2);
              }
              ptr
            }else {{
              ::core::ptr::null_mut()
            }};
            for (i, e) in vec2.into_iter().enumerate() {
              let base = result2.add(i * 8);
              {
                let vec1 = e;
                let ptr1 = vec1.as_ptr().cast::<u8>();
                let len1 = vec1.len();
                *base.add(4).cast::<usize>() = len1;
                *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
              }
            }
            let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]fields.set"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, result2, len2, ptr3);
            let l4 = i32::from(*ptr3.add(0).cast::<u8>());
            if layout2.size() != 0 {
              _rt::alloc::dealloc(result2.cast(), layout2);
            }
            match l4 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*ptr3.add(1).cast::<u8>());
                  let v6 = match l5 {
                    0 => {
                      HeaderError::InvalidSyntax
                    }
                    1 => {
                      HeaderError::Forbidden
                    }
                    n => {
                      debug_assert_eq!(n, 2, "invalid enum discriminant");
                      HeaderError::Immutable
                    }
                  };

                  v6
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Fields {
        #[allow(unused_unsafe, clippy::all)]
        /// Delete all values for a key. Does nothing if no values for the key
        /// exist.
        ///
        /// Fails with `header-error.immutable` if the `fields` are immutable.
        pub fn delete(&self,name: &FieldKey,) -> Result<(),HeaderError>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = name;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]fields.delete"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr1.add(1).cast::<u8>());
                  let v4 = match l3 {
                    0 => {
                      HeaderError::InvalidSyntax
                    }
                    1 => {
                      HeaderError::Forbidden
                    }
                    n => {
                      debug_assert_eq!(n, 2, "invalid enum discriminant");
                      HeaderError::Immutable
                    }
                  };

                  v4
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Fields {
        #[allow(unused_unsafe, clippy::all)]
        /// Append a value for a key. Does not change or delete any existing
        /// values for that key.
        ///
        /// Fails with `header-error.immutable` if the `fields` are immutable.
        pub fn append(&self,name: &FieldKey,value: &FieldValue,) -> Result<(),HeaderError>{
          unsafe {
            #[repr(align(1))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
            let vec0 = name;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let vec1 = value;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]fields.append"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
            let l3 = i32::from(*ptr2.add(0).cast::<u8>());
            match l3 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*ptr2.add(1).cast::<u8>());
                  let v5 = match l4 {
                    0 => {
                      HeaderError::InvalidSyntax
                    }
                    1 => {
                      HeaderError::Forbidden
                    }
                    n => {
                      debug_assert_eq!(n, 2, "invalid enum discriminant");
                      HeaderError::Immutable
                    }
                  };

                  v5
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Fields {
        #[allow(unused_unsafe, clippy::all)]
        /// Retrieve the full set of keys and values in the Fields. Like the
        /// constructor, the list represents each key-value pair.
        ///
        /// The outer list represents each key-value pair in the Fields. Keys
        /// which have multiple values are represented by multiple entries in this
        /// list with the same key.
        pub fn entries(&self,) -> _rt::Vec::<(FieldKey,FieldValue,)>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]fields.entries"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = *ptr0.add(0).cast::<*mut u8>();
            let l2 = *ptr0.add(4).cast::<usize>();
            let base9 = l1;
            let len9 = l2;
            let mut result9 = _rt::Vec::with_capacity(len9);
            for i in 0..len9 {
              let base = base9.add(i * 16);
              let e9 = {
                let l3 = *base.add(0).cast::<*mut u8>();
                let l4 = *base.add(4).cast::<usize>();
                let len5 = l4;
                let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                let l6 = *base.add(8).cast::<*mut u8>();
                let l7 = *base.add(12).cast::<usize>();
                let len8 = l7;

                (_rt::string_lift(bytes5), _rt::Vec::from_raw_parts(l6.cast(), len8, len8))
              };
              result9.push(e9);
            }
            _rt::cabi_dealloc(base9, len9 * 16, 4);
            result9
          }
        }
      }
      impl Fields {
        #[allow(unused_unsafe, clippy::all)]
        /// Make a deep copy of the Fields. Equivelant in behavior to calling the
        /// `fields` constructor on the return value of `entries`. The resulting
        /// `fields` is mutable.
        pub fn clone(&self,) -> Fields{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]fields.clone"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            Fields::from_handle(ret as u32)
          }
        }
      }
      impl IncomingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns the method of the incoming request.
        pub fn method(&self,) -> Method{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]incoming-request.method"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            let v5 = match l1 {
              0 => {
                Method::Get
              }
              1 => {
                Method::Head
              }
              2 => {
                Method::Post
              }
              3 => {
                Method::Put
              }
              4 => {
                Method::Delete
              }
              5 => {
                Method::Connect
              }
              6 => {
                Method::Options
              }
              7 => {
                Method::Trace
              }
              8 => {
                Method::Patch
              }
              n => {
                debug_assert_eq!(n, 9, "invalid enum discriminant");
                let e5 = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let len4 = l3;
                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                  _rt::string_lift(bytes4)
                };
                Method::Other(e5)
              }
            };
            v5
          }
        }
      }
      impl IncomingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns the path with query parameters from the request, as a string.
        pub fn path_with_query(&self,) -> Option<_rt::String>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]incoming-request.path-with-query"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let len4 = l3;
                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                  _rt::string_lift(bytes4)
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl IncomingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns the protocol scheme from the request.
        pub fn scheme(&self,) -> Option<Scheme>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]incoming-request.scheme"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v6 = match l2 {
                    0 => {
                      Scheme::Http
                    }
                    1 => {
                      Scheme::Https
                    }
                    n => {
                      debug_assert_eq!(n, 2, "invalid enum discriminant");
                      let e6 = {
                        let l3 = *ptr0.add(8).cast::<*mut u8>();
                        let l4 = *ptr0.add(12).cast::<usize>();
                        let len5 = l4;
                        let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

                        _rt::string_lift(bytes5)
                      };
                      Scheme::Other(e6)
                    }
                  };

                  v6
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl IncomingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns the authority from the request, if it was present.
        pub fn authority(&self,) -> Option<_rt::String>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]incoming-request.authority"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let len4 = l3;
                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                  _rt::string_lift(bytes4)
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl IncomingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the `headers` associated with the request.
        ///
        /// The returned `headers` resource is immutable: `set`, `append`, and
        /// `delete` operations will fail with `header-error.immutable`.
        ///
        /// The `headers` returned are a child resource: it must be dropped before
        /// the parent `incoming-request` is dropped. Dropping this
        /// `incoming-request` before all children are dropped will trap.
        pub fn headers(&self,) -> Headers{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]incoming-request.headers"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            Fields::from_handle(ret as u32)
          }
        }
      }
      impl IncomingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Gives the `incoming-body` associated with this request. Will only
        /// return success at most once, and subsequent calls will return error.
        pub fn consume(&self,) -> Result<IncomingBody,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]incoming-request.consume"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  IncomingBody::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Construct a new `outgoing-request` with a default `method` of `GET`, and
        /// `none` values for `path-with-query`, `scheme`, and `authority`.
        ///
        /// * `headers` is the HTTP Headers for the Request.
        ///
        /// It is possible to construct, or manipulate with the accessor functions
        /// below, an `outgoing-request` with an invalid combination of `scheme`
        /// and `authority`, or `headers` which are not permitted to be sent.
        /// It is the obligation of the `outgoing-handler.handle` implementation
        /// to reject invalid constructions of `outgoing-request`.
        pub fn new(headers: Headers,) -> Self{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[constructor]outgoing-request"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((&headers).take_handle() as i32);
            OutgoingRequest::from_handle(ret as u32)
          }
        }
      }
      impl OutgoingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns the resource corresponding to the outgoing Body for this
        /// Request.
        ///
        /// Returns success on the first call: the `outgoing-body` resource for
        /// this `outgoing-request` can be retrieved at most once. Subsequent
        /// calls will return error.
        pub fn body(&self,) -> Result<OutgoingBody,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-request.body"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  OutgoingBody::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the Method for the Request.
        pub fn method(&self,) -> Method{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-request.method"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            let v5 = match l1 {
              0 => {
                Method::Get
              }
              1 => {
                Method::Head
              }
              2 => {
                Method::Post
              }
              3 => {
                Method::Put
              }
              4 => {
                Method::Delete
              }
              5 => {
                Method::Connect
              }
              6 => {
                Method::Options
              }
              7 => {
                Method::Trace
              }
              8 => {
                Method::Patch
              }
              n => {
                debug_assert_eq!(n, 9, "invalid enum discriminant");
                let e5 = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let len4 = l3;
                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                  _rt::string_lift(bytes4)
                };
                Method::Other(e5)
              }
            };
            v5
          }
        }
      }
      impl OutgoingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Set the Method for the Request. Fails if the string present in a
        /// `method.other` argument is not a syntactically valid method.
        pub fn set_method(&self,method: &Method,) -> Result<(),()>{
          unsafe {
            let (result1_0,result1_1,result1_2,) = match method {
              Method::Get=> {
                (0i32, ::core::ptr::null_mut(), 0usize)
              }
              Method::Head=> {
                (1i32, ::core::ptr::null_mut(), 0usize)
              }
              Method::Post=> {
                (2i32, ::core::ptr::null_mut(), 0usize)
              }
              Method::Put=> {
                (3i32, ::core::ptr::null_mut(), 0usize)
              }
              Method::Delete=> {
                (4i32, ::core::ptr::null_mut(), 0usize)
              }
              Method::Connect=> {
                (5i32, ::core::ptr::null_mut(), 0usize)
              }
              Method::Options=> {
                (6i32, ::core::ptr::null_mut(), 0usize)
              }
              Method::Trace=> {
                (7i32, ::core::ptr::null_mut(), 0usize)
              }
              Method::Patch=> {
                (8i32, ::core::ptr::null_mut(), 0usize)
              }
              Method::Other(e) => {
                let vec0 = e;
                let ptr0 = vec0.as_ptr().cast::<u8>();
                let len0 = vec0.len();

                (9i32, ptr0.cast_mut(), len0)
              },
            };

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-request.set-method"]
              fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, result1_0, result1_1, result1_2);
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the combination of the HTTP Path and Query for the Request.
        /// When `none`, this represents an empty Path and empty Query.
        pub fn path_with_query(&self,) -> Option<_rt::String>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-request.path-with-query"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let len4 = l3;
                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                  _rt::string_lift(bytes4)
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Set the combination of the HTTP Path and Query for the Request.
        /// When `none`, this represents an empty Path and empty Query. Fails is the
        /// string given is not a syntactically valid path and query uri component.
        pub fn set_path_with_query(&self,path_with_query: Option<&str>,) -> Result<(),()>{
          unsafe {
            let (result1_0,result1_1,result1_2,) = match path_with_query {
              Some(e) => {
                let vec0 = e;
                let ptr0 = vec0.as_ptr().cast::<u8>();
                let len0 = vec0.len();

                (1i32, ptr0.cast_mut(), len0)
              },
              None => {
                (0i32, ::core::ptr::null_mut(), 0usize)
              },
            };
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-request.set-path-with-query"]
              fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, result1_0, result1_1, result1_2);
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the HTTP Related Scheme for the Request. When `none`, the
        /// implementation may choose an appropriate default scheme.
        pub fn scheme(&self,) -> Option<Scheme>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-request.scheme"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v6 = match l2 {
                    0 => {
                      Scheme::Http
                    }
                    1 => {
                      Scheme::Https
                    }
                    n => {
                      debug_assert_eq!(n, 2, "invalid enum discriminant");
                      let e6 = {
                        let l3 = *ptr0.add(8).cast::<*mut u8>();
                        let l4 = *ptr0.add(12).cast::<usize>();
                        let len5 = l4;
                        let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

                        _rt::string_lift(bytes5)
                      };
                      Scheme::Other(e6)
                    }
                  };

                  v6
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Set the HTTP Related Scheme for the Request. When `none`, the
        /// implementation may choose an appropriate default scheme. Fails if the
        /// string given is not a syntactically valid uri scheme.
        pub fn set_scheme(&self,scheme: Option<&Scheme>,) -> Result<(),()>{
          unsafe {
            let (result2_0,result2_1,result2_2,result2_3,) = match scheme {
              Some(e) => {
                let (result1_0,result1_1,result1_2,) = match e {
                  Scheme::Http=> {
                    (0i32, ::core::ptr::null_mut(), 0usize)
                  }
                  Scheme::Https=> {
                    (1i32, ::core::ptr::null_mut(), 0usize)
                  }
                  Scheme::Other(e) => {
                    let vec0 = e;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();

                    (2i32, ptr0.cast_mut(), len0)
                  },
                };

                (1i32, result1_0, result1_1, result1_2)
              },
              None => {
                (0i32, 0i32, ::core::ptr::null_mut(), 0usize)
              },
            };
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-request.set-scheme"]
              fn wit_import(_: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, result2_0, result2_1, result2_2, result2_3);
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the HTTP Authority for the Request. A value of `none` may be used
        /// with Related Schemes which do not require an Authority. The HTTP and
        /// HTTPS schemes always require an authority.
        pub fn authority(&self,) -> Option<_rt::String>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-request.authority"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let len4 = l3;
                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                  _rt::string_lift(bytes4)
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Set the HTTP Authority for the Request. A value of `none` may be used
        /// with Related Schemes which do not require an Authority. The HTTP and
        /// HTTPS schemes always require an authority. Fails if the string given is
        /// not a syntactically valid uri authority.
        pub fn set_authority(&self,authority: Option<&str>,) -> Result<(),()>{
          unsafe {
            let (result1_0,result1_1,result1_2,) = match authority {
              Some(e) => {
                let vec0 = e;
                let ptr0 = vec0.as_ptr().cast::<u8>();
                let len0 = vec0.len();

                (1i32, ptr0.cast_mut(), len0)
              },
              None => {
                (0i32, ::core::ptr::null_mut(), 0usize)
              },
            };
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-request.set-authority"]
              fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: *mut u8, _: usize, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, result1_0, result1_1, result1_2);
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingRequest {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the headers associated with the Request.
        ///
        /// The returned `headers` resource is immutable: `set`, `append`, and
        /// `delete` operations will fail with `header-error.immutable`.
        ///
        /// This headers resource is a child: it must be dropped before the parent
        /// `outgoing-request` is dropped, or its ownership is transfered to
        /// another component by e.g. `outgoing-handler.handle`.
        pub fn headers(&self,) -> Headers{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-request.headers"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            Fields::from_handle(ret as u32)
          }
        }
      }
      impl RequestOptions {
        #[allow(unused_unsafe, clippy::all)]
        /// Construct a default `request-options` value.
        pub fn new() -> Self{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[constructor]request-options"]
              fn wit_import() -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import() -> i32{ unreachable!() }
            let ret = wit_import();
            RequestOptions::from_handle(ret as u32)
          }
        }
      }
      impl RequestOptions {
        #[allow(unused_unsafe, clippy::all)]
        /// The timeout for the initial connect to the HTTP Server.
        pub fn connect_timeout(&self,) -> Option<Duration>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]request-options.connect-timeout"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();

                  l2 as u64
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl RequestOptions {
        #[allow(unused_unsafe, clippy::all)]
        /// Set the timeout for the initial connect to the HTTP Server. An error
        /// return value indicates that this timeout is not supported.
        pub fn set_connect_timeout(&self,duration: Option<Duration>,) -> Result<(),()>{
          unsafe {
            let (result0_0,result0_1,) = match duration {
              Some(e) => (1i32, _rt::as_i64(e)),
              None => {
                (0i32, 0i64)
              },
            };
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]request-options.set-connect-timeout"]
              fn wit_import(_: i32, _: i32, _: i64, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i64, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, result0_0, result0_1);
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl RequestOptions {
        #[allow(unused_unsafe, clippy::all)]
        /// The timeout for receiving the first byte of the Response body.
        pub fn first_byte_timeout(&self,) -> Option<Duration>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]request-options.first-byte-timeout"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();

                  l2 as u64
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl RequestOptions {
        #[allow(unused_unsafe, clippy::all)]
        /// Set the timeout for receiving the first byte of the Response body. An
        /// error return value indicates that this timeout is not supported.
        pub fn set_first_byte_timeout(&self,duration: Option<Duration>,) -> Result<(),()>{
          unsafe {
            let (result0_0,result0_1,) = match duration {
              Some(e) => (1i32, _rt::as_i64(e)),
              None => {
                (0i32, 0i64)
              },
            };
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]request-options.set-first-byte-timeout"]
              fn wit_import(_: i32, _: i32, _: i64, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i64, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, result0_0, result0_1);
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl RequestOptions {
        #[allow(unused_unsafe, clippy::all)]
        /// The timeout for receiving subsequent chunks of bytes in the Response
        /// body stream.
        pub fn between_bytes_timeout(&self,) -> Option<Duration>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]request-options.between-bytes-timeout"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();

                  l2 as u64
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl RequestOptions {
        #[allow(unused_unsafe, clippy::all)]
        /// Set the timeout for receiving subsequent chunks of bytes in the Response
        /// body stream. An error return value indicates that this timeout is not
        /// supported.
        pub fn set_between_bytes_timeout(&self,duration: Option<Duration>,) -> Result<(),()>{
          unsafe {
            let (result0_0,result0_1,) = match duration {
              Some(e) => (1i32, _rt::as_i64(e)),
              None => {
                (0i32, 0i64)
              },
            };
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]request-options.set-between-bytes-timeout"]
              fn wit_import(_: i32, _: i32, _: i64, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i64, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, result0_0, result0_1);
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl ResponseOutparam {
        #[allow(unused_unsafe, clippy::all)]
        /// Set the value of the `response-outparam` to either send a response,
        /// or indicate an error.
        ///
        /// This method consumes the `response-outparam` to ensure that it is
        /// called at most once. If it is never called, the implementation
        /// will respond with an error.
        ///
        /// The user may provide an `error` to `response` to allow the
        /// implementation determine how to respond with an HTTP error response.
        pub fn set(param: ResponseOutparam,response: Result<OutgoingResponse,ErrorCode>,){
          unsafe {
            let (result38_0,result38_1,result38_2,result38_3,result38_4,result38_5,result38_6,result38_7,) = match &response {
              Ok(e) => { (0i32, (e).take_handle() as i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32) },
              Err(e) => { {
                let (result37_0,result37_1,result37_2,result37_3,result37_4,result37_5,result37_6,) = match e {
                  ErrorCode::DnsTimeout=> {
                    (0i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::DnsError(e) => {
                    let DnsErrorPayload{ rcode:rcode0, info_code:info_code0, } = e;
                    let (result2_0,result2_1,result2_2,) = match rcode0 {
                      Some(e) => {
                        let vec1 = e;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();

                        (1i32, ptr1.cast_mut(), len1)
                      },
                      None => {
                        (0i32, ::core::ptr::null_mut(), 0usize)
                      },
                    };let (result3_0,result3_1,) = match info_code0 {
                      Some(e) => (1i32, _rt::as_i32(e)),
                      None => {
                        (0i32, 0i32)
                      },
                    };
                    (1i32, result2_0, {
                      let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                      t.as_mut_ptr().cast::<*mut u8>().write(result2_1);
                      t
                    }, result2_2 as *mut u8, result3_0 as *mut u8, result3_1 as usize, 0i32)
                  },
                  ErrorCode::DestinationNotFound=> {
                    (2i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::DestinationUnavailable=> {
                    (3i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::DestinationIpProhibited=> {
                    (4i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::DestinationIpUnroutable=> {
                    (5i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::ConnectionRefused=> {
                    (6i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::ConnectionTerminated=> {
                    (7i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::ConnectionTimeout=> {
                    (8i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::ConnectionReadTimeout=> {
                    (9i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::ConnectionWriteTimeout=> {
                    (10i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::ConnectionLimitReached=> {
                    (11i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::TlsProtocolError=> {
                    (12i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::TlsCertificateError=> {
                    (13i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::TlsAlertReceived(e) => {
                    let TlsAlertReceivedPayload{ alert_id:alert_id4, alert_message:alert_message4, } = e;
                    let (result5_0,result5_1,) = match alert_id4 {
                      Some(e) => (1i32, _rt::as_i32(e)),
                      None => {
                        (0i32, 0i32)
                      },
                    };let (result7_0,result7_1,result7_2,) = match alert_message4 {
                      Some(e) => {
                        let vec6 = e;
                        let ptr6 = vec6.as_ptr().cast::<u8>();
                        let len6 = vec6.len();

                        (1i32, ptr6.cast_mut(), len6)
                      },
                      None => {
                        (0i32, ::core::ptr::null_mut(), 0usize)
                      },
                    };
                    (14i32, result5_0, ::core::mem::MaybeUninit::new(i64::from(result5_1) as u64), result7_0 as *mut u8, result7_1, result7_2, 0i32)
                  },
                  ErrorCode::HttpRequestDenied=> {
                    (15i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::HttpRequestLengthRequired=> {
                    (16i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::HttpRequestBodySize(e) => {
                    let (result8_0,result8_1,) = match e {
                      Some(e) => (1i32, _rt::as_i64(e)),
                      None => {
                        (0i32, 0i64)
                      },
                    };
                    (17i32, result8_0, ::core::mem::MaybeUninit::new(result8_1 as u64), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  },
                  ErrorCode::HttpRequestMethodInvalid=> {
                    (18i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::HttpRequestUriInvalid=> {
                    (19i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::HttpRequestUriTooLong=> {
                    (20i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::HttpRequestHeaderSectionSize(e) => {
                    let (result9_0,result9_1,) = match e {
                      Some(e) => (1i32, _rt::as_i32(e)),
                      None => {
                        (0i32, 0i32)
                      },
                    };
                    (21i32, result9_0, ::core::mem::MaybeUninit::new(i64::from(result9_1) as u64), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  },
                  ErrorCode::HttpRequestHeaderSize(e) => {
                    let (result14_0,result14_1,result14_2,result14_3,result14_4,result14_5,) = match e {
                      Some(e) => {
                        let FieldSizePayload{ field_name:field_name10, field_size:field_size10, } = e;
                        let (result12_0,result12_1,result12_2,) = match field_name10 {
                          Some(e) => {
                            let vec11 = e;
                            let ptr11 = vec11.as_ptr().cast::<u8>();
                            let len11 = vec11.len();

                            (1i32, ptr11.cast_mut(), len11)
                          },
                          None => {
                            (0i32, ::core::ptr::null_mut(), 0usize)
                          },
                        };let (result13_0,result13_1,) = match field_size10 {
                          Some(e) => (1i32, _rt::as_i32(e)),
                          None => {
                            (0i32, 0i32)
                          },
                        };
                        (1i32, result12_0, result12_1, result12_2, result13_0, result13_1)
                      },
                      None => {
                        (0i32, 0i32, ::core::ptr::null_mut(), 0usize, 0i32, 0i32)
                      },
                    };
                    (22i32, result14_0, ::core::mem::MaybeUninit::new(i64::from(result14_1) as u64), result14_2, result14_3 as *mut u8, result14_4 as usize, result14_5)
                  },
                  ErrorCode::HttpRequestTrailerSectionSize(e) => {
                    let (result15_0,result15_1,) = match e {
                      Some(e) => (1i32, _rt::as_i32(e)),
                      None => {
                        (0i32, 0i32)
                      },
                    };
                    (23i32, result15_0, ::core::mem::MaybeUninit::new(i64::from(result15_1) as u64), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  },
                  ErrorCode::HttpRequestTrailerSize(e) => {
                    let FieldSizePayload{ field_name:field_name16, field_size:field_size16, } = e;
                    let (result18_0,result18_1,result18_2,) = match field_name16 {
                      Some(e) => {
                        let vec17 = e;
                        let ptr17 = vec17.as_ptr().cast::<u8>();
                        let len17 = vec17.len();

                        (1i32, ptr17.cast_mut(), len17)
                      },
                      None => {
                        (0i32, ::core::ptr::null_mut(), 0usize)
                      },
                    };let (result19_0,result19_1,) = match field_size16 {
                      Some(e) => (1i32, _rt::as_i32(e)),
                      None => {
                        (0i32, 0i32)
                      },
                    };
                    (24i32, result18_0, {
                      let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                      t.as_mut_ptr().cast::<*mut u8>().write(result18_1);
                      t
                    }, result18_2 as *mut u8, result19_0 as *mut u8, result19_1 as usize, 0i32)
                  },
                  ErrorCode::HttpResponseIncomplete=> {
                    (25i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::HttpResponseHeaderSectionSize(e) => {
                    let (result20_0,result20_1,) = match e {
                      Some(e) => (1i32, _rt::as_i32(e)),
                      None => {
                        (0i32, 0i32)
                      },
                    };
                    (26i32, result20_0, ::core::mem::MaybeUninit::new(i64::from(result20_1) as u64), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  },
                  ErrorCode::HttpResponseHeaderSize(e) => {
                    let FieldSizePayload{ field_name:field_name21, field_size:field_size21, } = e;
                    let (result23_0,result23_1,result23_2,) = match field_name21 {
                      Some(e) => {
                        let vec22 = e;
                        let ptr22 = vec22.as_ptr().cast::<u8>();
                        let len22 = vec22.len();

                        (1i32, ptr22.cast_mut(), len22)
                      },
                      None => {
                        (0i32, ::core::ptr::null_mut(), 0usize)
                      },
                    };let (result24_0,result24_1,) = match field_size21 {
                      Some(e) => (1i32, _rt::as_i32(e)),
                      None => {
                        (0i32, 0i32)
                      },
                    };
                    (27i32, result23_0, {
                      let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                      t.as_mut_ptr().cast::<*mut u8>().write(result23_1);
                      t
                    }, result23_2 as *mut u8, result24_0 as *mut u8, result24_1 as usize, 0i32)
                  },
                  ErrorCode::HttpResponseBodySize(e) => {
                    let (result25_0,result25_1,) = match e {
                      Some(e) => (1i32, _rt::as_i64(e)),
                      None => {
                        (0i32, 0i64)
                      },
                    };
                    (28i32, result25_0, ::core::mem::MaybeUninit::new(result25_1 as u64), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  },
                  ErrorCode::HttpResponseTrailerSectionSize(e) => {
                    let (result26_0,result26_1,) = match e {
                      Some(e) => (1i32, _rt::as_i32(e)),
                      None => {
                        (0i32, 0i32)
                      },
                    };
                    (29i32, result26_0, ::core::mem::MaybeUninit::new(i64::from(result26_1) as u64), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  },
                  ErrorCode::HttpResponseTrailerSize(e) => {
                    let FieldSizePayload{ field_name:field_name27, field_size:field_size27, } = e;
                    let (result29_0,result29_1,result29_2,) = match field_name27 {
                      Some(e) => {
                        let vec28 = e;
                        let ptr28 = vec28.as_ptr().cast::<u8>();
                        let len28 = vec28.len();

                        (1i32, ptr28.cast_mut(), len28)
                      },
                      None => {
                        (0i32, ::core::ptr::null_mut(), 0usize)
                      },
                    };let (result30_0,result30_1,) = match field_size27 {
                      Some(e) => (1i32, _rt::as_i32(e)),
                      None => {
                        (0i32, 0i32)
                      },
                    };
                    (30i32, result29_0, {
                      let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                      t.as_mut_ptr().cast::<*mut u8>().write(result29_1);
                      t
                    }, result29_2 as *mut u8, result30_0 as *mut u8, result30_1 as usize, 0i32)
                  },
                  ErrorCode::HttpResponseTransferCoding(e) => {
                    let (result32_0,result32_1,result32_2,) = match e {
                      Some(e) => {
                        let vec31 = e;
                        let ptr31 = vec31.as_ptr().cast::<u8>();
                        let len31 = vec31.len();

                        (1i32, ptr31.cast_mut(), len31)
                      },
                      None => {
                        (0i32, ::core::ptr::null_mut(), 0usize)
                      },
                    };
                    (31i32, result32_0, {
                      let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                      t.as_mut_ptr().cast::<*mut u8>().write(result32_1);
                      t
                    }, result32_2 as *mut u8, ::core::ptr::null_mut(), 0usize, 0i32)
                  },
                  ErrorCode::HttpResponseContentCoding(e) => {
                    let (result34_0,result34_1,result34_2,) = match e {
                      Some(e) => {
                        let vec33 = e;
                        let ptr33 = vec33.as_ptr().cast::<u8>();
                        let len33 = vec33.len();

                        (1i32, ptr33.cast_mut(), len33)
                      },
                      None => {
                        (0i32, ::core::ptr::null_mut(), 0usize)
                      },
                    };
                    (32i32, result34_0, {
                      let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                      t.as_mut_ptr().cast::<*mut u8>().write(result34_1);
                      t
                    }, result34_2 as *mut u8, ::core::ptr::null_mut(), 0usize, 0i32)
                  },
                  ErrorCode::HttpResponseTimeout=> {
                    (33i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::HttpUpgradeFailed=> {
                    (34i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::HttpProtocolError=> {
                    (35i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::LoopDetected=> {
                    (36i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::ConfigurationError=> {
                    (37i32, 0i32, ::core::mem::MaybeUninit::<u64>::zeroed(), ::core::ptr::null_mut(), ::core::ptr::null_mut(), 0usize, 0i32)
                  }
                  ErrorCode::InternalError(e) => {
                    let (result36_0,result36_1,result36_2,) = match e {
                      Some(e) => {
                        let vec35 = e;
                        let ptr35 = vec35.as_ptr().cast::<u8>();
                        let len35 = vec35.len();

                        (1i32, ptr35.cast_mut(), len35)
                      },
                      None => {
                        (0i32, ::core::ptr::null_mut(), 0usize)
                      },
                    };
                    (38i32, result36_0, {
                      let mut t = ::core::mem::MaybeUninit::<u64>::uninit();
                      t.as_mut_ptr().cast::<*mut u8>().write(result36_1);
                      t
                    }, result36_2 as *mut u8, ::core::ptr::null_mut(), 0usize, 0i32)
                  },
                };

                (1i32, result37_0, result37_1, result37_2, result37_3, result37_4, result37_5, result37_6)
              } },
            };
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[static]response-outparam.set"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: *mut u8, _: *mut u8, _: usize, _: i32, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: ::core::mem::MaybeUninit::<u64>, _: *mut u8, _: *mut u8, _: usize, _: i32, ){ unreachable!() }
            wit_import((&param).take_handle() as i32, result38_0, result38_1, result38_2, result38_3, result38_4, result38_5, result38_6, result38_7);
          }
        }
      }
      impl IncomingResponse {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns the status code from the incoming response.
        pub fn status(&self,) -> StatusCode{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]incoming-response.status"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            ret as u16
          }
        }
      }
      impl IncomingResponse {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns the headers from the incoming response.
        ///
        /// The returned `headers` resource is immutable: `set`, `append`, and
        /// `delete` operations will fail with `header-error.immutable`.
        ///
        /// This headers resource is a child: it must be dropped before the parent
        /// `incoming-response` is dropped.
        pub fn headers(&self,) -> Headers{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]incoming-response.headers"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            Fields::from_handle(ret as u32)
          }
        }
      }
      impl IncomingResponse {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns the incoming body. May be called at most once. Returns error
        /// if called additional times.
        pub fn consume(&self,) -> Result<IncomingBody,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]incoming-response.consume"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  IncomingBody::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl IncomingBody {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns the contents of the body, as a stream of bytes.
        ///
        /// Returns success on first call: the stream representing the contents
        /// can be retrieved at most once. Subsequent calls will return error.
        ///
        /// The returned `input-stream` resource is a child: it must be dropped
        /// before the parent `incoming-body` is dropped, or consumed by
        /// `incoming-body.finish`.
        ///
        /// This invariant ensures that the implementation can determine whether
        /// the user is consuming the contents of the body, waiting on the
        /// `future-trailers` to be ready, or neither. This allows for network
        /// backpressure is to be applied when the user is consuming the body,
        /// and for that backpressure to not inhibit delivery of the trailers if
        /// the user does not read the entire body.
        pub fn stream(&self,) -> Result<InputStream,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]incoming-body.stream"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  super::super::super::wasi::io::streams::InputStream::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl IncomingBody {
        #[allow(unused_unsafe, clippy::all)]
        /// Takes ownership of `incoming-body`, and returns a `future-trailers`.
        /// This function will trap if the `input-stream` child is still alive.
        pub fn finish(this: IncomingBody,) -> FutureTrailers{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[static]incoming-body.finish"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((&this).take_handle() as i32);
            FutureTrailers::from_handle(ret as u32)
          }
        }
      }
      impl FutureTrailers {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns a pollable which becomes ready when either the trailers have
        /// been received, or an error has occured. When this pollable is ready,
        /// the `get` method will return `some`.
        /// subscribe: func() -> pollable; // Hermes does NOT support `poll`
        /// Returns the contents of the trailers, or an error which occured,
        /// once the future is ready.
        ///
        /// The outer `option` represents future readiness. Users can wait on this
        /// `option` to become `some` using the `subscribe` method.
        ///
        /// The outer `result` is used to retrieve the trailers or error at most
        /// once. It will be success on the first call in which the outer option
        /// is `some`, and error on subsequent calls.
        ///
        /// The inner `result` represents that either the HTTP Request or Response
        /// body, as well as any trailers, were received successfully, or that an
        /// error occured receiving them. The optional `trailers` indicates whether
        /// or not trailers were present in the body.
        ///
        /// When some `trailers` are returned by this method, the `trailers`
        /// resource is immutable, and a child. Use of the `set`, `append`, or
        /// `delete` methods will return an error, and the resource must be
        /// dropped before the parent `future-trailers` is dropped.
        pub fn get(&self,) -> Option<Result<Result<Option<Trailers>,ErrorCode>,()>>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 56]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 56]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]future-trailers.get"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(8).cast::<u8>());

                  match l2 {
                    0 => {
                      let e = {
                        let l3 = i32::from(*ptr0.add(16).cast::<u8>());

                        match l3 {
                          0 => {
                            let e = {
                              let l4 = i32::from(*ptr0.add(24).cast::<u8>());

                              match l4 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l5 = *ptr0.add(28).cast::<i32>();

                                    Fields::from_handle(l5 as u32)
                                  };
                                  Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                              }
                            };
                            Ok(e)
                          }
                          1 => {
                            let e = {
                              let l6 = i32::from(*ptr0.add(24).cast::<u8>());
                              let v68 = match l6 {
                                0 => {
                                  ErrorCode::DnsTimeout
                                }
                                1 => {
                                  let e68 = {
                                    let l7 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l11 = i32::from(*ptr0.add(44).cast::<u8>());

                                    DnsErrorPayload{
                                      rcode: match l7 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l8 = *ptr0.add(36).cast::<*mut u8>();
                                            let l9 = *ptr0.add(40).cast::<usize>();
                                            let len10 = l9;
                                            let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                                            _rt::string_lift(bytes10)
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                      info_code: match l11 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l12 = i32::from(*ptr0.add(46).cast::<u16>());

                                            l12 as u16
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                    }
                                  };
                                  ErrorCode::DnsError(e68)
                                }
                                2 => {
                                  ErrorCode::DestinationNotFound
                                }
                                3 => {
                                  ErrorCode::DestinationUnavailable
                                }
                                4 => {
                                  ErrorCode::DestinationIpProhibited
                                }
                                5 => {
                                  ErrorCode::DestinationIpUnroutable
                                }
                                6 => {
                                  ErrorCode::ConnectionRefused
                                }
                                7 => {
                                  ErrorCode::ConnectionTerminated
                                }
                                8 => {
                                  ErrorCode::ConnectionTimeout
                                }
                                9 => {
                                  ErrorCode::ConnectionReadTimeout
                                }
                                10 => {
                                  ErrorCode::ConnectionWriteTimeout
                                }
                                11 => {
                                  ErrorCode::ConnectionLimitReached
                                }
                                12 => {
                                  ErrorCode::TlsProtocolError
                                }
                                13 => {
                                  ErrorCode::TlsCertificateError
                                }
                                14 => {
                                  let e68 = {
                                    let l13 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l15 = i32::from(*ptr0.add(36).cast::<u8>());

                                    TlsAlertReceivedPayload{
                                      alert_id: match l13 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l14 = i32::from(*ptr0.add(33).cast::<u8>());

                                            l14 as u8
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                      alert_message: match l15 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l16 = *ptr0.add(40).cast::<*mut u8>();
                                            let l17 = *ptr0.add(44).cast::<usize>();
                                            let len18 = l17;
                                            let bytes18 = _rt::Vec::from_raw_parts(l16.cast(), len18, len18);

                                            _rt::string_lift(bytes18)
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                    }
                                  };
                                  ErrorCode::TlsAlertReceived(e68)
                                }
                                15 => {
                                  ErrorCode::HttpRequestDenied
                                }
                                16 => {
                                  ErrorCode::HttpRequestLengthRequired
                                }
                                17 => {
                                  let e68 = {
                                    let l19 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l19 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l20 = *ptr0.add(40).cast::<i64>();

                                          l20 as u64
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpRequestBodySize(e68)
                                }
                                18 => {
                                  ErrorCode::HttpRequestMethodInvalid
                                }
                                19 => {
                                  ErrorCode::HttpRequestUriInvalid
                                }
                                20 => {
                                  ErrorCode::HttpRequestUriTooLong
                                }
                                21 => {
                                  let e68 = {
                                    let l21 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l21 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l22 = *ptr0.add(36).cast::<i32>();

                                          l22 as u32
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpRequestHeaderSectionSize(e68)
                                }
                                22 => {
                                  let e68 = {
                                    let l23 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l23 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l24 = i32::from(*ptr0.add(36).cast::<u8>());
                                          let l28 = i32::from(*ptr0.add(48).cast::<u8>());

                                          FieldSizePayload{
                                            field_name: match l24 {
                                              0 => None,
                                              1 => {
                                                let e = {
                                                  let l25 = *ptr0.add(40).cast::<*mut u8>();
                                                  let l26 = *ptr0.add(44).cast::<usize>();
                                                  let len27 = l26;
                                                  let bytes27 = _rt::Vec::from_raw_parts(l25.cast(), len27, len27);

                                                  _rt::string_lift(bytes27)
                                                };
                                                Some(e)
                                              }
                                              _ => _rt::invalid_enum_discriminant(),
                                            },
                                            field_size: match l28 {
                                              0 => None,
                                              1 => {
                                                let e = {
                                                  let l29 = *ptr0.add(52).cast::<i32>();

                                                  l29 as u32
                                                };
                                                Some(e)
                                              }
                                              _ => _rt::invalid_enum_discriminant(),
                                            },
                                          }
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpRequestHeaderSize(e68)
                                }
                                23 => {
                                  let e68 = {
                                    let l30 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l30 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l31 = *ptr0.add(36).cast::<i32>();

                                          l31 as u32
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpRequestTrailerSectionSize(e68)
                                }
                                24 => {
                                  let e68 = {
                                    let l32 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l36 = i32::from(*ptr0.add(44).cast::<u8>());

                                    FieldSizePayload{
                                      field_name: match l32 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l33 = *ptr0.add(36).cast::<*mut u8>();
                                            let l34 = *ptr0.add(40).cast::<usize>();
                                            let len35 = l34;
                                            let bytes35 = _rt::Vec::from_raw_parts(l33.cast(), len35, len35);

                                            _rt::string_lift(bytes35)
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                      field_size: match l36 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l37 = *ptr0.add(48).cast::<i32>();

                                            l37 as u32
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                    }
                                  };
                                  ErrorCode::HttpRequestTrailerSize(e68)
                                }
                                25 => {
                                  ErrorCode::HttpResponseIncomplete
                                }
                                26 => {
                                  let e68 = {
                                    let l38 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l38 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l39 = *ptr0.add(36).cast::<i32>();

                                          l39 as u32
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpResponseHeaderSectionSize(e68)
                                }
                                27 => {
                                  let e68 = {
                                    let l40 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l44 = i32::from(*ptr0.add(44).cast::<u8>());

                                    FieldSizePayload{
                                      field_name: match l40 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l41 = *ptr0.add(36).cast::<*mut u8>();
                                            let l42 = *ptr0.add(40).cast::<usize>();
                                            let len43 = l42;
                                            let bytes43 = _rt::Vec::from_raw_parts(l41.cast(), len43, len43);

                                            _rt::string_lift(bytes43)
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                      field_size: match l44 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l45 = *ptr0.add(48).cast::<i32>();

                                            l45 as u32
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                    }
                                  };
                                  ErrorCode::HttpResponseHeaderSize(e68)
                                }
                                28 => {
                                  let e68 = {
                                    let l46 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l46 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l47 = *ptr0.add(40).cast::<i64>();

                                          l47 as u64
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpResponseBodySize(e68)
                                }
                                29 => {
                                  let e68 = {
                                    let l48 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l48 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l49 = *ptr0.add(36).cast::<i32>();

                                          l49 as u32
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpResponseTrailerSectionSize(e68)
                                }
                                30 => {
                                  let e68 = {
                                    let l50 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l54 = i32::from(*ptr0.add(44).cast::<u8>());

                                    FieldSizePayload{
                                      field_name: match l50 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l51 = *ptr0.add(36).cast::<*mut u8>();
                                            let l52 = *ptr0.add(40).cast::<usize>();
                                            let len53 = l52;
                                            let bytes53 = _rt::Vec::from_raw_parts(l51.cast(), len53, len53);

                                            _rt::string_lift(bytes53)
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                      field_size: match l54 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l55 = *ptr0.add(48).cast::<i32>();

                                            l55 as u32
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                    }
                                  };
                                  ErrorCode::HttpResponseTrailerSize(e68)
                                }
                                31 => {
                                  let e68 = {
                                    let l56 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l56 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l57 = *ptr0.add(36).cast::<*mut u8>();
                                          let l58 = *ptr0.add(40).cast::<usize>();
                                          let len59 = l58;
                                          let bytes59 = _rt::Vec::from_raw_parts(l57.cast(), len59, len59);

                                          _rt::string_lift(bytes59)
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpResponseTransferCoding(e68)
                                }
                                32 => {
                                  let e68 = {
                                    let l60 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l60 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l61 = *ptr0.add(36).cast::<*mut u8>();
                                          let l62 = *ptr0.add(40).cast::<usize>();
                                          let len63 = l62;
                                          let bytes63 = _rt::Vec::from_raw_parts(l61.cast(), len63, len63);

                                          _rt::string_lift(bytes63)
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpResponseContentCoding(e68)
                                }
                                33 => {
                                  ErrorCode::HttpResponseTimeout
                                }
                                34 => {
                                  ErrorCode::HttpUpgradeFailed
                                }
                                35 => {
                                  ErrorCode::HttpProtocolError
                                }
                                36 => {
                                  ErrorCode::LoopDetected
                                }
                                37 => {
                                  ErrorCode::ConfigurationError
                                }
                                n => {
                                  debug_assert_eq!(n, 38, "invalid enum discriminant");
                                  let e68 = {
                                    let l64 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l64 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l65 = *ptr0.add(36).cast::<*mut u8>();
                                          let l66 = *ptr0.add(40).cast::<usize>();
                                          let len67 = l66;
                                          let bytes67 = _rt::Vec::from_raw_parts(l65.cast(), len67, len67);

                                          _rt::string_lift(bytes67)
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::InternalError(e68)
                                }
                              };

                              v68
                            };
                            Err(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      Ok(e)
                    }
                    1 => {
                      let e = ();
                      Err(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  }
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingResponse {
        #[allow(unused_unsafe, clippy::all)]
        /// Construct an `outgoing-response`, with a default `status-code` of `200`.
        /// If a different `status-code` is needed, it must be set via the
        /// `set-status-code` method.
        ///
        /// * `headers` is the HTTP Headers for the Response.
        pub fn new(headers: Headers,) -> Self{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[constructor]outgoing-response"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((&headers).take_handle() as i32);
            OutgoingResponse::from_handle(ret as u32)
          }
        }
      }
      impl OutgoingResponse {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the HTTP Status Code for the Response.
        pub fn status_code(&self,) -> StatusCode{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-response.status-code"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            ret as u16
          }
        }
      }
      impl OutgoingResponse {
        #[allow(unused_unsafe, clippy::all)]
        /// Set the HTTP Status Code for the Response. Fails if the status-code
        /// given is not a valid http status code.
        pub fn set_status_code(&self,status_code: StatusCode,) -> Result<(),()>{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-response.set-status-code"]
              fn wit_import(_: i32, _: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32, _rt::as_i32(status_code));
            match ret {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingResponse {
        #[allow(unused_unsafe, clippy::all)]
        /// Get the headers associated with the Request.
        ///
        /// The returned `headers` resource is immutable: `set`, `append`, and
        /// `delete` operations will fail with `header-error.immutable`.
        ///
        /// This headers resource is a child: it must be dropped before the parent
        /// `outgoing-request` is dropped, or its ownership is transfered to
        /// another component by e.g. `outgoing-handler.handle`.
        pub fn headers(&self,) -> Headers{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-response.headers"]
              fn wit_import(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            Fields::from_handle(ret as u32)
          }
        }
      }
      impl OutgoingResponse {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns the resource corresponding to the outgoing Body for this Response.
        ///
        /// Returns success on the first call: the `outgoing-body` resource for
        /// this `outgoing-response` can be retrieved at most once. Subsequent
        /// calls will return error.
        pub fn body(&self,) -> Result<OutgoingBody,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-response.body"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  OutgoingBody::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingBody {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns a stream for writing the body contents.
        ///
        /// The returned `output-stream` is a child resource: it must be dropped
        /// before the parent `outgoing-body` resource is dropped (or finished),
        /// otherwise the `outgoing-body` drop or `finish` will trap.
        ///
        /// Returns success on the first call: the `output-stream` resource for
        /// this `outgoing-body` may be retrieved at most once. Subsequent calls
        /// will return error.
        pub fn write(&self,) -> Result<OutputStream,()>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]outgoing-body.write"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<i32>();

                  super::super::super::wasi::io::streams::OutputStream::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutgoingBody {
        #[allow(unused_unsafe, clippy::all)]
        /// Finalize an outgoing body, optionally providing trailers. This must be
        /// called to signal that the response is complete. If the `outgoing-body`
        /// is dropped without calling `outgoing-body.finalize`, the implementation
        /// should treat the body as corrupted.
        ///
        /// Fails if the body's `outgoing-request` or `outgoing-response` was
        /// constructed with a Content-Length header, and the contents written
        /// to the body (via `write`) does not match the value given in the
        /// Content-Length.
        pub fn finish(this: OutgoingBody,trailers: Option<Trailers>,) -> Result<(),ErrorCode>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 40]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 40]);
            let (result0_0,result0_1,) = match &trailers {
              Some(e) => (1i32, (e).take_handle() as i32),
              None => {
                (0i32, 0i32)
              },
            };let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[static]outgoing-body.finish"]
              fn wit_import(_: i32, _: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: *mut u8, ){ unreachable!() }
            wit_import((&this).take_handle() as i32, result0_0, result0_1, ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr1.add(8).cast::<u8>());
                  let v65 = match l3 {
                    0 => {
                      ErrorCode::DnsTimeout
                    }
                    1 => {
                      let e65 = {
                        let l4 = i32::from(*ptr1.add(16).cast::<u8>());
                        let l8 = i32::from(*ptr1.add(28).cast::<u8>());

                        DnsErrorPayload{
                          rcode: match l4 {
                            0 => None,
                            1 => {
                              let e = {
                                let l5 = *ptr1.add(20).cast::<*mut u8>();
                                let l6 = *ptr1.add(24).cast::<usize>();
                                let len7 = l6;
                                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                                _rt::string_lift(bytes7)
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                          info_code: match l8 {
                            0 => None,
                            1 => {
                              let e = {
                                let l9 = i32::from(*ptr1.add(30).cast::<u16>());

                                l9 as u16
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                        }
                      };
                      ErrorCode::DnsError(e65)
                    }
                    2 => {
                      ErrorCode::DestinationNotFound
                    }
                    3 => {
                      ErrorCode::DestinationUnavailable
                    }
                    4 => {
                      ErrorCode::DestinationIpProhibited
                    }
                    5 => {
                      ErrorCode::DestinationIpUnroutable
                    }
                    6 => {
                      ErrorCode::ConnectionRefused
                    }
                    7 => {
                      ErrorCode::ConnectionTerminated
                    }
                    8 => {
                      ErrorCode::ConnectionTimeout
                    }
                    9 => {
                      ErrorCode::ConnectionReadTimeout
                    }
                    10 => {
                      ErrorCode::ConnectionWriteTimeout
                    }
                    11 => {
                      ErrorCode::ConnectionLimitReached
                    }
                    12 => {
                      ErrorCode::TlsProtocolError
                    }
                    13 => {
                      ErrorCode::TlsCertificateError
                    }
                    14 => {
                      let e65 = {
                        let l10 = i32::from(*ptr1.add(16).cast::<u8>());
                        let l12 = i32::from(*ptr1.add(20).cast::<u8>());

                        TlsAlertReceivedPayload{
                          alert_id: match l10 {
                            0 => None,
                            1 => {
                              let e = {
                                let l11 = i32::from(*ptr1.add(17).cast::<u8>());

                                l11 as u8
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                          alert_message: match l12 {
                            0 => None,
                            1 => {
                              let e = {
                                let l13 = *ptr1.add(24).cast::<*mut u8>();
                                let l14 = *ptr1.add(28).cast::<usize>();
                                let len15 = l14;
                                let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);

                                _rt::string_lift(bytes15)
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                        }
                      };
                      ErrorCode::TlsAlertReceived(e65)
                    }
                    15 => {
                      ErrorCode::HttpRequestDenied
                    }
                    16 => {
                      ErrorCode::HttpRequestLengthRequired
                    }
                    17 => {
                      let e65 = {
                        let l16 = i32::from(*ptr1.add(16).cast::<u8>());

                        match l16 {
                          0 => None,
                          1 => {
                            let e = {
                              let l17 = *ptr1.add(24).cast::<i64>();

                              l17 as u64
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      ErrorCode::HttpRequestBodySize(e65)
                    }
                    18 => {
                      ErrorCode::HttpRequestMethodInvalid
                    }
                    19 => {
                      ErrorCode::HttpRequestUriInvalid
                    }
                    20 => {
                      ErrorCode::HttpRequestUriTooLong
                    }
                    21 => {
                      let e65 = {
                        let l18 = i32::from(*ptr1.add(16).cast::<u8>());

                        match l18 {
                          0 => None,
                          1 => {
                            let e = {
                              let l19 = *ptr1.add(20).cast::<i32>();

                              l19 as u32
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      ErrorCode::HttpRequestHeaderSectionSize(e65)
                    }
                    22 => {
                      let e65 = {
                        let l20 = i32::from(*ptr1.add(16).cast::<u8>());

                        match l20 {
                          0 => None,
                          1 => {
                            let e = {
                              let l21 = i32::from(*ptr1.add(20).cast::<u8>());
                              let l25 = i32::from(*ptr1.add(32).cast::<u8>());

                              FieldSizePayload{
                                field_name: match l21 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l22 = *ptr1.add(24).cast::<*mut u8>();
                                      let l23 = *ptr1.add(28).cast::<usize>();
                                      let len24 = l23;
                                      let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);

                                      _rt::string_lift(bytes24)
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                field_size: match l25 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l26 = *ptr1.add(36).cast::<i32>();

                                      l26 as u32
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                              }
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      ErrorCode::HttpRequestHeaderSize(e65)
                    }
                    23 => {
                      let e65 = {
                        let l27 = i32::from(*ptr1.add(16).cast::<u8>());

                        match l27 {
                          0 => None,
                          1 => {
                            let e = {
                              let l28 = *ptr1.add(20).cast::<i32>();

                              l28 as u32
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      ErrorCode::HttpRequestTrailerSectionSize(e65)
                    }
                    24 => {
                      let e65 = {
                        let l29 = i32::from(*ptr1.add(16).cast::<u8>());
                        let l33 = i32::from(*ptr1.add(28).cast::<u8>());

                        FieldSizePayload{
                          field_name: match l29 {
                            0 => None,
                            1 => {
                              let e = {
                                let l30 = *ptr1.add(20).cast::<*mut u8>();
                                let l31 = *ptr1.add(24).cast::<usize>();
                                let len32 = l31;
                                let bytes32 = _rt::Vec::from_raw_parts(l30.cast(), len32, len32);

                                _rt::string_lift(bytes32)
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                          field_size: match l33 {
                            0 => None,
                            1 => {
                              let e = {
                                let l34 = *ptr1.add(32).cast::<i32>();

                                l34 as u32
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                        }
                      };
                      ErrorCode::HttpRequestTrailerSize(e65)
                    }
                    25 => {
                      ErrorCode::HttpResponseIncomplete
                    }
                    26 => {
                      let e65 = {
                        let l35 = i32::from(*ptr1.add(16).cast::<u8>());

                        match l35 {
                          0 => None,
                          1 => {
                            let e = {
                              let l36 = *ptr1.add(20).cast::<i32>();

                              l36 as u32
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      ErrorCode::HttpResponseHeaderSectionSize(e65)
                    }
                    27 => {
                      let e65 = {
                        let l37 = i32::from(*ptr1.add(16).cast::<u8>());
                        let l41 = i32::from(*ptr1.add(28).cast::<u8>());

                        FieldSizePayload{
                          field_name: match l37 {
                            0 => None,
                            1 => {
                              let e = {
                                let l38 = *ptr1.add(20).cast::<*mut u8>();
                                let l39 = *ptr1.add(24).cast::<usize>();
                                let len40 = l39;
                                let bytes40 = _rt::Vec::from_raw_parts(l38.cast(), len40, len40);

                                _rt::string_lift(bytes40)
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                          field_size: match l41 {
                            0 => None,
                            1 => {
                              let e = {
                                let l42 = *ptr1.add(32).cast::<i32>();

                                l42 as u32
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                        }
                      };
                      ErrorCode::HttpResponseHeaderSize(e65)
                    }
                    28 => {
                      let e65 = {
                        let l43 = i32::from(*ptr1.add(16).cast::<u8>());

                        match l43 {
                          0 => None,
                          1 => {
                            let e = {
                              let l44 = *ptr1.add(24).cast::<i64>();

                              l44 as u64
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      ErrorCode::HttpResponseBodySize(e65)
                    }
                    29 => {
                      let e65 = {
                        let l45 = i32::from(*ptr1.add(16).cast::<u8>());

                        match l45 {
                          0 => None,
                          1 => {
                            let e = {
                              let l46 = *ptr1.add(20).cast::<i32>();

                              l46 as u32
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      ErrorCode::HttpResponseTrailerSectionSize(e65)
                    }
                    30 => {
                      let e65 = {
                        let l47 = i32::from(*ptr1.add(16).cast::<u8>());
                        let l51 = i32::from(*ptr1.add(28).cast::<u8>());

                        FieldSizePayload{
                          field_name: match l47 {
                            0 => None,
                            1 => {
                              let e = {
                                let l48 = *ptr1.add(20).cast::<*mut u8>();
                                let l49 = *ptr1.add(24).cast::<usize>();
                                let len50 = l49;
                                let bytes50 = _rt::Vec::from_raw_parts(l48.cast(), len50, len50);

                                _rt::string_lift(bytes50)
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                          field_size: match l51 {
                            0 => None,
                            1 => {
                              let e = {
                                let l52 = *ptr1.add(32).cast::<i32>();

                                l52 as u32
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                        }
                      };
                      ErrorCode::HttpResponseTrailerSize(e65)
                    }
                    31 => {
                      let e65 = {
                        let l53 = i32::from(*ptr1.add(16).cast::<u8>());

                        match l53 {
                          0 => None,
                          1 => {
                            let e = {
                              let l54 = *ptr1.add(20).cast::<*mut u8>();
                              let l55 = *ptr1.add(24).cast::<usize>();
                              let len56 = l55;
                              let bytes56 = _rt::Vec::from_raw_parts(l54.cast(), len56, len56);

                              _rt::string_lift(bytes56)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      ErrorCode::HttpResponseTransferCoding(e65)
                    }
                    32 => {
                      let e65 = {
                        let l57 = i32::from(*ptr1.add(16).cast::<u8>());

                        match l57 {
                          0 => None,
                          1 => {
                            let e = {
                              let l58 = *ptr1.add(20).cast::<*mut u8>();
                              let l59 = *ptr1.add(24).cast::<usize>();
                              let len60 = l59;
                              let bytes60 = _rt::Vec::from_raw_parts(l58.cast(), len60, len60);

                              _rt::string_lift(bytes60)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      ErrorCode::HttpResponseContentCoding(e65)
                    }
                    33 => {
                      ErrorCode::HttpResponseTimeout
                    }
                    34 => {
                      ErrorCode::HttpUpgradeFailed
                    }
                    35 => {
                      ErrorCode::HttpProtocolError
                    }
                    36 => {
                      ErrorCode::LoopDetected
                    }
                    37 => {
                      ErrorCode::ConfigurationError
                    }
                    n => {
                      debug_assert_eq!(n, 38, "invalid enum discriminant");
                      let e65 = {
                        let l61 = i32::from(*ptr1.add(16).cast::<u8>());

                        match l61 {
                          0 => None,
                          1 => {
                            let e = {
                              let l62 = *ptr1.add(20).cast::<*mut u8>();
                              let l63 = *ptr1.add(24).cast::<usize>();
                              let len64 = l63;
                              let bytes64 = _rt::Vec::from_raw_parts(l62.cast(), len64, len64);

                              _rt::string_lift(bytes64)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      ErrorCode::InternalError(e65)
                    }
                  };

                  v65
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl FutureIncomingResponse {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns a pollable which becomes ready when either the Response has
        /// been received, or an error has occured. When this pollable is ready,
        /// the `get` method will return `some`.
        /// subscribe: func() -> pollable; // Hermes does NOT support `poll`
        /// Returns the incoming HTTP Response, or an error, once one is ready.
        ///
        /// The outer `option` represents future readiness. Users can wait on this
        /// `option` to become `some` using the `subscribe` method.
        ///
        /// The outer `result` is used to retrieve the response or error at most
        /// once. It will be success on the first call in which the outer option
        /// is `some`, and error on subsequent calls.
        ///
        /// The inner `result` represents that either the incoming HTTP Response
        /// status and headers have recieved successfully, or that an error
        /// occured. Errors may also occur while consuming the response body,
        /// but those will be reported by the `incoming-body` and its
        /// `output-stream` child.
        pub fn get(&self,) -> Option<Result<Result<IncomingResponse,ErrorCode>,()>>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 56]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 56]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:http/types@0.2.0")]
            extern "C" {
              #[link_name = "[method]future-incoming-response.get"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => None,
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(8).cast::<u8>());

                  match l2 {
                    0 => {
                      let e = {
                        let l3 = i32::from(*ptr0.add(16).cast::<u8>());

                        match l3 {
                          0 => {
                            let e = {
                              let l4 = *ptr0.add(24).cast::<i32>();

                              IncomingResponse::from_handle(l4 as u32)
                            };
                            Ok(e)
                          }
                          1 => {
                            let e = {
                              let l5 = i32::from(*ptr0.add(24).cast::<u8>());
                              let v67 = match l5 {
                                0 => {
                                  ErrorCode::DnsTimeout
                                }
                                1 => {
                                  let e67 = {
                                    let l6 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l10 = i32::from(*ptr0.add(44).cast::<u8>());

                                    DnsErrorPayload{
                                      rcode: match l6 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l7 = *ptr0.add(36).cast::<*mut u8>();
                                            let l8 = *ptr0.add(40).cast::<usize>();
                                            let len9 = l8;
                                            let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                                            _rt::string_lift(bytes9)
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                      info_code: match l10 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l11 = i32::from(*ptr0.add(46).cast::<u16>());

                                            l11 as u16
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                    }
                                  };
                                  ErrorCode::DnsError(e67)
                                }
                                2 => {
                                  ErrorCode::DestinationNotFound
                                }
                                3 => {
                                  ErrorCode::DestinationUnavailable
                                }
                                4 => {
                                  ErrorCode::DestinationIpProhibited
                                }
                                5 => {
                                  ErrorCode::DestinationIpUnroutable
                                }
                                6 => {
                                  ErrorCode::ConnectionRefused
                                }
                                7 => {
                                  ErrorCode::ConnectionTerminated
                                }
                                8 => {
                                  ErrorCode::ConnectionTimeout
                                }
                                9 => {
                                  ErrorCode::ConnectionReadTimeout
                                }
                                10 => {
                                  ErrorCode::ConnectionWriteTimeout
                                }
                                11 => {
                                  ErrorCode::ConnectionLimitReached
                                }
                                12 => {
                                  ErrorCode::TlsProtocolError
                                }
                                13 => {
                                  ErrorCode::TlsCertificateError
                                }
                                14 => {
                                  let e67 = {
                                    let l12 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l14 = i32::from(*ptr0.add(36).cast::<u8>());

                                    TlsAlertReceivedPayload{
                                      alert_id: match l12 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l13 = i32::from(*ptr0.add(33).cast::<u8>());

                                            l13 as u8
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                      alert_message: match l14 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l15 = *ptr0.add(40).cast::<*mut u8>();
                                            let l16 = *ptr0.add(44).cast::<usize>();
                                            let len17 = l16;
                                            let bytes17 = _rt::Vec::from_raw_parts(l15.cast(), len17, len17);

                                            _rt::string_lift(bytes17)
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                    }
                                  };
                                  ErrorCode::TlsAlertReceived(e67)
                                }
                                15 => {
                                  ErrorCode::HttpRequestDenied
                                }
                                16 => {
                                  ErrorCode::HttpRequestLengthRequired
                                }
                                17 => {
                                  let e67 = {
                                    let l18 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l18 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l19 = *ptr0.add(40).cast::<i64>();

                                          l19 as u64
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpRequestBodySize(e67)
                                }
                                18 => {
                                  ErrorCode::HttpRequestMethodInvalid
                                }
                                19 => {
                                  ErrorCode::HttpRequestUriInvalid
                                }
                                20 => {
                                  ErrorCode::HttpRequestUriTooLong
                                }
                                21 => {
                                  let e67 = {
                                    let l20 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l20 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l21 = *ptr0.add(36).cast::<i32>();

                                          l21 as u32
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpRequestHeaderSectionSize(e67)
                                }
                                22 => {
                                  let e67 = {
                                    let l22 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l22 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l23 = i32::from(*ptr0.add(36).cast::<u8>());
                                          let l27 = i32::from(*ptr0.add(48).cast::<u8>());

                                          FieldSizePayload{
                                            field_name: match l23 {
                                              0 => None,
                                              1 => {
                                                let e = {
                                                  let l24 = *ptr0.add(40).cast::<*mut u8>();
                                                  let l25 = *ptr0.add(44).cast::<usize>();
                                                  let len26 = l25;
                                                  let bytes26 = _rt::Vec::from_raw_parts(l24.cast(), len26, len26);

                                                  _rt::string_lift(bytes26)
                                                };
                                                Some(e)
                                              }
                                              _ => _rt::invalid_enum_discriminant(),
                                            },
                                            field_size: match l27 {
                                              0 => None,
                                              1 => {
                                                let e = {
                                                  let l28 = *ptr0.add(52).cast::<i32>();

                                                  l28 as u32
                                                };
                                                Some(e)
                                              }
                                              _ => _rt::invalid_enum_discriminant(),
                                            },
                                          }
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpRequestHeaderSize(e67)
                                }
                                23 => {
                                  let e67 = {
                                    let l29 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l29 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l30 = *ptr0.add(36).cast::<i32>();

                                          l30 as u32
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpRequestTrailerSectionSize(e67)
                                }
                                24 => {
                                  let e67 = {
                                    let l31 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l35 = i32::from(*ptr0.add(44).cast::<u8>());

                                    FieldSizePayload{
                                      field_name: match l31 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l32 = *ptr0.add(36).cast::<*mut u8>();
                                            let l33 = *ptr0.add(40).cast::<usize>();
                                            let len34 = l33;
                                            let bytes34 = _rt::Vec::from_raw_parts(l32.cast(), len34, len34);

                                            _rt::string_lift(bytes34)
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                      field_size: match l35 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l36 = *ptr0.add(48).cast::<i32>();

                                            l36 as u32
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                    }
                                  };
                                  ErrorCode::HttpRequestTrailerSize(e67)
                                }
                                25 => {
                                  ErrorCode::HttpResponseIncomplete
                                }
                                26 => {
                                  let e67 = {
                                    let l37 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l37 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l38 = *ptr0.add(36).cast::<i32>();

                                          l38 as u32
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpResponseHeaderSectionSize(e67)
                                }
                                27 => {
                                  let e67 = {
                                    let l39 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l43 = i32::from(*ptr0.add(44).cast::<u8>());

                                    FieldSizePayload{
                                      field_name: match l39 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l40 = *ptr0.add(36).cast::<*mut u8>();
                                            let l41 = *ptr0.add(40).cast::<usize>();
                                            let len42 = l41;
                                            let bytes42 = _rt::Vec::from_raw_parts(l40.cast(), len42, len42);

                                            _rt::string_lift(bytes42)
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                      field_size: match l43 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l44 = *ptr0.add(48).cast::<i32>();

                                            l44 as u32
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                    }
                                  };
                                  ErrorCode::HttpResponseHeaderSize(e67)
                                }
                                28 => {
                                  let e67 = {
                                    let l45 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l45 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l46 = *ptr0.add(40).cast::<i64>();

                                          l46 as u64
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpResponseBodySize(e67)
                                }
                                29 => {
                                  let e67 = {
                                    let l47 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l47 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l48 = *ptr0.add(36).cast::<i32>();

                                          l48 as u32
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpResponseTrailerSectionSize(e67)
                                }
                                30 => {
                                  let e67 = {
                                    let l49 = i32::from(*ptr0.add(32).cast::<u8>());
                                    let l53 = i32::from(*ptr0.add(44).cast::<u8>());

                                    FieldSizePayload{
                                      field_name: match l49 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l50 = *ptr0.add(36).cast::<*mut u8>();
                                            let l51 = *ptr0.add(40).cast::<usize>();
                                            let len52 = l51;
                                            let bytes52 = _rt::Vec::from_raw_parts(l50.cast(), len52, len52);

                                            _rt::string_lift(bytes52)
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                      field_size: match l53 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l54 = *ptr0.add(48).cast::<i32>();

                                            l54 as u32
                                          };
                                          Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                      },
                                    }
                                  };
                                  ErrorCode::HttpResponseTrailerSize(e67)
                                }
                                31 => {
                                  let e67 = {
                                    let l55 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l55 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l56 = *ptr0.add(36).cast::<*mut u8>();
                                          let l57 = *ptr0.add(40).cast::<usize>();
                                          let len58 = l57;
                                          let bytes58 = _rt::Vec::from_raw_parts(l56.cast(), len58, len58);

                                          _rt::string_lift(bytes58)
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpResponseTransferCoding(e67)
                                }
                                32 => {
                                  let e67 = {
                                    let l59 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l59 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l60 = *ptr0.add(36).cast::<*mut u8>();
                                          let l61 = *ptr0.add(40).cast::<usize>();
                                          let len62 = l61;
                                          let bytes62 = _rt::Vec::from_raw_parts(l60.cast(), len62, len62);

                                          _rt::string_lift(bytes62)
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::HttpResponseContentCoding(e67)
                                }
                                33 => {
                                  ErrorCode::HttpResponseTimeout
                                }
                                34 => {
                                  ErrorCode::HttpUpgradeFailed
                                }
                                35 => {
                                  ErrorCode::HttpProtocolError
                                }
                                36 => {
                                  ErrorCode::LoopDetected
                                }
                                37 => {
                                  ErrorCode::ConfigurationError
                                }
                                n => {
                                  debug_assert_eq!(n, 38, "invalid enum discriminant");
                                  let e67 = {
                                    let l63 = i32::from(*ptr0.add(32).cast::<u8>());

                                    match l63 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l64 = *ptr0.add(36).cast::<*mut u8>();
                                          let l65 = *ptr0.add(40).cast::<usize>();
                                          let len66 = l65;
                                          let bytes66 = _rt::Vec::from_raw_parts(l64.cast(), len66, len66);

                                          _rt::string_lift(bytes66)
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    }
                                  };
                                  ErrorCode::InternalError(e67)
                                }
                              };

                              v67
                            };
                            Err(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        }
                      };
                      Ok(e)
                    }
                    1 => {
                      let e = ();
                      Err(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  }
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod outgoing_handler {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type OutgoingRequest = super::super::super::wasi::http::types::OutgoingRequest;
      pub type RequestOptions = super::super::super::wasi::http::types::RequestOptions;
      pub type FutureIncomingResponse = super::super::super::wasi::http::types::FutureIncomingResponse;
      pub type ErrorCode = super::super::super::wasi::http::types::ErrorCode;
      #[allow(unused_unsafe, clippy::all)]
      /// This function is invoked with an outgoing HTTP Request, and it returns
      /// a resource `future-incoming-response` which represents an HTTP Response
      /// which may arrive in the future.
      ///
      /// The `options` argument accepts optional parameters for the HTTP
      /// protocol's transport layer.
      ///
      /// This function may return an error if the `outgoing-request` is invalid
      /// or not allowed to be made. Otherwise, protocol errors are reported
      /// through the `future-incoming-response`.
      pub fn handle(request: OutgoingRequest,options: Option<RequestOptions>,) -> Result<FutureIncomingResponse,ErrorCode>{
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 40]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 40]);
          let (result0_0,result0_1,) = match &options {
            Some(e) => (1i32, (e).take_handle() as i32),
            None => {
              (0i32, 0i32)
            },
          };let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:http/outgoing-handler@0.2.0")]
          extern "C" {
            #[link_name = "handle"]
            fn wit_import(_: i32, _: i32, _: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: *mut u8, ){ unreachable!() }
          wit_import((&request).take_handle() as i32, result0_0, result0_1, ptr1);
          let l2 = i32::from(*ptr1.add(0).cast::<u8>());
          match l2 {
            0 => {
              let e = {
                let l3 = *ptr1.add(8).cast::<i32>();

                super::super::super::wasi::http::types::FutureIncomingResponse::from_handle(l3 as u32)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = i32::from(*ptr1.add(8).cast::<u8>());
                use super::super::super::wasi::http::types::ErrorCode as V66;
                let v66 = match l4 {
                  0 => {
                    V66::DnsTimeout
                  }
                  1 => {
                    let e66 = {
                      let l5 = i32::from(*ptr1.add(16).cast::<u8>());
                      let l9 = i32::from(*ptr1.add(28).cast::<u8>());

                      super::super::super::wasi::http::types::DnsErrorPayload{
                        rcode: match l5 {
                          0 => None,
                          1 => {
                            let e = {
                              let l6 = *ptr1.add(20).cast::<*mut u8>();
                              let l7 = *ptr1.add(24).cast::<usize>();
                              let len8 = l7;
                              let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);

                              _rt::string_lift(bytes8)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        info_code: match l9 {
                          0 => None,
                          1 => {
                            let e = {
                              let l10 = i32::from(*ptr1.add(30).cast::<u16>());

                              l10 as u16
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    V66::DnsError(e66)
                  }
                  2 => {
                    V66::DestinationNotFound
                  }
                  3 => {
                    V66::DestinationUnavailable
                  }
                  4 => {
                    V66::DestinationIpProhibited
                  }
                  5 => {
                    V66::DestinationIpUnroutable
                  }
                  6 => {
                    V66::ConnectionRefused
                  }
                  7 => {
                    V66::ConnectionTerminated
                  }
                  8 => {
                    V66::ConnectionTimeout
                  }
                  9 => {
                    V66::ConnectionReadTimeout
                  }
                  10 => {
                    V66::ConnectionWriteTimeout
                  }
                  11 => {
                    V66::ConnectionLimitReached
                  }
                  12 => {
                    V66::TlsProtocolError
                  }
                  13 => {
                    V66::TlsCertificateError
                  }
                  14 => {
                    let e66 = {
                      let l11 = i32::from(*ptr1.add(16).cast::<u8>());
                      let l13 = i32::from(*ptr1.add(20).cast::<u8>());

                      super::super::super::wasi::http::types::TlsAlertReceivedPayload{
                        alert_id: match l11 {
                          0 => None,
                          1 => {
                            let e = {
                              let l12 = i32::from(*ptr1.add(17).cast::<u8>());

                              l12 as u8
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        alert_message: match l13 {
                          0 => None,
                          1 => {
                            let e = {
                              let l14 = *ptr1.add(24).cast::<*mut u8>();
                              let l15 = *ptr1.add(28).cast::<usize>();
                              let len16 = l15;
                              let bytes16 = _rt::Vec::from_raw_parts(l14.cast(), len16, len16);

                              _rt::string_lift(bytes16)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    V66::TlsAlertReceived(e66)
                  }
                  15 => {
                    V66::HttpRequestDenied
                  }
                  16 => {
                    V66::HttpRequestLengthRequired
                  }
                  17 => {
                    let e66 = {
                      let l17 = i32::from(*ptr1.add(16).cast::<u8>());

                      match l17 {
                        0 => None,
                        1 => {
                          let e = {
                            let l18 = *ptr1.add(24).cast::<i64>();

                            l18 as u64
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    V66::HttpRequestBodySize(e66)
                  }
                  18 => {
                    V66::HttpRequestMethodInvalid
                  }
                  19 => {
                    V66::HttpRequestUriInvalid
                  }
                  20 => {
                    V66::HttpRequestUriTooLong
                  }
                  21 => {
                    let e66 = {
                      let l19 = i32::from(*ptr1.add(16).cast::<u8>());

                      match l19 {
                        0 => None,
                        1 => {
                          let e = {
                            let l20 = *ptr1.add(20).cast::<i32>();

                            l20 as u32
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    V66::HttpRequestHeaderSectionSize(e66)
                  }
                  22 => {
                    let e66 = {
                      let l21 = i32::from(*ptr1.add(16).cast::<u8>());

                      match l21 {
                        0 => None,
                        1 => {
                          let e = {
                            let l22 = i32::from(*ptr1.add(20).cast::<u8>());
                            let l26 = i32::from(*ptr1.add(32).cast::<u8>());

                            super::super::super::wasi::http::types::FieldSizePayload{
                              field_name: match l22 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l23 = *ptr1.add(24).cast::<*mut u8>();
                                    let l24 = *ptr1.add(28).cast::<usize>();
                                    let len25 = l24;
                                    let bytes25 = _rt::Vec::from_raw_parts(l23.cast(), len25, len25);

                                    _rt::string_lift(bytes25)
                                  };
                                  Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                              },
                              field_size: match l26 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l27 = *ptr1.add(36).cast::<i32>();

                                    l27 as u32
                                  };
                                  Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                              },
                            }
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    V66::HttpRequestHeaderSize(e66)
                  }
                  23 => {
                    let e66 = {
                      let l28 = i32::from(*ptr1.add(16).cast::<u8>());

                      match l28 {
                        0 => None,
                        1 => {
                          let e = {
                            let l29 = *ptr1.add(20).cast::<i32>();

                            l29 as u32
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    V66::HttpRequestTrailerSectionSize(e66)
                  }
                  24 => {
                    let e66 = {
                      let l30 = i32::from(*ptr1.add(16).cast::<u8>());
                      let l34 = i32::from(*ptr1.add(28).cast::<u8>());

                      super::super::super::wasi::http::types::FieldSizePayload{
                        field_name: match l30 {
                          0 => None,
                          1 => {
                            let e = {
                              let l31 = *ptr1.add(20).cast::<*mut u8>();
                              let l32 = *ptr1.add(24).cast::<usize>();
                              let len33 = l32;
                              let bytes33 = _rt::Vec::from_raw_parts(l31.cast(), len33, len33);

                              _rt::string_lift(bytes33)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        field_size: match l34 {
                          0 => None,
                          1 => {
                            let e = {
                              let l35 = *ptr1.add(32).cast::<i32>();

                              l35 as u32
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    V66::HttpRequestTrailerSize(e66)
                  }
                  25 => {
                    V66::HttpResponseIncomplete
                  }
                  26 => {
                    let e66 = {
                      let l36 = i32::from(*ptr1.add(16).cast::<u8>());

                      match l36 {
                        0 => None,
                        1 => {
                          let e = {
                            let l37 = *ptr1.add(20).cast::<i32>();

                            l37 as u32
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    V66::HttpResponseHeaderSectionSize(e66)
                  }
                  27 => {
                    let e66 = {
                      let l38 = i32::from(*ptr1.add(16).cast::<u8>());
                      let l42 = i32::from(*ptr1.add(28).cast::<u8>());

                      super::super::super::wasi::http::types::FieldSizePayload{
                        field_name: match l38 {
                          0 => None,
                          1 => {
                            let e = {
                              let l39 = *ptr1.add(20).cast::<*mut u8>();
                              let l40 = *ptr1.add(24).cast::<usize>();
                              let len41 = l40;
                              let bytes41 = _rt::Vec::from_raw_parts(l39.cast(), len41, len41);

                              _rt::string_lift(bytes41)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        field_size: match l42 {
                          0 => None,
                          1 => {
                            let e = {
                              let l43 = *ptr1.add(32).cast::<i32>();

                              l43 as u32
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    V66::HttpResponseHeaderSize(e66)
                  }
                  28 => {
                    let e66 = {
                      let l44 = i32::from(*ptr1.add(16).cast::<u8>());

                      match l44 {
                        0 => None,
                        1 => {
                          let e = {
                            let l45 = *ptr1.add(24).cast::<i64>();

                            l45 as u64
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    V66::HttpResponseBodySize(e66)
                  }
                  29 => {
                    let e66 = {
                      let l46 = i32::from(*ptr1.add(16).cast::<u8>());

                      match l46 {
                        0 => None,
                        1 => {
                          let e = {
                            let l47 = *ptr1.add(20).cast::<i32>();

                            l47 as u32
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    V66::HttpResponseTrailerSectionSize(e66)
                  }
                  30 => {
                    let e66 = {
                      let l48 = i32::from(*ptr1.add(16).cast::<u8>());
                      let l52 = i32::from(*ptr1.add(28).cast::<u8>());

                      super::super::super::wasi::http::types::FieldSizePayload{
                        field_name: match l48 {
                          0 => None,
                          1 => {
                            let e = {
                              let l49 = *ptr1.add(20).cast::<*mut u8>();
                              let l50 = *ptr1.add(24).cast::<usize>();
                              let len51 = l50;
                              let bytes51 = _rt::Vec::from_raw_parts(l49.cast(), len51, len51);

                              _rt::string_lift(bytes51)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        field_size: match l52 {
                          0 => None,
                          1 => {
                            let e = {
                              let l53 = *ptr1.add(32).cast::<i32>();

                              l53 as u32
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    V66::HttpResponseTrailerSize(e66)
                  }
                  31 => {
                    let e66 = {
                      let l54 = i32::from(*ptr1.add(16).cast::<u8>());

                      match l54 {
                        0 => None,
                        1 => {
                          let e = {
                            let l55 = *ptr1.add(20).cast::<*mut u8>();
                            let l56 = *ptr1.add(24).cast::<usize>();
                            let len57 = l56;
                            let bytes57 = _rt::Vec::from_raw_parts(l55.cast(), len57, len57);

                            _rt::string_lift(bytes57)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    V66::HttpResponseTransferCoding(e66)
                  }
                  32 => {
                    let e66 = {
                      let l58 = i32::from(*ptr1.add(16).cast::<u8>());

                      match l58 {
                        0 => None,
                        1 => {
                          let e = {
                            let l59 = *ptr1.add(20).cast::<*mut u8>();
                            let l60 = *ptr1.add(24).cast::<usize>();
                            let len61 = l60;
                            let bytes61 = _rt::Vec::from_raw_parts(l59.cast(), len61, len61);

                            _rt::string_lift(bytes61)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    V66::HttpResponseContentCoding(e66)
                  }
                  33 => {
                    V66::HttpResponseTimeout
                  }
                  34 => {
                    V66::HttpUpgradeFailed
                  }
                  35 => {
                    V66::HttpProtocolError
                  }
                  36 => {
                    V66::LoopDetected
                  }
                  37 => {
                    V66::ConfigurationError
                  }
                  n => {
                    debug_assert_eq!(n, 38, "invalid enum discriminant");
                    let e66 = {
                      let l62 = i32::from(*ptr1.add(16).cast::<u8>());

                      match l62 {
                        0 => None,
                        1 => {
                          let e = {
                            let l63 = *ptr1.add(20).cast::<*mut u8>();
                            let l64 = *ptr1.add(24).cast::<usize>();
                            let len65 = l64;
                            let bytes65 = _rt::Vec::from_raw_parts(l63.cast(), len65, len65);

                            _rt::string_lift(bytes65)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      }
                    };
                    V66::InternalError(e66)
                  }
                };

                v66
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod io {
    #[allow(dead_code, clippy::all)]
    pub mod error {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      /// A resource which represents some error information.
      ///
      /// The only method provided by this resource is `to-debug-string`,
      /// which provides some human-readable information about the error.
      ///
      /// In the `wasi:io` package, this resource is returned through the
      /// `wasi:io/streams/stream-error` type.
      ///
      /// To provide more specific error information, other interfaces may
      /// provide functions to further "downcast" this error into more specific
      /// error information. For example, `error`s returned in streams derived
      /// from filesystem types to be described using the filesystem's own
      /// error-code type, using the function
      /// `wasi:filesystem/types/filesystem-error-code`, which takes a parameter
      /// `borrow<error>` and returns
      /// `option<wasi:filesystem/types/error-code>`.
      ///
      /// The set of functions which can "downcast" an `error` into a more
      /// concrete type is open.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Error{
        handle: _rt::Resource<Error>,
      }

      impl Error{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for Error{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:io/error@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]error"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      impl Error {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns a string that is suitable to assist humans in debugging
        /// this error.
        ///
        /// WARNING: The returned string should not be consumed mechanically!
        /// It may change across platforms, hosts, or other implementation
        /// details. Parsing this string is a major platform-compatibility
        /// hazard.
        pub fn to_debug_string(&self,) -> _rt::String{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/error@0.2.0")]
            extern "C" {
              #[link_name = "[method]error.to-debug-string"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = *ptr0.add(0).cast::<*mut u8>();
            let l2 = *ptr0.add(4).cast::<usize>();
            let len3 = l2;
            let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
            _rt::string_lift(bytes3)
          }
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod streams {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      pub type Error = super::super::super::wasi::io::error::Error;
      /// *
      ///     // Hermes does not support `poll`
      ///     use poll.{pollable};
      ///     */
      /// An error for input-stream and output-stream operations.
      pub enum StreamError {
        /// The last operation (a write or flush) failed before completion.
        ///
        /// More information is available in the `error` payload.
        LastOperationFailed(Error),
        /// The stream is closed: no more input will be accepted by the
        /// stream. A closed output-stream will return this error on all
        /// future operations.
        Closed,
      }
      impl ::core::fmt::Debug for StreamError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            StreamError::LastOperationFailed(e) => {
              f.debug_tuple("StreamError::LastOperationFailed").field(e).finish()
            }
            StreamError::Closed => {
              f.debug_tuple("StreamError::Closed").finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for StreamError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }

      impl std::error::Error for StreamError {}
      /// An input bytestream.
      ///
      /// `input-stream`s are *non-blocking* to the extent practical on underlying
      /// platforms. I/O operations always return promptly; if fewer bytes are
      /// promptly available than requested, they return the number of bytes promptly
      /// available, which could even be zero. To wait for data to be available,
      /// use the `subscribe` function to obtain a `pollable` which can be polled
      /// for using `wasi:io/poll`.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct InputStream{
        handle: _rt::Resource<InputStream>,
      }

      impl InputStream{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for InputStream{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]input-stream"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      /// An output bytestream.
      ///
      /// `output-stream`s are *non-blocking* to the extent practical on
      /// underlying platforms. Except where specified otherwise, I/O operations also
      /// always return promptly, after the number of bytes that can be written
      /// promptly, which could even be zero. To wait for the stream to be ready to
      /// accept data, the `subscribe` function to obtain a `pollable` which can be
      /// polled for using `wasi:io/poll`.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct OutputStream{
        handle: _rt::Resource<OutputStream>,
      }

      impl OutputStream{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: _rt::Resource::from_handle(handle),
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }


      unsafe impl _rt::WasmResource for OutputStream{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();

          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]output-stream"]
              fn drop(_: u32);
            }

            drop(_handle);
          }
        }
      }

      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Perform a non-blocking read from the stream.
        ///
        /// This function returns a list of bytes containing the read data,
        /// when successful. The returned list will contain up to `len` bytes;
        /// it may return fewer than requested, but not more. The list is
        /// empty when no bytes are available for reading at this time. The
        /// pollable given by `subscribe` will be ready when more bytes are
        /// available.
        ///
        /// This function fails with a `stream-error` when the operation
        /// encounters an error, giving `last-operation-failed`, or when the
        /// stream is closed, giving `closed`.
        ///
        /// When the caller gives a `len` of 0, it represents a request to
        /// read 0 bytes. If the stream is still open, this call should
        /// succeed and return an empty list, or otherwise fail with `closed`.
        ///
        /// The `len` parameter is a `u64`, which could represent a list of u8 which
        /// is not possible to allocate in wasm32, or not desirable to allocate as
        /// as a return value by the callee. The callee may return a list of bytes
        /// less than `len` in size while more bytes are available for reading.
        pub fn read(&self,len: u64,) -> Result<_rt::Vec::<u8>,StreamError>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.read"]
              fn wit_import(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(&len), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let len4 = l3;

                  _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v7 = match l5 {
                    0 => {
                      let e7 = {
                        let l6 = *ptr0.add(8).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l6 as u32)
                      };
                      StreamError::LastOperationFailed(e7)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v7
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Read bytes from a stream, after blocking until at least one byte can
        /// be read. Except for blocking, behavior is identical to `read`.
        pub fn blocking_read(&self,len: u64,) -> Result<_rt::Vec::<u8>,StreamError>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.blocking-read"]
              fn wit_import(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(&len), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(4).cast::<*mut u8>();
                  let l3 = *ptr0.add(8).cast::<usize>();
                  let len4 = l3;

                  _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v7 = match l5 {
                    0 => {
                      let e7 = {
                        let l6 = *ptr0.add(8).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l6 as u32)
                      };
                      StreamError::LastOperationFailed(e7)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v7
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Skip bytes from a stream. Returns number of bytes skipped.
        ///
        /// Behaves identical to `read`, except instead of returning a list
        /// of bytes, returns the number of bytes consumed from the stream.
        pub fn skip(&self,len: u64,) -> Result<u64,StreamError>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.skip"]
              fn wit_import(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(&len), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();

                  l2 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *ptr0.add(12).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v5
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Skip bytes from a stream, after blocking until at least one byte
        /// can be skipped. Except for blocking behavior, identical to `skip`.
        pub fn blocking_skip(&self,len: u64,) -> Result<u64,StreamError>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.blocking-skip"]
              fn wit_import(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(&len), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();

                  l2 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *ptr0.add(12).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v5
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Check readiness for writing. This function never blocks.
        ///
        /// Returns the number of bytes permitted for the next call to `write`,
        /// or an error. Calling `write` with more bytes than this function has
        /// permitted will trap.
        ///
        /// When this function returns 0 bytes, the `subscribe` pollable will
        /// become ready when this function will report at least 1 byte, or an
        /// error.
        pub fn check_write(&self,) -> Result<u64,StreamError>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.check-write"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();

                  l2 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *ptr0.add(12).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v5
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Perform a write. This function never blocks.
        ///
        /// Precondition: check-write gave permit of Ok(n) and contents has a
        /// length of less than or equal to n. Otherwise, this function will trap.
        ///
        /// returns Err(closed) without writing if the stream has closed since
        /// the last call to check-write provided a permit.
        pub fn write(&self,contents: &[u8],) -> Result<(),StreamError>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let vec0 = contents;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.write"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr1.add(4).cast::<u8>());
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *ptr1.add(8).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v5
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Perform a write of up to 4096 bytes, and then flush the stream. Block
        /// until all of these operations are complete, or an error occurs.
        ///
        /// This is a convenience wrapper around the use of `check-write`,
        /// `subscribe`, `write`, and `flush`, and is implemented with the
        /// following pseudo-code:
        ///
        /// ```text
        /// let pollable = this.subscribe();
        /// while !contents.is_empty() {
        /// // Wait for the stream to become writable
        /// poll-one(pollable);
        /// let Ok(n) = this.check-write(); // eliding error handling
        /// let len = min(n, contents.len());
        /// let (chunk, rest) = contents.split_at(len);
        /// this.write(chunk  );            // eliding error handling
        /// contents = rest;
        /// }
        /// this.flush();
        /// // Wait for completion of `flush`
        /// poll-one(pollable);
        /// // Check for any errors that arose during `flush`
        /// let _ = this.check-write();         // eliding error handling
        /// ```
        pub fn blocking_write_and_flush(&self,contents: &[u8],) -> Result<(),StreamError>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let vec0 = contents;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.blocking-write-and-flush"]
              fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l2 = i32::from(*ptr1.add(0).cast::<u8>());
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr1.add(4).cast::<u8>());
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *ptr1.add(8).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v5
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Request to flush buffered output. This function never blocks.
        ///
        /// This tells the output-stream that the caller intends any buffered
        /// output to be flushed. the output which is expected to be flushed
        /// is all that has been passed to `write` prior to this call.
        ///
        /// Upon calling this function, the `output-stream` will not accept any
        /// writes (`check-write` will return `ok(0)`) until the flush has
        /// completed. The `subscribe` pollable will become ready when the
        /// flush has completed and the stream can accept more writes.
        pub fn flush(&self,) -> Result<(),StreamError>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.flush"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v4 = match l2 {
                    0 => {
                      let e4 = {
                        let l3 = *ptr0.add(8).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                      };
                      StreamError::LastOperationFailed(e4)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v4
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Request to flush buffered output, and block until flush completes
        /// and stream is ready for writing again.
        pub fn blocking_flush(&self,) -> Result<(),StreamError>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.blocking-flush"]
              fn wit_import(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v4 = match l2 {
                    0 => {
                      let e4 = {
                        let l3 = *ptr0.add(8).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                      };
                      StreamError::LastOperationFailed(e4)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v4
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a `pollable` which will resolve once the output-stream
        /// is ready for more writing, or an error has occured. When this
        /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
        /// error.
        ///
        /// If the stream is closed, this pollable is always ready immediately.
        ///
        /// The created `pollable` is a child resource of the `output-stream`.
        /// Implementations may trap if the `output-stream` is dropped before
        /// all derived `pollable`s created with this function are dropped.
        /// subscribe: func() -> pollable; // Hermes does NOT support `poll`
        /// Write zeroes to a stream.
        ///
        /// this should be used precisely like `write` with the exact same
        /// preconditions (must use check-write first), but instead of
        /// passing a list of bytes, you simply pass the number of zero-bytes
        /// that should be written.
        pub fn write_zeroes(&self,len: u64,) -> Result<(),StreamError>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.write-zeroes"]
              fn wit_import(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(&len), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v4 = match l2 {
                    0 => {
                      let e4 = {
                        let l3 = *ptr0.add(8).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                      };
                      StreamError::LastOperationFailed(e4)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v4
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Perform a write of up to 4096 zeroes, and then flush the stream.
        /// Block until all of these operations are complete, or an error
        /// occurs.
        ///
        /// This is a convenience wrapper around the use of `check-write`,
        /// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
        /// the following pseudo-code:
        ///
        /// ```text
        /// let pollable = this.subscribe();
        /// while num_zeroes != 0 {
        /// // Wait for the stream to become writable
        /// poll-one(pollable);
        /// let Ok(n) = this.check-write(); // eliding error handling
        /// let len = min(n, num_zeroes);
        /// this.write-zeroes(len);         // eliding error handling
        /// num_zeroes -= len;
        /// }
        /// this.flush();
        /// // Wait for completion of `flush`
        /// poll-one(pollable);
        /// // Check for any errors that arose during `flush`
        /// let _ = this.check-write();         // eliding error handling
        /// ```
        pub fn blocking_write_zeroes_and_flush(&self,len: u64,) -> Result<(),StreamError>{
          unsafe {
            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.blocking-write-zeroes-and-flush"]
              fn wit_import(_: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, _rt::as_i64(&len), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                  let v4 = match l2 {
                    0 => {
                      let e4 = {
                        let l3 = *ptr0.add(8).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                      };
                      StreamError::LastOperationFailed(e4)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v4
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Read from one stream and write to another.
        ///
        /// The behavior of splice is equivelant to:
        /// 1. calling `check-write` on the `output-stream`
        /// 2. calling `read` on the `input-stream` with the smaller of the
        /// `check-write` permitted length and the `len` provided to `splice`
        /// 3. calling `write` on the `output-stream` with that read data.
        ///
        /// Any error reported by the call to `check-write`, `read`, or
        /// `write` ends the splice and reports that error.
        ///
        /// This function returns the number of bytes transferred; it may be less
        /// than `len`.
        pub fn splice(&self,src: &InputStream,len: u64,) -> Result<u64,StreamError>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.splice"]
              fn wit_import(_: i32, _: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, (src).handle() as i32, _rt::as_i64(&len), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();

                  l2 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *ptr0.add(12).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v5
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Read from one stream and write to another, with blocking.
        ///
        /// This is similar to `splice`, except that it blocks until the
        /// `output-stream` is ready for writing, and the `input-stream`
        /// is ready for reading, before performing the `splice`.
        pub fn blocking_splice(&self,src: &InputStream,len: u64,) -> Result<u64,StreamError>{
          unsafe {
            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.blocking-splice"]
              fn wit_import(_: i32, _: i32, _: i64, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i64, _: *mut u8, ){ unreachable!() }
            wit_import((self).handle() as i32, (src).handle() as i32, _rt::as_i64(&len), ptr0);
            let l1 = i32::from(*ptr0.add(0).cast::<u8>());
            match l1 {
              0 => {
                let e = {
                  let l2 = *ptr0.add(8).cast::<i64>();

                  l2 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*ptr0.add(8).cast::<u8>());
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *ptr0.add(12).cast::<i32>();

                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };

                  v5
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            }
          }
        }
      }

    }

  }
  #[allow(dead_code)]
  pub mod random {
    #[allow(dead_code, clippy::all)]
    pub mod random {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      /// Return `len` cryptographically-secure random or pseudo-random bytes.
      ///
      /// This function must produce data at least as cryptographically secure and
      /// fast as an adequately seeded cryptographically-secure pseudo-random
      /// number generator (CSPRNG). It must not block, from the perspective of
      /// the calling program, under any circumstances, including on the first
      /// request and on requests for numbers of bytes. The returned data must
      /// always be unpredictable.
      ///
      /// This function must always return fresh data. Deterministic environments
      /// must omit this function, rather than implementing it with deterministic
      /// data.
      pub fn get_random_bytes(len: u64,) -> _rt::Vec::<u8>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:random/random@0.2.0")]
          extern "C" {
            #[link_name = "get-random-bytes"]
            fn wit_import(_: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i64(&len), ptr0);
          let l1 = *ptr0.add(0).cast::<*mut u8>();
          let l2 = *ptr0.add(4).cast::<usize>();
          let len3 = l2;
          _rt::Vec::from_raw_parts(l1.cast(), len3, len3)
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Return a cryptographically-secure random or pseudo-random `u64` value.
      ///
      /// This function returns the same type of data as `get-random-bytes`,
      /// represented as a `u64`.
      pub fn get_random_u64() -> u64{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:random/random@0.2.0")]
          extern "C" {
            #[link_name = "get-random-u64"]
            fn wit_import() -> i64;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import() -> i64{ unreachable!() }
          let ret = wit_import();
          ret as u64
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod insecure {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      /// Return `len` insecure pseudo-random bytes.
      ///
      /// This function is not cryptographically secure. Do not use it for
      /// anything related to security.
      ///
      /// There are no requirements on the values of the returned bytes, however
      /// implementations are encouraged to return evenly distributed values with
      /// a long period.
      pub fn get_insecure_random_bytes(len: u64,) -> _rt::Vec::<u8>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:random/insecure@0.2.0")]
          extern "C" {
            #[link_name = "get-insecure-random-bytes"]
            fn wit_import(_: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i64, _: *mut u8, ){ unreachable!() }
          wit_import(_rt::as_i64(&len), ptr0);
          let l1 = *ptr0.add(0).cast::<*mut u8>();
          let l2 = *ptr0.add(4).cast::<usize>();
          let len3 = l2;
          _rt::Vec::from_raw_parts(l1.cast(), len3, len3)
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Return an insecure pseudo-random `u64` value.
      ///
      /// This function returns the same type of pseudo-random data as
      /// `get-insecure-random-bytes`, represented as a `u64`.
      pub fn get_insecure_random_u64() -> u64{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:random/insecure@0.2.0")]
          extern "C" {
            #[link_name = "get-insecure-random-u64"]
            fn wit_import() -> i64;
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import() -> i64{ unreachable!() }
          let ret = wit_import();
          ret as u64
        }
      }

    }

    #[allow(dead_code, clippy::all)]
    pub mod insecure_seed {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
      #[allow(unused_unsafe, clippy::all)]
      /// Return a 128-bit value that may contain a pseudo-random value.
      ///
      /// The returned value is not required to be computed from a CSPRNG, and may
      /// even be entirely deterministic. Host implementations are encouraged to
      /// provide pseudo-random values to any program exposed to
      /// attacker-controlled content, to enable DoS protection built into many
      /// languages' hash-map implementations.
      ///
      /// This function is intended to only be called once, by a source language
      /// to initialize Denial Of Service (DoS) protection in its hash-map
      /// implementation.
      ///
      /// # Expected future evolution
      ///
      /// This will likely be changed to a value import, to prevent it from being
      /// called multiple times and potentially used for purposes other than DoS
      /// protection.
      pub fn insecure_seed() -> (u64,u64,){
        unsafe {
          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:random/insecure-seed@0.2.0")]
          extern "C" {
            #[link_name = "insecure-seed"]
            fn wit_import(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = *ptr0.add(0).cast::<i64>();
          let l2 = *ptr0.add(8).cast::<i64>();
          (l1 as u64, l2 as u64)
        }
      }

    }

  }
}
#[allow(dead_code)]
pub mod exports {
  #[allow(dead_code)]
  pub mod hermes {
    #[allow(dead_code)]
    pub mod cardano {
      #[allow(dead_code, clippy::all)]
      pub mod event_on_block {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
        use super::super::super::super::_rt;
        pub type CardanoBlockchainId = super::super::super::super::hermes::cardano::api::CardanoBlockchainId;
        pub type CardanoBlock = super::super::super::super::hermes::cardano::api::CardanoBlock;
        pub type BlockSrc = super::super::super::super::hermes::cardano::api::BlockSrc;
        #[doc(hidden)]
        #[allow(non_snake_case)]
        pub unsafe fn _export_on_cardano_block_cabi<T: Guest>(arg0: i32,arg1: *mut u8,arg2: usize,arg3: i32,) {#[cfg(target_arch="wasm32")]
        _rt::run_ctors_once();let len0 = arg2;
        T::on_cardano_block(super::super::super::super::hermes::cardano::api::CardanoBlockchainId::_lift(arg0 as u8), _rt::Vec::from_raw_parts(arg1.cast(), len0, len0), super::super::super::super::hermes::cardano::api::BlockSrc::empty() | super::super::super::super::hermes::cardano::api::BlockSrc::from_bits_retain(((arg3 as u8) << 0) as _));
      }
      pub trait Guest {
        /// Triggered when a cardano block event fires.
        ///
        /// The module must export this interface to use it.
        ///
        /// ## Parameters
        ///
        /// - `blockchain` : The blockchain id the block originated from.
        /// - `block` : This raw CBOR block data.
        /// - `source` : Source information about where the block came from, and if we are at tip or not.
        ///
        /// Returns:
        /// Nothing.
        fn on_cardano_block(blockchain: CardanoBlockchainId,block: CardanoBlock,source: BlockSrc,);
      }
      #[doc(hidden)]

      macro_rules! __export_hermes_cardano_event_on_block_cabi{
        ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          #[export_name = "hermes:cardano/event-on-block#on-cardano-block"]
          unsafe extern "C" fn export_on_cardano_block(arg0: i32,arg1: *mut u8,arg2: usize,arg3: i32,) {
            $($path_to_types)*::_export_on_cardano_block_cabi::<$ty>(arg0, arg1, arg2, arg3)
          }
        };);
      }
      #[doc(hidden)]
      pub(crate) use __export_hermes_cardano_event_on_block_cabi;

    }

    #[allow(dead_code, clippy::all)]
    pub mod event_on_txn {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
      use super::super::super::super::_rt;
      pub type CardanoBlockchainId = super::super::super::super::hermes::cardano::api::CardanoBlockchainId;
      pub type CardanoTxn = super::super::super::super::hermes::cardano::api::CardanoTxn;
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn _export_on_cardano_txn_cabi<T: Guest>(arg0: i32,arg1: i64,arg2: i32,arg3: *mut u8,arg4: usize,) {#[cfg(target_arch="wasm32")]
      _rt::run_ctors_once();let len0 = arg4;
      T::on_cardano_txn(super::super::super::super::hermes::cardano::api::CardanoBlockchainId::_lift(arg0 as u8), arg1 as u64, arg2 as u32, _rt::Vec::from_raw_parts(arg3.cast(), len0, len0));
    }
    pub trait Guest {
      /// Triggered when a cardano transaction event fires.
      ///
      /// The module must export this interface to use it.
      ///
      /// ## Parameters
      ///
      /// - `blockchain` : The blockchain id the block originated from.
      /// - `slot`       : The slot the transaction is in.
      /// - `txn-index`  : The offset in the block this transaction is at.
      /// - `txn`        : The raw transaction data itself.
      ///
      /// Returns:
      /// Nothing.
      fn on_cardano_txn(blockchain: CardanoBlockchainId,slot: u64,txn_index: u32,txn: CardanoTxn,);
    }
    #[doc(hidden)]

    macro_rules! __export_hermes_cardano_event_on_txn_cabi{
      ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

        #[export_name = "hermes:cardano/event-on-txn#on-cardano-txn"]
        unsafe extern "C" fn export_on_cardano_txn(arg0: i32,arg1: i64,arg2: i32,arg3: *mut u8,arg4: usize,) {
          $($path_to_types)*::_export_on_cardano_txn_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
        }
      };);
    }
    #[doc(hidden)]
    pub(crate) use __export_hermes_cardano_event_on_txn_cabi;

  }

  #[allow(dead_code, clippy::all)]
  pub mod event_on_rollback {
    #[used]
    #[doc(hidden)]
    #[cfg(target_arch = "wasm32")]
    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
    use super::super::super::super::_rt;
    pub type CardanoBlockchainId = super::super::super::super::hermes::cardano::api::CardanoBlockchainId;
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn _export_on_cardano_rollback_cabi<T: Guest>(arg0: i32,arg1: i64,) {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();T::on_cardano_rollback(super::super::super::super::hermes::cardano::api::CardanoBlockchainId::_lift(arg0 as u8), arg1 as u64);
  }
  pub trait Guest {
    /// Triggered when a cardano rollback event fires.
    ///
    /// The module must export this interface to use it.
    ///
    /// ## Parameters
    ///
    /// - `blockchain` : The blockchain id the rollback originated from.
    /// - `slot`       : The slot the rollback is targeting. (The next block event will be from this slot.)
    ///
    /// Returns:
    /// Nothing.
    fn on_cardano_rollback(blockchain: CardanoBlockchainId,slot: u64,);
  }
  #[doc(hidden)]

  macro_rules! __export_hermes_cardano_event_on_rollback_cabi{
    ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

      #[export_name = "hermes:cardano/event-on-rollback#on-cardano-rollback"]
      unsafe extern "C" fn export_on_cardano_rollback(arg0: i32,arg1: i64,) {
        $($path_to_types)*::_export_on_cardano_rollback_cabi::<$ty>(arg0, arg1)
      }
    };);
  }
  #[doc(hidden)]
  pub(crate) use __export_hermes_cardano_event_on_rollback_cabi;

}

}
#[allow(dead_code)]
pub mod cron {
  #[allow(dead_code, clippy::all)]
  pub mod event {
    #[used]
    #[doc(hidden)]
    #[cfg(target_arch = "wasm32")]
    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
    use super::super::super::super::_rt;
    pub type CronTagged = super::super::super::super::hermes::cron::api::CronTagged;
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn _export_on_cron_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,arg4: i32,) -> i32 {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let len1 = arg3;
    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
    let result2 = T::on_cron(super::super::super::super::hermes::cron::api::CronTagged{
      when: _rt::string_lift(bytes0),
      tag: _rt::string_lift(bytes1),
    }, _rt::bool_lift(arg4 as u8));
    match result2 { true => 1, false => 0 }
  }
  pub trait Guest {
    /// Triggered when a cron event fires.
    ///
    /// This event is only ever generated for the application that added
    /// the cron job.
    ///
    /// The module must export this interface to use it.
    ///
    /// ## Parameters
    ///
    /// - `event` : The tagged cron event that was triggered.
    /// - `last` : This cron event will not retrigger.
    ///
    /// Returns:
    /// - `true`  - retrigger. (Ignored if the cron event is `final`).
    /// - `false` - stop the cron.
    fn on_cron(event: CronTagged,last: bool,) -> bool;
  }
  #[doc(hidden)]

  macro_rules! __export_hermes_cron_event_cabi{
    ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

      #[export_name = "hermes:cron/event#on-cron"]
      unsafe extern "C" fn export_on_cron(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,arg4: i32,) -> i32 {
        $($path_to_types)*::_export_on_cron_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
      }
    };);
  }
  #[doc(hidden)]
  pub(crate) use __export_hermes_cron_event_cabi;

}

}
#[allow(dead_code)]
pub mod http_gateway {
  #[allow(dead_code, clippy::all)]
  pub mod event {
    #[used]
    #[doc(hidden)]
    #[cfg(target_arch = "wasm32")]
    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
    use super::super::super::super::_rt;
    pub type Bstr = super::super::super::super::hermes::binary::api::Bstr;
    pub type Header = (_rt::String,_rt::Vec::<_rt::String>,);
    pub type Headers = _rt::Vec::<Header>;
    #[derive(Clone)]
    pub struct HttpResponse {
      pub code: u16,
      pub headers: Headers,
      pub body: Bstr,
    }
    impl ::core::fmt::Debug for HttpResponse {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("HttpResponse").field("code", &self.code).field("headers", &self.headers).field("body", &self.body).finish()
      }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn _export_reply_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,arg4: *mut u8,arg5: usize,arg6: *mut u8,arg7: usize,) -> *mut u8 {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let len0 = arg1;
    let base10 = arg2;
    let len10 = arg3;
    let mut result10 = _rt::Vec::with_capacity(len10);
    for i in 0..len10 {
      let base = base10.add(i * 16);
      let e10 = {
        let l1 = *base.add(0).cast::<*mut u8>();
        let l2 = *base.add(4).cast::<usize>();
        let len3 = l2;
        let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
        let l4 = *base.add(8).cast::<*mut u8>();
        let l5 = *base.add(12).cast::<usize>();
        let base9 = l4;
        let len9 = l5;
        let mut result9 = _rt::Vec::with_capacity(len9);
        for i in 0..len9 {
          let base = base9.add(i * 8);
          let e9 = {
            let l6 = *base.add(0).cast::<*mut u8>();
            let l7 = *base.add(4).cast::<usize>();
            let len8 = l7;
            let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);

            _rt::string_lift(bytes8)
          };
          result9.push(e9);
        }
        _rt::cabi_dealloc(base9, len9 * 8, 4);

        (_rt::string_lift(bytes3), result9)
      };
      result10.push(e10);
    }
    _rt::cabi_dealloc(base10, len10 * 16, 4);
    let len11 = arg5;
    let bytes11 = _rt::Vec::from_raw_parts(arg4.cast(), len11, len11);
    let len12 = arg7;
    let bytes12 = _rt::Vec::from_raw_parts(arg6.cast(), len12, len12);
    let result13 = T::reply(_rt::Vec::from_raw_parts(arg0.cast(), len0, len0), result10, _rt::string_lift(bytes11), _rt::string_lift(bytes12));
    let ptr14 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
    match result13 {
      Some(e) => {
        *ptr14.add(0).cast::<u8>() = (1i32) as u8;
        let HttpResponse{ code:code15, headers:headers15, body:body15, } = e;
        *ptr14.add(4).cast::<u16>() = (_rt::as_i32(code15)) as u16;
        let vec20 = headers15;
        let len20 = vec20.len();
        let layout20 = _rt::alloc::Layout::from_size_align_unchecked(vec20.len() * 16, 4);
        let result20 = if layout20.size() != 0 {
          let ptr = _rt::alloc::alloc(layout20).cast::<u8>();
          if ptr.is_null()
          {
            _rt::alloc::handle_alloc_error(layout20);
          }
          ptr
        }else {{
          ::core::ptr::null_mut()
        }};
        for (i, e) in vec20.into_iter().enumerate() {
          let base = result20.add(i * 16);
          {
            let (t16_0, t16_1, ) = e;
            let vec17 = (t16_0.into_bytes()).into_boxed_slice();
            let ptr17 = vec17.as_ptr().cast::<u8>();
            let len17 = vec17.len();
            ::core::mem::forget(vec17);
            *base.add(4).cast::<usize>() = len17;
            *base.add(0).cast::<*mut u8>() = ptr17.cast_mut();
            let vec19 = t16_1;
            let len19 = vec19.len();
            let layout19 = _rt::alloc::Layout::from_size_align_unchecked(vec19.len() * 8, 4);
            let result19 = if layout19.size() != 0 {
              let ptr = _rt::alloc::alloc(layout19).cast::<u8>();
              if ptr.is_null()
              {
                _rt::alloc::handle_alloc_error(layout19);
              }
              ptr
            }else {{
              ::core::ptr::null_mut()
            }};
            for (i, e) in vec19.into_iter().enumerate() {
              let base = result19.add(i * 8);
              {
                let vec18 = (e.into_bytes()).into_boxed_slice();
                let ptr18 = vec18.as_ptr().cast::<u8>();
                let len18 = vec18.len();
                ::core::mem::forget(vec18);
                *base.add(4).cast::<usize>() = len18;
                *base.add(0).cast::<*mut u8>() = ptr18.cast_mut();
              }
            }
            *base.add(12).cast::<usize>() = len19;
            *base.add(8).cast::<*mut u8>() = result19;
          }
        }
        *ptr14.add(12).cast::<usize>() = len20;
        *ptr14.add(8).cast::<*mut u8>() = result20;
        let vec21 = (body15).into_boxed_slice();
        let ptr21 = vec21.as_ptr().cast::<u8>();
        let len21 = vec21.len();
        ::core::mem::forget(vec21);
        *ptr14.add(20).cast::<usize>() = len21;
        *ptr14.add(16).cast::<*mut u8>() = ptr21.cast_mut();
      },
      None => {
        {
          *ptr14.add(0).cast::<u8>() = (0i32) as u8;
        }
      },
    };ptr14
  }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn __post_return_reply<T: Guest>(arg0: *mut u8,) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
      0 => (),
      _ => {
        let l1 = *arg0.add(8).cast::<*mut u8>();
        let l2 = *arg0.add(12).cast::<usize>();
        let base10 = l1;
        let len10 = l2;
        for i in 0..len10 {
          let base = base10.add(i * 16);
          {
            let l3 = *base.add(0).cast::<*mut u8>();
            let l4 = *base.add(4).cast::<usize>();
            _rt::cabi_dealloc(l3, l4, 1);
            let l5 = *base.add(8).cast::<*mut u8>();
            let l6 = *base.add(12).cast::<usize>();
            let base9 = l5;
            let len9 = l6;
            for i in 0..len9 {
              let base = base9.add(i * 8);
              {
                let l7 = *base.add(0).cast::<*mut u8>();
                let l8 = *base.add(4).cast::<usize>();
                _rt::cabi_dealloc(l7, l8, 1);
              }
            }
            _rt::cabi_dealloc(base9, len9 * 8, 4);
          }
        }
        _rt::cabi_dealloc(base10, len10 * 16, 4);
        let l11 = *arg0.add(16).cast::<*mut u8>();
        let l12 = *arg0.add(20).cast::<usize>();
        let base13 = l11;
        let len13 = l12;
        _rt::cabi_dealloc(base13, len13 * 1, 1);
      },
    }
  }
  pub trait Guest {
    fn reply(body: Bstr,headers: Headers,path: _rt::String,method: _rt::String,) -> Option<HttpResponse>;
  }
  #[doc(hidden)]

  macro_rules! __export_hermes_http_gateway_event_cabi{
    ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

      #[export_name = "hermes:http-gateway/event#reply"]
      unsafe extern "C" fn export_reply(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,arg4: *mut u8,arg5: usize,arg6: *mut u8,arg7: usize,) -> *mut u8 {
        $($path_to_types)*::_export_reply_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
      }
      #[export_name = "cabi_post_hermes:http-gateway/event#reply"]
      unsafe extern "C" fn _post_return_reply(arg0: *mut u8,) {
        $($path_to_types)*::__post_return_reply::<$ty>(arg0)
      }
    };);
  }
  #[doc(hidden)]
  pub(crate) use __export_hermes_http_gateway_event_cabi;
  #[repr(align(4))]
  struct _RetArea([::core::mem::MaybeUninit::<u8>; 24]);
  static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);

}

}
#[allow(dead_code)]
pub mod http_request {
  #[allow(dead_code, clippy::all)]
  pub mod event_on_http_response {
    #[used]
    #[doc(hidden)]
    #[cfg(target_arch = "wasm32")]
    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
    use super::super::super::super::_rt;
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn _export_on_http_response_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let len1 = arg3;
    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
    T::on_http_response(_rt::string_lift(bytes0), _rt::string_lift(bytes1));
  }
  pub trait Guest {
    fn on_http_response(request_id: _rt::String,response: _rt::String,);
  }
  #[doc(hidden)]

  macro_rules! __export_hermes_http_request_event_on_http_response_cabi{
    ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

      #[export_name = "hermes:http-request/event-on-http-response#on-http-response"]
      unsafe extern "C" fn export_on_http_response(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,) {
        $($path_to_types)*::_export_on_http_response_cabi::<$ty>(arg0, arg1, arg2, arg3)
      }
    };);
  }
  #[doc(hidden)]
  pub(crate) use __export_hermes_http_request_event_on_http_response_cabi;

}

}
#[allow(dead_code)]
pub mod init {
  #[allow(dead_code, clippy::all)]
  pub mod event {
    #[used]
    #[doc(hidden)]
    #[cfg(target_arch = "wasm32")]
    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
    use super::super::super::super::_rt;
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn _export_init_cabi<T: Guest>() -> i32 {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let result0 = T::init();
    match result0 { true => 1, false => 0 }
  }
  pub trait Guest {
    /// Perform application start up initialization.
    ///
    /// This will only ever be called once when the application this module is a part of is started.
    /// The module must export this interface to use it.
    ///
    /// Returns:
    /// - `true`  - Initialization is successful, the application may commence.
    /// - `false` - Fatal error during Initialization.  DO NOT START APPLICATION.
    fn init() -> bool;
  }
  #[doc(hidden)]

  macro_rules! __export_hermes_init_event_cabi{
    ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

      #[export_name = "hermes:init/event#init"]
      unsafe extern "C" fn export_init() -> i32 {
        $($path_to_types)*::_export_init_cabi::<$ty>()
      }
    };);
  }
  #[doc(hidden)]
  pub(crate) use __export_hermes_init_event_cabi;

}

}
#[allow(dead_code)]
pub mod integration_test {
  #[allow(dead_code, clippy::all)]
  pub mod event {
    #[used]
    #[doc(hidden)]
    #[cfg(target_arch = "wasm32")]
    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
    use super::super::super::super::_rt;
    /// Time in localtime format.
    #[derive(Clone)]
    pub struct TestResult {
      pub name: _rt::String,
      /// Name of the test
      pub status: bool,
    }
    impl ::core::fmt::Debug for TestResult {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TestResult").field("name", &self.name).field("status", &self.status).finish()
      }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn _export_test_cabi<T: Guest>(arg0: i32,arg1: i32,) -> *mut u8 {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let result0 = T::test(arg0 as u32, _rt::bool_lift(arg1 as u8));
    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
    match result0 {
      Some(e) => {
        *ptr1.add(0).cast::<u8>() = (1i32) as u8;
        let TestResult{ name:name2, status:status2, } = e;
        let vec3 = (name2.into_bytes()).into_boxed_slice();
        let ptr3 = vec3.as_ptr().cast::<u8>();
        let len3 = vec3.len();
        ::core::mem::forget(vec3);
        *ptr1.add(8).cast::<usize>() = len3;
        *ptr1.add(4).cast::<*mut u8>() = ptr3.cast_mut();
        *ptr1.add(12).cast::<u8>() = (match status2 { true => 1, false => 0 }) as u8;
      },
      None => {
        {
          *ptr1.add(0).cast::<u8>() = (0i32) as u8;
        }
      },
    };ptr1
  }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn __post_return_test<T: Guest>(arg0: *mut u8,) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
      0 => (),
      _ => {
        let l1 = *arg0.add(4).cast::<*mut u8>();
        let l2 = *arg0.add(8).cast::<usize>();
        _rt::cabi_dealloc(l1, l2, 1);
      },
    }
  }
  #[doc(hidden)]
  #[allow(non_snake_case)]
  pub unsafe fn _export_bench_cabi<T: Guest>(arg0: i32,arg1: i32,) -> *mut u8 {#[cfg(target_arch="wasm32")]
  _rt::run_ctors_once();let result0 = T::bench(arg0 as u32, _rt::bool_lift(arg1 as u8));
  let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
  match result0 {
    Some(e) => {
      *ptr1.add(0).cast::<u8>() = (1i32) as u8;
      let TestResult{ name:name2, status:status2, } = e;
      let vec3 = (name2.into_bytes()).into_boxed_slice();
      let ptr3 = vec3.as_ptr().cast::<u8>();
      let len3 = vec3.len();
      ::core::mem::forget(vec3);
      *ptr1.add(8).cast::<usize>() = len3;
      *ptr1.add(4).cast::<*mut u8>() = ptr3.cast_mut();
      *ptr1.add(12).cast::<u8>() = (match status2 { true => 1, false => 0 }) as u8;
    },
    None => {
      {
        *ptr1.add(0).cast::<u8>() = (0i32) as u8;
      }
    },
  };ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_bench<T: Guest>(arg0: *mut u8,) {
  let l0 = i32::from(*arg0.add(0).cast::<u8>());
  match l0 {
    0 => (),
    _ => {
      let l1 = *arg0.add(4).cast::<*mut u8>();
      let l2 = *arg0.add(8).cast::<usize>();
      _rt::cabi_dealloc(l1, l2, 1);
    },
  }
}
pub trait Guest {
  /// Run or List a WASM provided integration test.
  ///
  /// This is a single entrypoint in a wasm component, which can provide multiple tests.
  /// Each test must be numbered from 0-n, with no gaps.
  ///
  /// test : u32 - The test number to run/list
  /// run  : bool - True = Run the test, False = Just list the test name.
  ///
  /// Returns:
  /// None - There is no test at that test number.
  /// test-result - The result of the test,  if the test was not run, just returns the name and
  /// status is True.  Otherwise the test is executed, and the result is
  /// the result of the test run.
  fn test(test: u32,run: bool,) -> Option<TestResult>;
  /// Run or List a WASM provided benchmark test.
  ///
  /// This is a single entrypoint in a wasm component, which can provide multiple benchmarks.
  /// Each benchmark must be numbered from 0-n, with no gaps.
  ///
  /// Each time this function is called the bench function is run exactly once.
  ///
  /// test : u32 - The bench number to run/list
  /// run  : bool - True = Run the benchmark, False = Just list the test name.
  ///
  /// Returns:
  /// None - There is no test at that test number.
  /// test-result - The result of the test,  if the test was not run, just returns the name and
  /// status is True.  Otherwise the test is executed, and the result is
  /// the result of the test run.
  fn bench(test: u32,run: bool,) -> Option<TestResult>;
}
#[doc(hidden)]

macro_rules! __export_hermes_integration_test_event_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "hermes:integration-test/event#test"]
    unsafe extern "C" fn export_test(arg0: i32,arg1: i32,) -> *mut u8 {
      $($path_to_types)*::_export_test_cabi::<$ty>(arg0, arg1)
    }
    #[export_name = "cabi_post_hermes:integration-test/event#test"]
    unsafe extern "C" fn _post_return_test(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_test::<$ty>(arg0)
    }
    #[export_name = "hermes:integration-test/event#bench"]
    unsafe extern "C" fn export_bench(arg0: i32,arg1: i32,) -> *mut u8 {
      $($path_to_types)*::_export_bench_cabi::<$ty>(arg0, arg1)
    }
    #[export_name = "cabi_post_hermes:integration-test/event#bench"]
    unsafe extern "C" fn _post_return_bench(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_bench::<$ty>(arg0)
    }
  };);
}
#[doc(hidden)]
pub(crate) use __export_hermes_integration_test_event_cabi;
#[repr(align(4))]
struct _RetArea([::core::mem::MaybeUninit::<u8>; 16]);
static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);

}

}
#[allow(dead_code)]
pub mod ipfs {
  #[allow(dead_code, clippy::all)]
  pub mod event {
    #[used]
    #[doc(hidden)]
    #[cfg(target_arch = "wasm32")]
    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
    use super::super::super::super::_rt;
    pub type PubsubMessage = super::super::super::super::hermes::ipfs::api::PubsubMessage;
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn _export_on_topic_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,arg4: i32,arg5: *mut u8,arg6: usize,) -> i32 {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let len1 = arg3;
    let result3 = T::on_topic(super::super::super::super::hermes::ipfs::api::PubsubMessage{
      topic: _rt::string_lift(bytes0),
      message: _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
      publisher: match arg4 {
        0 => None,
        1 => {
          let e = {
            let len2 = arg6;
            let bytes2 = _rt::Vec::from_raw_parts(arg5.cast(), len2, len2);

            _rt::string_lift(bytes2)
          };
          Some(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      },
    });
    match result3 { true => 1, false => 0 }
  }
  pub trait Guest {
    /// Triggers when a message is received on a topic.
    fn on_topic(message: PubsubMessage,) -> bool;
  }
  #[doc(hidden)]

  macro_rules! __export_hermes_ipfs_event_cabi{
    ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

      #[export_name = "hermes:ipfs/event#on-topic"]
      unsafe extern "C" fn export_on_topic(arg0: *mut u8,arg1: usize,arg2: *mut u8,arg3: usize,arg4: i32,arg5: *mut u8,arg6: usize,) -> i32 {
        $($path_to_types)*::_export_on_topic_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
      }
    };);
  }
  #[doc(hidden)]
  pub(crate) use __export_hermes_ipfs_event_cabi;

}

}
#[allow(dead_code)]
pub mod kv_store {
  #[allow(dead_code, clippy::all)]
  pub mod event {
    #[used]
    #[doc(hidden)]
    #[cfg(target_arch = "wasm32")]
    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
    use super::super::super::super::_rt;
    pub type KvValues = super::super::super::super::hermes::kv_store::api::KvValues;
    #[doc(hidden)]
    #[allow(non_snake_case)]
    pub unsafe fn _export_kv_update_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: i32,arg3: ::core::mem::MaybeUninit::<u64>,arg4: usize,) {#[cfg(target_arch="wasm32")]
    _rt::run_ctors_once();let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    use super::super::super::super::hermes::kv_store::api::KvValues as V5;
    let v5 = match arg2 {
      0 => {
        let e5 = {
          let len1 = arg4;
          let bytes1 = _rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len1, len1);

          _rt::string_lift(bytes1)
        };
        V5::KvString(e5)
      }
      1 => {
        let e5 = arg3.assume_init() as i64;
        V5::KvS64(e5)
      }
      2 => {
        let e5 = arg3.assume_init() as i64 as u64;
        V5::KvU64(e5)
      }
      3 => {
        let e5 = f64::from_bits(arg3.assume_init() as i64 as u64);
        V5::KvF64(e5)
      }
      4 => {
        let e5 = {
          let len2 = arg4;

          _rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len2, len2)
        };
        V5::KvBstr(e5)
      }
      5 => {
        let e5 = {
          let len3 = arg4;

          _rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len3, len3)
        };
        V5::KvCbor(e5)
      }
      n => {
        debug_assert_eq!(n, 6, "invalid enum discriminant");
        let e5 = {
          let len4 = arg4;
          let bytes4 = _rt::Vec::from_raw_parts(arg3.as_ptr().cast::<*mut u8>().read().cast(), len4, len4);

          _rt::string_lift(bytes4)
        };
        V5::KvJson(e5)
      }
    };
    T::kv_update(_rt::string_lift(bytes0), v5);
  }
  pub trait Guest {
    /// A Subscribed key has updated.
    ///
    /// This will only ever be called if the module has subscribed to updates using
    /// `kv-subscribe`
    ///
    /// Returns:
    /// Nothing.
    fn kv_update(key: _rt::String,value: KvValues,);
  }
  #[doc(hidden)]

  macro_rules! __export_hermes_kv_store_event_cabi{
    ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

      #[export_name = "hermes:kv-store/event#kv-update"]
      unsafe extern "C" fn export_kv_update(arg0: *mut u8,arg1: usize,arg2: i32,arg3: ::core::mem::MaybeUninit::<u64>,arg4: usize,) {
        $($path_to_types)*::_export_kv_update_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
      }
    };);
  }
  #[doc(hidden)]
  pub(crate) use __export_hermes_kv_store_event_cabi;

}

}
}
#[allow(dead_code)]
pub mod wasi {
  #[allow(dead_code)]
  pub mod http {
    #[allow(dead_code, clippy::all)]
    pub mod incoming_handler {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
      use super::super::super::super::_rt;
      pub type IncomingRequest = super::super::super::super::wasi::http::types::IncomingRequest;
      pub type ResponseOutparam = super::super::super::super::wasi::http::types::ResponseOutparam;
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn _export_handle_cabi<T: Guest>(arg0: i32,arg1: i32,) {#[cfg(target_arch="wasm32")]
      _rt::run_ctors_once();T::handle(super::super::super::super::wasi::http::types::IncomingRequest::from_handle(arg0 as u32), super::super::super::super::wasi::http::types::ResponseOutparam::from_handle(arg1 as u32));
    }
    pub trait Guest {
      /// This function is invoked with an incoming HTTP Request, and a resource
      /// `response-outparam` which provides the capability to reply with an HTTP
      /// Response. The response is sent by calling the `response-outparam.set`
      /// method, which allows execution to continue after the response has been
      /// sent. This enables both streaming to the response body, and performing other
      /// work.
      ///
      /// The implementor of this function must write a response to the
      /// `response-outparam` before returning, or else the caller will respond
      /// with an error on its behalf.
      fn handle(request: IncomingRequest,response_out: ResponseOutparam,);
    }
    #[doc(hidden)]

    macro_rules! __export_wasi_http_incoming_handler_0_2_0_cabi{
      ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

        #[export_name = "wasi:http/incoming-handler@0.2.0#handle"]
        unsafe extern "C" fn export_handle(arg0: i32,arg1: i32,) {
          $($path_to_types)*::_export_handle_cabi::<$ty>(arg0, arg1)
        }
      };);
    }
    #[doc(hidden)]
    pub(crate) use __export_wasi_http_incoming_handler_0_2_0_cabi;

  }

}
}
}
mod _rt {
  pub use alloc_crate::vec::Vec;
  pub use alloc_crate::string::String;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      String::from_utf8_unchecked(bytes)
    }
  }
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    let layout = alloc::Layout::from_size_align_unchecked(size, align);
    alloc::dealloc(ptr, layout);
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      core::hint::unreachable_unchecked()
    }
  }
  

  use core::fmt;
  use core::marker;
  use core::sync::atomic::{AtomicU32, Ordering::Relaxed};

  /// A type which represents a component model resource, either imported or
  /// exported into this component.
  ///
  /// This is a low-level wrapper which handles the lifetime of the resource
  /// (namely this has a destructor). The `T` provided defines the component model
  /// intrinsics that this wrapper uses.
  ///
  /// One of the chief purposes of this type is to provide `Deref` implementations
  /// to access the underlying data when it is owned.
  ///
  /// This type is primarily used in generated code for exported and imported
  /// resources.
  #[repr(transparent)]
  pub struct Resource<T: WasmResource> {
    // NB: This would ideally be `u32` but it is not. The fact that this has
    // interior mutability is not exposed in the API of this type except for the
    // `take_handle` method which is supposed to in theory be private.
    //
    // This represents, almost all the time, a valid handle value. When it's
    // invalid it's stored as `u32::MAX`.
    handle: AtomicU32,
    _marker: marker::PhantomData<T>,
  }

  /// A trait which all wasm resources implement, namely providing the ability to
  /// drop a resource.
  ///
  /// This generally is implemented by generated code, not user-facing code.
  #[allow(clippy::missing_safety_doc)]
  pub unsafe trait WasmResource {
    /// Invokes the `[resource-drop]...` intrinsic.
    unsafe fn drop(handle: u32);
  }

  impl<T: WasmResource> Resource<T> {
    #[doc(hidden)]
    pub unsafe fn from_handle(handle: u32) -> Self {
      debug_assert!(handle != u32::MAX);
      Self {
        handle: AtomicU32::new(handle),
        _marker: marker::PhantomData,
      }
    }

    /// Takes ownership of the handle owned by `resource`.
    ///
    /// Note that this ideally would be `into_handle` taking `Resource<T>` by
    /// ownership. The code generator does not enable that in all situations,
    /// unfortunately, so this is provided instead.
    ///
    /// Also note that `take_handle` is in theory only ever called on values
    /// owned by a generated function. For example a generated function might
    /// take `Resource<T>` as an argument but then call `take_handle` on a
    /// reference to that argument. In that sense the dynamic nature of
    /// `take_handle` should only be exposed internally to generated code, not
    /// to user code.
    #[doc(hidden)]
    pub fn take_handle(resource: &Resource<T>) -> u32 {
      resource.handle.swap(u32::MAX, Relaxed)
    }

    #[doc(hidden)]
    pub fn handle(resource: &Resource<T>) -> u32 {
      resource.handle.load(Relaxed)
    }
  }

  impl<T: WasmResource> fmt::Debug for Resource<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      f.debug_struct("Resource")
      .field("handle", &self.handle)
      .finish()
    }
  }

  impl<T: WasmResource> Drop for Resource<T> {
    fn drop(&mut self) {
      unsafe {
        match self.handle.load(Relaxed) {
          // If this handle was "taken" then don't do anything in the
          // destructor.
          u32::MAX => {}

          // ... but otherwise do actually destroy it with the imported
          // component model intrinsic as defined through `T`.
          other => T::drop(other),
        }
      }
    }
  }
  
  pub fn as_i64<T: AsI64>(t: T) -> i64 {
    t.as_i64()
  }

  pub trait AsI64 {
    fn as_i64(self) -> i64;
  }

  impl<'a, T: Copy + AsI64> AsI64 for &'a T {
    fn as_i64(self) -> i64 {
      (*self).as_i64()
    }
  }
  
  impl AsI64 for i64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  impl AsI64 for u64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  pub unsafe fn bool_lift(val: u8) -> bool {
    if cfg!(debug_assertions) {
      match val {
        0 => false,
        1 => true,
        _ => panic!("invalid bool discriminant"),
      }
    } else {
      val != 0
    }
  }
  pub use alloc_crate::alloc;

  pub fn as_f64<T: AsF64>(t: T) -> f64 {
    t.as_f64()
  }

  pub trait AsF64 {
    fn as_f64(self) -> f64;
  }

  impl<'a, T: Copy + AsF64> AsF64 for &'a T {
    fn as_f64(self) -> f64 {
      (*self).as_f64()
    }
  }
  
  impl AsF64 for f64 {
    #[inline]
    fn as_f64(self) -> f64 {
      self as f64
    }
  }
  
  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen::rt::run_ctors_once();
  }
  extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_hermes_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::wasi::http::incoming_handler::__export_wasi_http_incoming_handler_0_2_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::wasi::http::incoming_handler);
  $($path_to_types_root)*::exports::hermes::cardano::event_on_block::__export_hermes_cardano_event_on_block_cabi!($ty with_types_in $($path_to_types_root)*::exports::hermes::cardano::event_on_block);
  $($path_to_types_root)*::exports::hermes::cardano::event_on_txn::__export_hermes_cardano_event_on_txn_cabi!($ty with_types_in $($path_to_types_root)*::exports::hermes::cardano::event_on_txn);
  $($path_to_types_root)*::exports::hermes::cardano::event_on_rollback::__export_hermes_cardano_event_on_rollback_cabi!($ty with_types_in $($path_to_types_root)*::exports::hermes::cardano::event_on_rollback);
  $($path_to_types_root)*::exports::hermes::cron::event::__export_hermes_cron_event_cabi!($ty with_types_in $($path_to_types_root)*::exports::hermes::cron::event);
  $($path_to_types_root)*::exports::hermes::init::event::__export_hermes_init_event_cabi!($ty with_types_in $($path_to_types_root)*::exports::hermes::init::event);
  $($path_to_types_root)*::exports::hermes::ipfs::event::__export_hermes_ipfs_event_cabi!($ty with_types_in $($path_to_types_root)*::exports::hermes::ipfs::event);
  $($path_to_types_root)*::exports::hermes::kv_store::event::__export_hermes_kv_store_event_cabi!($ty with_types_in $($path_to_types_root)*::exports::hermes::kv_store::event);
  $($path_to_types_root)*::exports::hermes::integration_test::event::__export_hermes_integration_test_event_cabi!($ty with_types_in $($path_to_types_root)*::exports::hermes::integration_test::event);
  $($path_to_types_root)*::exports::hermes::http_gateway::event::__export_hermes_http_gateway_event_cabi!($ty with_types_in $($path_to_types_root)*::exports::hermes::http_gateway::event);
  $($path_to_types_root)*::exports::hermes::http_request::event_on_http_response::__export_hermes_http_request_event_on_http_response_cabi!($ty with_types_in $($path_to_types_root)*::exports::hermes::http_request::event_on_http_response);
  )
}
#[doc(inline)]
pub(crate) use __export_hermes_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.29.0:hermes:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 16310] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xb9~\x01A\x02\x01Ak\x01\
B\x0a\x01o\x02ss\x01p\0\x01@\0\0\x01\x04\0\x0fget-environment\x01\x02\x01ps\x01@\
\0\0\x03\x04\0\x0dget-arguments\x01\x04\x01ks\x01@\0\0\x05\x04\0\x0binitial-cwd\x01\
\x06\x03\x01\x1awasi:cli/environment@0.2.0\x05\0\x01B\x03\x01j\0\0\x01@\x01\x06s\
tatus\0\x01\0\x04\0\x04exit\x01\x01\x03\x01\x13wasi:cli/exit@0.2.0\x05\x01\x01B\x04\
\x04\0\x05error\x03\x01\x01h\0\x01@\x01\x04self\x01\0s\x04\0\x1d[method]error.to\
-debug-string\x01\x02\x03\x01\x13wasi:io/error@0.2.0\x05\x02\x02\x03\0\x02\x05er\
ror\x01B!\x02\x03\x02\x01\x03\x04\0\x05error\x03\0\0\x01i\x01\x01q\x02\x15last-o\
peration-failed\x01\x02\0\x06closed\0\0\x04\0\x0cstream-error\x03\0\x03\x04\0\x0c\
input-stream\x03\x01\x04\0\x0doutput-stream\x03\x01\x01h\x05\x01p}\x01j\x01\x08\x01\
\x04\x01@\x02\x04self\x07\x03lenw\0\x09\x04\0\x19[method]input-stream.read\x01\x0a\
\x04\0\"[method]input-stream.blocking-read\x01\x0a\x01j\x01w\x01\x04\x01@\x02\x04\
self\x07\x03lenw\0\x0b\x04\0\x19[method]input-stream.skip\x01\x0c\x04\0\"[method\
]input-stream.blocking-skip\x01\x0c\x01h\x06\x01@\x01\x04self\x0d\0\x0b\x04\0![m\
ethod]output-stream.check-write\x01\x0e\x01j\0\x01\x04\x01@\x02\x04self\x0d\x08c\
ontents\x08\0\x0f\x04\0\x1b[method]output-stream.write\x01\x10\x04\0.[method]out\
put-stream.blocking-write-and-flush\x01\x10\x01@\x01\x04self\x0d\0\x0f\x04\0\x1b\
[method]output-stream.flush\x01\x11\x04\0$[method]output-stream.blocking-flush\x01\
\x11\x01@\x02\x04self\x0d\x03lenw\0\x0f\x04\0\"[method]output-stream.write-zeroe\
s\x01\x12\x04\05[method]output-stream.blocking-write-zeroes-and-flush\x01\x12\x01\
@\x03\x04self\x0d\x03src\x07\x03lenw\0\x0b\x04\0\x1c[method]output-stream.splice\
\x01\x13\x04\0%[method]output-stream.blocking-splice\x01\x13\x03\x01\x15wasi:io/\
streams@0.2.0\x05\x04\x02\x03\0\x03\x0cinput-stream\x01B\x05\x02\x03\x02\x01\x05\
\x04\0\x0cinput-stream\x03\0\0\x01i\x01\x01@\0\0\x02\x04\0\x09get-stdin\x01\x03\x03\
\x01\x14wasi:cli/stdin@0.2.0\x05\x06\x02\x03\0\x03\x0doutput-stream\x01B\x05\x02\
\x03\x02\x01\x07\x04\0\x0doutput-stream\x03\0\0\x01i\x01\x01@\0\0\x02\x04\0\x0ag\
et-stdout\x01\x03\x03\x01\x15wasi:cli/stdout@0.2.0\x05\x08\x01B\x05\x02\x03\x02\x01\
\x07\x04\0\x0doutput-stream\x03\0\0\x01i\x01\x01@\0\0\x02\x04\0\x0aget-stderr\x01\
\x03\x03\x01\x15wasi:cli/stderr@0.2.0\x05\x09\x01B\x08\x01w\x04\0\x07instant\x03\
\0\0\x01w\x04\0\x08duration\x03\0\x02\x01@\0\0\x01\x04\0\x03now\x01\x04\x01@\0\0\
\x03\x04\0\x0aresolution\x01\x05\x03\x01!wasi:clocks/monotonic-clock@0.2.0\x05\x0a\
\x01B\x05\x01r\x02\x07secondsw\x0bnanosecondsy\x04\0\x08datetime\x03\0\0\x01@\0\0\
\x01\x04\0\x03now\x01\x02\x04\0\x0aresolution\x01\x02\x03\x01\x1cwasi:clocks/wal\
l-clock@0.2.0\x05\x0b\x02\x03\0\x03\x05error\x02\x03\0\x08\x08datetime\x01Br\x02\
\x03\x02\x01\x05\x04\0\x0cinput-stream\x03\0\0\x02\x03\x02\x01\x07\x04\0\x0doutp\
ut-stream\x03\0\x02\x02\x03\x02\x01\x0c\x04\0\x05error\x03\0\x04\x02\x03\x02\x01\
\x0d\x04\0\x08datetime\x03\0\x06\x01w\x04\0\x08filesize\x03\0\x08\x01m\x08\x07un\
known\x0cblock-device\x10character-device\x09directory\x04fifo\x0dsymbolic-link\x0c\
regular-file\x06socket\x04\0\x0fdescriptor-type\x03\0\x0a\x01n\x06\x04read\x05wr\
ite\x13file-integrity-sync\x13data-integrity-sync\x14requested-write-sync\x10mut\
ate-directory\x04\0\x10descriptor-flags\x03\0\x0c\x01n\x01\x0esymlink-follow\x04\
\0\x0apath-flags\x03\0\x0e\x01n\x04\x06create\x09directory\x09exclusive\x08trunc\
ate\x04\0\x0aopen-flags\x03\0\x10\x01w\x04\0\x0alink-count\x03\0\x12\x01k\x07\x01\
r\x06\x04type\x0b\x0alink-count\x13\x04size\x09\x15data-access-timestamp\x14\x1b\
data-modification-timestamp\x14\x17status-change-timestamp\x14\x04\0\x0fdescript\
or-stat\x03\0\x15\x01q\x03\x09no-change\0\0\x03now\0\0\x09timestamp\x01\x07\0\x04\
\0\x0dnew-timestamp\x03\0\x17\x01r\x02\x04type\x0b\x04names\x04\0\x0fdirectory-e\
ntry\x03\0\x19\x01m%\x06access\x0bwould-block\x07already\x0ebad-descriptor\x04bu\
sy\x08deadlock\x05quota\x05exist\x0efile-too-large\x15illegal-byte-sequence\x0bi\
n-progress\x0binterrupted\x07invalid\x02io\x0cis-directory\x04loop\x0etoo-many-l\
inks\x0cmessage-size\x0dname-too-long\x09no-device\x08no-entry\x07no-lock\x13ins\
ufficient-memory\x12insufficient-space\x0dnot-directory\x09not-empty\x0fnot-reco\
verable\x0bunsupported\x06no-tty\x0eno-such-device\x08overflow\x0dnot-permitted\x04\
pipe\x09read-only\x0cinvalid-seek\x0etext-file-busy\x0ccross-device\x04\0\x0aerr\
or-code\x03\0\x1b\x01m\x06\x06normal\x0asequential\x06random\x09will-need\x09don\
t-need\x08no-reuse\x04\0\x06advice\x03\0\x1d\x01r\x02\x05lowerw\x05upperw\x04\0\x13\
metadata-hash-value\x03\0\x1f\x04\0\x0adescriptor\x03\x01\x04\0\x16directory-ent\
ry-stream\x03\x01\x01h!\x01i\x01\x01j\x01$\x01\x1c\x01@\x02\x04self#\x06offset\x09\
\0%\x04\0\"[method]descriptor.read-via-stream\x01&\x01i\x03\x01j\x01'\x01\x1c\x01\
@\x02\x04self#\x06offset\x09\0(\x04\0#[method]descriptor.write-via-stream\x01)\x01\
@\x01\x04self#\0(\x04\0$[method]descriptor.append-via-stream\x01*\x01j\0\x01\x1c\
\x01@\x04\x04self#\x06offset\x09\x06length\x09\x06advice\x1e\0+\x04\0\x19[method\
]descriptor.advise\x01,\x01@\x01\x04self#\0+\x04\0\x1c[method]descriptor.sync-da\
ta\x01-\x01j\x01\x0d\x01\x1c\x01@\x01\x04self#\0.\x04\0\x1c[method]descriptor.ge\
t-flags\x01/\x01j\x01\x0b\x01\x1c\x01@\x01\x04self#\00\x04\0\x1b[method]descript\
or.get-type\x011\x01@\x02\x04self#\x04size\x09\0+\x04\0\x1b[method]descriptor.se\
t-size\x012\x01@\x03\x04self#\x15data-access-timestamp\x18\x1bdata-modification-\
timestamp\x18\0+\x04\0\x1c[method]descriptor.set-times\x013\x01p}\x01o\x024\x7f\x01\
j\x015\x01\x1c\x01@\x03\x04self#\x06length\x09\x06offset\x09\06\x04\0\x17[method\
]descriptor.read\x017\x01j\x01\x09\x01\x1c\x01@\x03\x04self#\x06buffer4\x06offse\
t\x09\08\x04\0\x18[method]descriptor.write\x019\x01i\"\x01j\x01:\x01\x1c\x01@\x01\
\x04self#\0;\x04\0![method]descriptor.read-directory\x01<\x04\0\x17[method]descr\
iptor.sync\x01-\x01@\x02\x04self#\x04paths\0+\x04\0&[method]descriptor.create-di\
rectory-at\x01=\x01j\x01\x16\x01\x1c\x01@\x01\x04self#\0>\x04\0\x17[method]descr\
iptor.stat\x01?\x01@\x03\x04self#\x0apath-flags\x0f\x04paths\0>\x04\0\x1a[method\
]descriptor.stat-at\x01@\x01@\x05\x04self#\x0apath-flags\x0f\x04paths\x15data-ac\
cess-timestamp\x18\x1bdata-modification-timestamp\x18\0+\x04\0\x1f[method]descri\
ptor.set-times-at\x01A\x01@\x05\x04self#\x0eold-path-flags\x0f\x08old-paths\x0en\
ew-descriptor#\x08new-paths\0+\x04\0\x1a[method]descriptor.link-at\x01B\x01i!\x01\
j\x01\xc3\0\x01\x1c\x01@\x05\x04self#\x0apath-flags\x0f\x04paths\x0aopen-flags\x11\
\x05flags\x0d\0\xc4\0\x04\0\x1a[method]descriptor.open-at\x01E\x01j\x01s\x01\x1c\
\x01@\x02\x04self#\x04paths\0\xc6\0\x04\0\x1e[method]descriptor.readlink-at\x01G\
\x04\0&[method]descriptor.remove-directory-at\x01=\x01@\x04\x04self#\x08old-path\
s\x0enew-descriptor#\x08new-paths\0+\x04\0\x1c[method]descriptor.rename-at\x01H\x01\
@\x03\x04self#\x08old-paths\x08new-paths\0+\x04\0\x1d[method]descriptor.symlink-\
at\x01I\x04\0![method]descriptor.unlink-file-at\x01=\x01@\x02\x04self#\x05other#\
\0\x7f\x04\0![method]descriptor.is-same-object\x01J\x01j\x01\x20\x01\x1c\x01@\x01\
\x04self#\0\xcb\0\x04\0\x20[method]descriptor.metadata-hash\x01L\x01@\x03\x04sel\
f#\x0apath-flags\x0f\x04paths\0\xcb\0\x04\0#[method]descriptor.metadata-hash-at\x01\
M\x01h\"\x01k\x1a\x01j\x01\xcf\0\x01\x1c\x01@\x01\x04self\xce\0\0\xd0\0\x04\03[m\
ethod]directory-entry-stream.read-directory-entry\x01Q\x01h\x05\x01k\x1c\x01@\x01\
\x03err\xd2\0\0\xd3\0\x04\0\x15filesystem-error-code\x01T\x03\x01\x1bwasi:filesy\
stem/types@0.2.0\x05\x0e\x02\x03\0\x09\x0adescriptor\x01B\x07\x02\x03\x02\x01\x0f\
\x04\0\x0adescriptor\x03\0\0\x01i\x01\x01o\x02\x02s\x01p\x03\x01@\0\0\x04\x04\0\x0f\
get-directories\x01\x05\x03\x01\x1ewasi:filesystem/preopens@0.2.0\x05\x10\x01B\x05\
\x01p}\x01@\x01\x03lenw\0\0\x04\0\x10get-random-bytes\x01\x01\x01@\0\0w\x04\0\x0e\
get-random-u64\x01\x02\x03\x01\x18wasi:random/random@0.2.0\x05\x11\x01B\x05\x01p\
}\x01@\x01\x03lenw\0\0\x04\0\x19get-insecure-random-bytes\x01\x01\x01@\0\0w\x04\0\
\x17get-insecure-random-u64\x01\x02\x03\x01\x1awasi:random/insecure@0.2.0\x05\x12\
\x01B\x03\x01o\x02ww\x01@\0\0\0\x04\0\x0dinsecure-seed\x01\x01\x03\x01\x1fwasi:r\
andom/insecure-seed@0.2.0\x05\x13\x02\x03\0\x07\x08duration\x01B\xb9\x01\x02\x03\
\x02\x01\x14\x04\0\x08duration\x03\0\0\x02\x03\x02\x01\x05\x04\0\x0cinput-stream\
\x03\0\x02\x02\x03\x02\x01\x07\x04\0\x0doutput-stream\x03\0\x04\x02\x03\x02\x01\x03\
\x04\0\x08io-error\x03\0\x06\x01q\x0a\x03get\0\0\x04head\0\0\x04post\0\0\x03put\0\
\0\x06delete\0\0\x07connect\0\0\x07options\0\0\x05trace\0\0\x05patch\0\0\x05othe\
r\x01s\0\x04\0\x06method\x03\0\x08\x01q\x03\x04HTTP\0\0\x05HTTPS\0\0\x05other\x01\
s\0\x04\0\x06scheme\x03\0\x0a\x01ks\x01k{\x01r\x02\x05rcode\x0c\x09info-code\x0d\
\x04\0\x11DNS-error-payload\x03\0\x0e\x01k}\x01r\x02\x08alert-id\x10\x0dalert-me\
ssage\x0c\x04\0\x1aTLS-alert-received-payload\x03\0\x11\x01ky\x01r\x02\x0afield-\
name\x0c\x0afield-size\x13\x04\0\x12field-size-payload\x03\0\x14\x01kw\x01k\x15\x01\
q'\x0bDNS-timeout\0\0\x09DNS-error\x01\x0f\0\x15destination-not-found\0\0\x17des\
tination-unavailable\0\0\x19destination-IP-prohibited\0\0\x19destination-IP-unro\
utable\0\0\x12connection-refused\0\0\x15connection-terminated\0\0\x12connection-\
timeout\0\0\x17connection-read-timeout\0\0\x18connection-write-timeout\0\0\x18co\
nnection-limit-reached\0\0\x12TLS-protocol-error\0\0\x15TLS-certificate-error\0\0\
\x12TLS-alert-received\x01\x12\0\x13HTTP-request-denied\0\0\x1cHTTP-request-leng\
th-required\0\0\x16HTTP-request-body-size\x01\x16\0\x1bHTTP-request-method-inval\
id\0\0\x18HTTP-request-URI-invalid\0\0\x19HTTP-request-URI-too-long\0\0\x20HTTP-\
request-header-section-size\x01\x13\0\x18HTTP-request-header-size\x01\x17\0!HTTP\
-request-trailer-section-size\x01\x13\0\x19HTTP-request-trailer-size\x01\x15\0\x18\
HTTP-response-incomplete\0\0!HTTP-response-header-section-size\x01\x13\0\x19HTTP\
-response-header-size\x01\x15\0\x17HTTP-response-body-size\x01\x16\0\"HTTP-respo\
nse-trailer-section-size\x01\x13\0\x1aHTTP-response-trailer-size\x01\x15\0\x1dHT\
TP-response-transfer-coding\x01\x0c\0\x1cHTTP-response-content-coding\x01\x0c\0\x15\
HTTP-response-timeout\0\0\x13HTTP-upgrade-failed\0\0\x13HTTP-protocol-error\0\0\x0d\
loop-detected\0\0\x13configuration-error\0\0\x0einternal-error\x01\x0c\0\x04\0\x0a\
error-code\x03\0\x18\x01q\x03\x0einvalid-syntax\0\0\x09forbidden\0\0\x09immutabl\
e\0\0\x04\0\x0cheader-error\x03\0\x1a\x01s\x04\0\x09field-key\x03\0\x1c\x01p}\x04\
\0\x0bfield-value\x03\0\x1e\x04\0\x06fields\x03\x01\x04\0\x07headers\x03\0\x20\x04\
\0\x08trailers\x03\0\x20\x04\0\x10incoming-request\x03\x01\x04\0\x10outgoing-req\
uest\x03\x01\x04\0\x0frequest-options\x03\x01\x04\0\x11response-outparam\x03\x01\
\x01{\x04\0\x0bstatus-code\x03\0'\x04\0\x11incoming-response\x03\x01\x04\0\x0din\
coming-body\x03\x01\x04\0\x0ffuture-trailers\x03\x01\x04\0\x11outgoing-response\x03\
\x01\x04\0\x0doutgoing-body\x03\x01\x04\0\x18future-incoming-response\x03\x01\x01\
i\x20\x01@\0\0/\x04\0\x13[constructor]fields\x010\x01o\x02\x1d\x1f\x01p1\x01j\x01\
/\x01\x1b\x01@\x01\x07entries2\03\x04\0\x18[static]fields.from-list\x014\x01h\x20\
\x01p\x1f\x01@\x02\x04self5\x04name\x1d\06\x04\0\x12[method]fields.get\x017\x01@\
\x02\x04self5\x04name\x1d\0\x7f\x04\0\x12[method]fields.has\x018\x01j\0\x01\x1b\x01\
@\x03\x04self5\x04name\x1d\x05value6\09\x04\0\x12[method]fields.set\x01:\x01@\x02\
\x04self5\x04name\x1d\09\x04\0\x15[method]fields.delete\x01;\x01@\x03\x04self5\x04\
name\x1d\x05value\x1f\09\x04\0\x15[method]fields.append\x01<\x01@\x01\x04self5\0\
2\x04\0\x16[method]fields.entries\x01=\x01@\x01\x04self5\0/\x04\0\x14[method]fie\
lds.clone\x01>\x01h#\x01@\x01\x04self?\0\x09\x04\0\x1f[method]incoming-request.m\
ethod\x01@\x01@\x01\x04self?\0\x0c\x04\0([method]incoming-request.path-with-quer\
y\x01A\x01k\x0b\x01@\x01\x04self?\0\xc2\0\x04\0\x1f[method]incoming-request.sche\
me\x01C\x04\0\"[method]incoming-request.authority\x01A\x01i!\x01@\x01\x04self?\0\
\xc4\0\x04\0\x20[method]incoming-request.headers\x01E\x01i*\x01j\x01\xc6\0\0\x01\
@\x01\x04self?\0\xc7\0\x04\0\x20[method]incoming-request.consume\x01H\x01i$\x01@\
\x01\x07headers\xc4\0\0\xc9\0\x04\0\x1d[constructor]outgoing-request\x01J\x01h$\x01\
i-\x01j\x01\xcc\0\0\x01@\x01\x04self\xcb\0\0\xcd\0\x04\0\x1d[method]outgoing-req\
uest.body\x01N\x01@\x01\x04self\xcb\0\0\x09\x04\0\x1f[method]outgoing-request.me\
thod\x01O\x01j\0\0\x01@\x02\x04self\xcb\0\x06method\x09\0\xd0\0\x04\0#[method]ou\
tgoing-request.set-method\x01Q\x01@\x01\x04self\xcb\0\0\x0c\x04\0([method]outgoi\
ng-request.path-with-query\x01R\x01@\x02\x04self\xcb\0\x0fpath-with-query\x0c\0\xd0\
\0\x04\0,[method]outgoing-request.set-path-with-query\x01S\x01@\x01\x04self\xcb\0\
\0\xc2\0\x04\0\x1f[method]outgoing-request.scheme\x01T\x01@\x02\x04self\xcb\0\x06\
scheme\xc2\0\0\xd0\0\x04\0#[method]outgoing-request.set-scheme\x01U\x04\0\"[meth\
od]outgoing-request.authority\x01R\x01@\x02\x04self\xcb\0\x09authority\x0c\0\xd0\
\0\x04\0&[method]outgoing-request.set-authority\x01V\x01@\x01\x04self\xcb\0\0\xc4\
\0\x04\0\x20[method]outgoing-request.headers\x01W\x01i%\x01@\0\0\xd8\0\x04\0\x1c\
[constructor]request-options\x01Y\x01h%\x01k\x01\x01@\x01\x04self\xda\0\0\xdb\0\x04\
\0'[method]request-options.connect-timeout\x01\\\x01@\x02\x04self\xda\0\x08durat\
ion\xdb\0\0\xd0\0\x04\0+[method]request-options.set-connect-timeout\x01]\x04\0*[\
method]request-options.first-byte-timeout\x01\\\x04\0.[method]request-options.se\
t-first-byte-timeout\x01]\x04\0-[method]request-options.between-bytes-timeout\x01\
\\\x04\01[method]request-options.set-between-bytes-timeout\x01]\x01i&\x01i,\x01j\
\x01\xdf\0\x01\x19\x01@\x02\x05param\xde\0\x08response\xe0\0\x01\0\x04\0\x1d[sta\
tic]response-outparam.set\x01a\x01h)\x01@\x01\x04self\xe2\0\0(\x04\0\x20[method]\
incoming-response.status\x01c\x01@\x01\x04self\xe2\0\0\xc4\0\x04\0![method]incom\
ing-response.headers\x01d\x01@\x01\x04self\xe2\0\0\xc7\0\x04\0![method]incoming-\
response.consume\x01e\x01h*\x01i\x03\x01j\x01\xe7\0\0\x01@\x01\x04self\xe6\0\0\xe8\
\0\x04\0\x1c[method]incoming-body.stream\x01i\x01i+\x01@\x01\x04this\xc6\0\0\xea\
\0\x04\0\x1c[static]incoming-body.finish\x01k\x01h+\x01i\"\x01k\xed\0\x01j\x01\xee\
\0\x01\x19\x01j\x01\xef\0\0\x01k\xf0\0\x01@\x01\x04self\xec\0\0\xf1\0\x04\0\x1b[\
method]future-trailers.get\x01r\x01@\x01\x07headers\xc4\0\0\xdf\0\x04\0\x1e[cons\
tructor]outgoing-response\x01s\x01h,\x01@\x01\x04self\xf4\0\0(\x04\0%[method]out\
going-response.status-code\x01u\x01@\x02\x04self\xf4\0\x0bstatus-code(\0\xd0\0\x04\
\0)[method]outgoing-response.set-status-code\x01v\x01@\x01\x04self\xf4\0\0\xc4\0\
\x04\0![method]outgoing-response.headers\x01w\x01@\x01\x04self\xf4\0\0\xcd\0\x04\
\0\x1e[method]outgoing-response.body\x01x\x01h-\x01i\x05\x01j\x01\xfa\0\0\x01@\x01\
\x04self\xf9\0\0\xfb\0\x04\0\x1b[method]outgoing-body.write\x01|\x01j\0\x01\x19\x01\
@\x02\x04this\xcc\0\x08trailers\xee\0\0\xfd\0\x04\0\x1c[static]outgoing-body.fin\
ish\x01~\x01h.\x01i)\x01j\x01\x80\x01\x01\x19\x01j\x01\x81\x01\0\x01k\x82\x01\x01\
@\x01\x04self\xff\0\0\x83\x01\x04\0$[method]future-incoming-response.get\x01\x84\
\x01\x01h\x07\x01k\x19\x01@\x01\x03err\x85\x01\0\x86\x01\x04\0\x0fhttp-error-cod\
e\x01\x87\x01\x03\x01\x15wasi:http/types@0.2.0\x05\x15\x02\x03\0\x0e\x10outgoing\
-request\x02\x03\0\x0e\x0frequest-options\x02\x03\0\x0e\x18future-incoming-respo\
nse\x02\x03\0\x0e\x0aerror-code\x01B\x0f\x02\x03\x02\x01\x16\x04\0\x10outgoing-r\
equest\x03\0\0\x02\x03\x02\x01\x17\x04\0\x0frequest-options\x03\0\x02\x02\x03\x02\
\x01\x18\x04\0\x18future-incoming-response\x03\0\x04\x02\x03\x02\x01\x19\x04\0\x0a\
error-code\x03\0\x06\x01i\x01\x01i\x03\x01k\x09\x01i\x05\x01j\x01\x0b\x01\x07\x01\
@\x02\x07request\x08\x07options\x0a\0\x0c\x04\0\x06handle\x01\x0d\x03\x01\x20was\
i:http/outgoing-handler@0.2.0\x05\x1a\x01B\x08\x01p}\x04\0\x04bstr\x03\0\0\x01o\x02\
ww\x04\0\x04b128\x03\0\x02\x01o\x04wwww\x04\0\x04b256\x03\0\x04\x01o\x08wwwwwwww\
\x04\0\x04b512\x03\0\x06\x03\x01\x11hermes:binary/api\x05\x1b\x02\x03\0\x10\x04b\
str\x01B\x03\x02\x03\x02\x01\x1c\x04\0\x04bstr\x03\0\0\x04\0\x04cbor\x03\0\x01\x03\
\x01\x0fhermes:cbor/api\x05\x1d\x02\x03\0\x11\x04cbor\x01B$\x02\x03\x02\x01\x1c\x04\
\0\x04bstr\x03\0\0\x02\x03\x02\x01\x1e\x04\0\x04cbor\x03\0\x02\x04\0\x0dcardano-\
block\x03\0\x03\x04\0\x0bcardano-txn\x03\0\x03\x01m\x04\x07mainnet\x07preprod\x07\
preview\x15local-test-blockchain\x04\0\x15cardano-blockchain-id\x03\0\x06\x01n\x03\
\x03tip\x04node\x07mithril\x04\0\x09block-src\x03\0\x08\x01o\x02w\x01\x01q\x04\x07\
genesis\0\0\x05point\x01\x0a\0\x03tip\0\0\x08continue\0\0\x04\0\x04slot\x03\0\x0b\
\x01m\x02\x18blockchain-not-available\x0cinvalid-slot\x04\0\x0bfetch-error\x03\0\
\x0d\x01m\x03\x18blockchain-not-available\x15malformed-transaction\x14post-txn-n\
ot-allowed\x04\0\x09txn-error\x03\0\x0f\x01n\x04\x05block\x0btransaction\x08roll\
back\x04stop\x04\0\x13unsubscribe-options\x03\0\x11\x01j\x01w\x01\x0e\x01@\x02\x03\
net\x07\x06whence\x0c\0\x13\x04\0\x10subscribe-blocks\x01\x14\x01@\x02\x03net\x07\
\x04opts\x12\x01\0\x04\0\x0bunsubscribe\x01\x15\x01@\x01\x03net\x07\x01\0\x04\0\x0d\
subscribe-txn\x01\x16\x04\0\x12subscribe-rollback\x01\x16\x01j\x01\x04\x01\x0e\x01\
@\x02\x03net\x07\x06whence\x0c\0\x17\x04\0\x0bfetch-block\x01\x18\x01p\x05\x01@\x01\
\x05block\x04\0\x19\x04\0\x08get-txns\x01\x1a\x01j\0\x01\x10\x01@\x02\x03net\x07\
\x03txn\x05\0\x1b\x04\0\x08post-txn\x01\x1c\x03\x01\x12hermes:cardano/api\x05\x1f\
\x02\x03\0\x07\x07instant\x01B\x1a\x02\x03\x02\x01\x20\x04\0\x07instant\x03\0\0\x01\
s\x04\0\x0ecron-event-tag\x03\0\x02\x01s\x04\0\x0acron-sched\x03\0\x04\x01r\x02\x04\
when\x05\x03tag\x03\x04\0\x0bcron-tagged\x03\0\x06\x01o\x02}}\x01q\x03\x03all\0\0\
\x02at\x01}\0\x05range\x01\x08\0\x04\0\x0ecron-component\x03\0\x09\x01p\x0a\x04\0\
\x09cron-time\x03\0\x0b\x01@\x02\x05entry\x07\x09retrigger\x7f\0\x7f\x04\0\x03ad\
d\x01\x0d\x01@\x02\x08duration\x01\x03tag\x03\0\x7f\x04\0\x05delay\x01\x0e\x01k\x03\
\x01o\x02\x07\x7f\x01p\x10\x01@\x01\x03tag\x0f\0\x11\x04\0\x02ls\x01\x12\x01@\x01\
\x05entry\x07\0\x7f\x04\0\x02rm\x01\x13\x01@\x05\x03dow\x0c\x05month\x0c\x03day\x0c\
\x04hour\x0c\x06minute\x0c\0\x05\x04\0\x06mkcron\x01\x14\x03\x01\x0fhermes:cron/\
api\x05!\x02\x03\0\x10\x04b256\x02\x03\0\x10\x04b512\x01B&\x02\x03\x02\x01\x1c\x04\
\0\x04bstr\x03\0\0\x02\x03\x02\x01\"\x04\0\x04b256\x03\0\x02\x02\x03\x02\x01#\x04\
\0\x04b512\x03\0\x04\x01m\x07\x0fprefix-too-long\x17invalid-mnemonic-length\x0ew\
ord-not-found\x10invalid-mnemonic\x19invalid-derivational-path\x17generate-entro\
py-failed\x14unsupported-language\x04\0\x05errno\x03\0\x06\x04\0\x19bip32-ed2551\
9-private-key\x03\0\x03\x04\0\"bip32-ed25519-extended-private-key\x03\0\x05\x04\0\
\x18bip32-ed25519-public-key\x03\0\x03\x04\0\x17bip32-ed25519-signature\x03\0\x05\
\x01ps\x04\0\x0fmnemonic-phrase\x03\0\x0c\x01ps\x04\0\x0apassphrase\x03\0\x0e\x01\
s\x04\0\x04path\x03\0\x10\x01ps\x04\0\x06prefix\x03\0\x12\x04\0\x0dbip32-ed25519\
\x03\x01\x01k\x0f\x01i\x14\x01@\x02\x08mnemonic\x0d\x0apassphrase\x15\0\x16\x04\0\
\x1a[constructor]bip32-ed25519\x01\x17\x01h\x14\x01@\x01\x04self\x18\0\x0a\x04\0\
\x20[method]bip32-ed25519.public-key\x01\x19\x01@\x02\x04self\x18\x04data\x01\0\x0b\
\x04\0\x1f[method]bip32-ed25519.sign-data\x01\x1a\x01@\x03\x04self\x18\x04data\x01\
\x03sig\x0b\0\x7f\x04\0\x1f[method]bip32-ed25519.check-sig\x01\x1b\x01@\x02\x04s\
elf\x18\x04path\x11\0\x16\x04\0\x1c[method]bip32-ed25519.derive\x01\x1c\x01ks\x01\
j\x01\x0d\x01\x07\x01@\x03\x04size}\x06prefix\x13\x08language\x1d\0\x1e\x04\0\x11\
generate-mnemonic\x01\x1f\x03\x01\x11hermes:crypto/api\x05$\x01B\x0f\x02\x03\x02\
\x01\x1c\x04\0\x04bstr\x03\0\0\x01m\x05\x0bkey-too-big\x0chash-too-big\x0csalt-t\
oo-big\x10personal-too-big\x1ainvalid-digest-byte-length\x04\0\x05errno\x03\0\x02\
\x01k}\x01j\x01\x01\x01\x03\x01@\x02\x03buf\x01\x06outlen\x04\0\x05\x04\0\x07bla\
ke2s\x01\x06\x01k\x01\x01@\x05\x03buf\x01\x06outlen\x04\x03key\x01\x04salt\x07\x08\
personal\x07\0\x05\x04\0\x0ablake2smac\x01\x08\x04\0\x07blake2b\x01\x06\x04\0\x0a\
blake2bmac\x01\x08\x01@\x03\x03buf\x01\x06outlen\x04\x03key\x07\0\x05\x04\0\x06b\
lake3\x01\x09\x03\x01\x0fhermes:hash/api\x05%\x01B1\x01p}\x04\0\x07dht-key\x03\0\
\0\x01p}\x04\0\x09dht-value\x03\0\x02\x01p}\x04\0\x09ipfs-file\x03\0\x04\x01s\x04\
\0\x09ipfs-path\x03\0\x06\x01p}\x04\0\x0cmessage-data\x03\0\x08\x01p}\x04\0\x0am\
essage-id\x03\0\x0a\x01s\x04\0\x07peer-id\x03\0\x0c\x01s\x04\0\x0cpubsub-topic\x03\
\0\x0e\x01o\x02\x01\x03\x01o\x02\x0f\x09\x01q\x02\x03dht\x01\x10\0\x06pubsub\x01\
\x11\0\x04\0\x0cipfs-content\x03\0\x12\x01k\x0d\x01r\x03\x05topic\x0f\x07message\
\x09\x09publisher\x14\x04\0\x0epubsub-message\x03\0\x15\x01m\x0f\x0ddht-get-erro\
r\x0ddht-put-error\x0efile-add-error\x0efile-get-error\x0efile-pin-error\x0binva\
lid-cid\x0finvalid-dht-key\x11invalid-dht-value\x11invalid-ipfs-path\x0finvalid-\
peer-id\x16invalid-pubsub-message\x13peer-eviction-error\x14pubsub-publish-error\
\x16pubsub-subscribe-error\x13service-unavailable\x04\0\x05errno\x03\0\x17\x01j\x01\
\x7f\x01\x18\x01@\x02\x03key\x01\x05value\x03\0\x19\x04\0\x07dht-put\x01\x1a\x01\
j\x01\x03\x01\x18\x01@\x01\x03key\x01\0\x1b\x04\0\x07dht-get\x01\x1c\x01@\x01\x07\
content\x13\0\x19\x04\0\x15ipfs-content-validate\x01\x1d\x01j\x01\x07\x01\x18\x01\
@\x01\x08contents\x05\0\x1e\x04\0\x08file-add\x01\x1f\x01j\x01\x05\x01\x18\x01@\x01\
\x04path\x07\0\x20\x04\0\x08file-get\x01!\x01@\x01\x04path\x07\0\x19\x04\0\x08fi\
le-pin\x01\"\x04\0\x0afile-unpin\x01\"\x01@\x01\x04peer\x0d\0\x19\x04\0\x0apeer-\
evict\x01#\x01j\x01\x0b\x01\x18\x01@\x02\x05topic\x0f\x07message\x09\0$\x04\0\x0e\
pubsub-publish\x01%\x01@\x01\x05topic\x0f\0\x19\x04\0\x10pubsub-subscribe\x01&\x03\
\x01\x0fhermes:ipfs/api\x05&\x01B\x02\x01s\x04\0\x04json\x03\0\0\x03\x01\x0fherm\
es:json/api\x05'\x02\x03\0\x17\x04json\x01B\x16\x02\x03\x02\x01\x1c\x04\0\x04bst\
r\x03\0\0\x02\x03\x02\x01\x1e\x04\0\x04cbor\x03\0\x02\x02\x03\x02\x01(\x04\0\x04\
json\x03\0\x04\x01q\x07\x09kv-string\x01s\0\x06kv-s64\x01x\0\x06kv-u64\x01w\0\x06\
kv-f64\x01u\0\x07kv-bstr\x01\x01\0\x07kv-cbor\x01\x03\0\x07kv-json\x01\x05\0\x04\
\0\x09kv-values\x03\0\x06\x01k\x07\x01@\x02\x03keys\x05value\x08\x01\0\x04\0\x06\
kv-set\x01\x09\x01@\x02\x03keys\x07default\x08\0\x08\x04\0\x0ekv-get-default\x01\
\x0a\x01@\x01\x03keys\0\x08\x04\0\x06kv-get\x01\x0b\x01@\x02\x03keys\x05value\x08\
\0\x08\x04\0\x0akv-get-set\x01\x0c\x04\0\x06kv-add\x01\x0c\x01@\x03\x03keys\x04t\
est\x08\x05value\x08\0\x08\x04\0\x06kv-cas\x01\x0d\x04\0\x0ckv-subscribe\x01\x0b\
\x04\0\x0ekv-unsubscribe\x01\x0b\x03\x01\x13hermes:kv-store/api\x05)\x01B\x12\x02\
\x03\x02\x01\x0d\x04\0\x08datetime\x03\0\0\x01s\x04\0\x08timezone\x03\0\x02\x01r\
\x09\x04yearw\x05month}\x03dow}\x03day}\x02hh}\x02mm}\x02ss}\x02nsy\x02tz\x03\x04\
\0\x09localtime\x03\0\x04\x01m\x03\x11invalid-localtime\x10unknown-timezone\x11y\
ear-out-of-range\x04\0\x05errno\x03\0\x06\x01k\x01\x01k\x03\x01j\x01\x05\x01\x07\
\x01@\x02\x04when\x08\x02tz\x09\0\x0a\x04\0\x0dget-localtime\x01\x0b\x01@\x02\x04\
time\x05\x02tz\x09\0\x0a\x04\0\x0dalt-localtime\x01\x0c\x01j\x01\x01\x01\x07\x01\
@\x01\x04time\x05\0\x0d\x04\0\x0cget-datetime\x01\x0e\x03\x01\x14hermes:localtim\
e/api\x05*\x01B\x09\x02\x03\x02\x01(\x04\0\x04json\x03\0\0\x01m\x05\x05debug\x05\
trace\x04info\x04warn\x05error\x04\0\x05level\x03\0\x02\x01ks\x01ky\x01k\x01\x01\
@\x08\x05level\x03\x04file\x04\x08function\x04\x04line\x05\x03col\x05\x03ctx\x04\
\x03msgs\x04data\x06\x01\0\x04\0\x03log\x01\x07\x03\x01\x12hermes:logging/api\x05\
+\x01B#\x01r\x02\x04codez\x07messages\x04\0\x0aerror-info\x03\0\0\x01q\x0b\x06sq\
lite\x01z\0\x13converting-c-string\0\0\x18invalid-in-memory-config\0\0\x19invali\
d-persistent-config\0\0+missing-database-name-for-persistent-config\0\0\x17faile\
d-opening-database\0\0\x1cfailed-setting-database-size\0\0\x13unknown-column-typ\
e\0\0\x18forbidden-pragma-command\0\0\x15returned-null-pointer\0\0\x12converting\
-numeric\0\0\x04\0\x05errno\x03\0\x02\x01p}\x01q\x06\x04blob\x01\x04\0\x06double\
\x01u\0\x05int32\x01z\0\x05int64\x01x\0\x04null\0\0\x04text\x01s\0\x04\0\x05valu\
e\x03\0\x05\x04\0\x06sqlite\x03\x01\x04\0\x09statement\x03\x01\x01h\x07\x01j\0\x01\
\x03\x01@\x01\x04self\x09\0\x0a\x04\0\x14[method]sqlite.close\x01\x0b\x01k\x01\x01\
@\x01\x04self\x09\0\x0c\x04\0\x16[method]sqlite.errcode\x01\x0d\x01i\x08\x01j\x01\
\x0e\x01\x03\x01@\x02\x04self\x09\x03sqls\0\x0f\x04\0\x16[method]sqlite.prepare\x01\
\x10\x01@\x02\x04self\x09\x03sqls\0\x0a\x04\0\x16[method]sqlite.execute\x01\x11\x01\
h\x08\x01@\x03\x04self\x12\x05indexy\x05value\x06\0\x0a\x04\0\x16[method]stateme\
nt.bind\x01\x13\x01@\x01\x04self\x12\0\x0a\x04\0\x16[method]statement.step\x01\x14\
\x01j\x01\x06\x01\x03\x01@\x02\x04self\x12\x05indexy\0\x15\x04\0\x18[method]stat\
ement.column\x01\x16\x04\0\x1a[method]statement.finalize\x01\x14\x01i\x07\x01j\x01\
\x17\x01\x03\x01@\x02\x08readonly\x7f\x06memory\x7f\0\x18\x04\0\x04open\x01\x19\x03\
\x01\x11hermes:sqlite/api\x05,\x01B\x06\x01p}\x01ks\x01r\x04\x08host-uris\x04por\
t{\x04body\0\x0arequest-id\x01\x04\0\x07payload\x03\0\x02\x01@\x01\x01p\x03\0\x7f\
\x04\0\x04send\x01\x04\x03\x01\x17hermes:http-request/api\x05-\x02\x03\0\x0e\x10\
incoming-request\x02\x03\0\x0e\x11response-outparam\x01B\x08\x02\x03\x02\x01.\x04\
\0\x10incoming-request\x03\0\0\x02\x03\x02\x01/\x04\0\x11response-outparam\x03\0\
\x02\x01i\x01\x01i\x03\x01@\x02\x07request\x04\x0cresponse-out\x05\x01\0\x04\0\x06\
handle\x01\x06\x04\x01\x20wasi:http/incoming-handler@0.2.0\x050\x02\x03\0\x12\x15\
cardano-blockchain-id\x02\x03\0\x12\x0dcardano-block\x02\x03\0\x12\x09block-src\x01\
B\x08\x02\x03\x02\x011\x04\0\x15cardano-blockchain-id\x03\0\0\x02\x03\x02\x012\x04\
\0\x0dcardano-block\x03\0\x02\x02\x03\x02\x013\x04\0\x09block-src\x03\0\x04\x01@\
\x03\x0ablockchain\x01\x05block\x03\x06source\x05\x01\0\x04\0\x10on-cardano-bloc\
k\x01\x06\x04\x01\x1dhermes:cardano/event-on-block\x054\x02\x03\0\x12\x0bcardano\
-txn\x01B\x06\x02\x03\x02\x011\x04\0\x15cardano-blockchain-id\x03\0\0\x02\x03\x02\
\x015\x04\0\x0bcardano-txn\x03\0\x02\x01@\x04\x0ablockchain\x01\x04slotw\x09txn-\
indexy\x03txn\x03\x01\0\x04\0\x0eon-cardano-txn\x01\x04\x04\x01\x1bhermes:cardan\
o/event-on-txn\x056\x01B\x04\x02\x03\x02\x011\x04\0\x15cardano-blockchain-id\x03\
\0\0\x01@\x02\x0ablockchain\x01\x04slotw\x01\0\x04\0\x13on-cardano-rollback\x01\x02\
\x04\x01\x20hermes:cardano/event-on-rollback\x057\x02\x03\0\x13\x0ecron-event-ta\
g\x02\x03\0\x13\x0bcron-tagged\x01B\x06\x02\x03\x02\x018\x04\0\x0ecron-event-tag\
\x03\0\0\x02\x03\x02\x019\x04\0\x0bcron-tagged\x03\0\x02\x01@\x02\x05event\x03\x04\
last\x7f\0\x7f\x04\0\x07on-cron\x01\x04\x04\x01\x11hermes:cron/event\x05:\x01B\x02\
\x01@\0\0\x7f\x04\0\x04init\x01\0\x04\x01\x11hermes:init/event\x05;\x02\x03\0\x16\
\x0epubsub-message\x01B\x04\x02\x03\x02\x01<\x04\0\x0epubsub-message\x03\0\0\x01\
@\x01\x07message\x01\0\x7f\x04\0\x08on-topic\x01\x02\x04\x01\x11hermes:ipfs/even\
t\x05=\x02\x03\0\x18\x09kv-values\x01B\x04\x02\x03\x02\x01>\x04\0\x09kv-values\x03\
\0\0\x01@\x02\x03keys\x05value\x01\x01\0\x04\0\x09kv-update\x01\x02\x04\x01\x15h\
ermes:kv-store/event\x05?\x01B\x06\x01r\x02\x04names\x06status\x7f\x04\0\x0btest\
-result\x03\0\0\x01k\x01\x01@\x02\x04testy\x03run\x7f\0\x02\x04\0\x04test\x01\x03\
\x04\0\x05bench\x01\x03\x04\x01\x1dhermes:integration-test/event\x05@\x01B\x0c\x02\
\x03\x02\x01\x1c\x04\0\x04bstr\x03\0\0\x01ps\x01o\x02s\x02\x04\0\x06header\x03\0\
\x03\x01p\x04\x04\0\x07headers\x03\0\x05\x01r\x03\x04code{\x07headers\x06\x04bod\
y\x01\x04\0\x0dhttp-response\x03\0\x07\x01k\x08\x01@\x04\x04body\x01\x07headers\x06\
\x04paths\x06methods\0\x09\x04\0\x05reply\x01\x0a\x04\x01\x19hermes:http-gateway\
/event\x05A\x01B\x02\x01@\x02\x0arequest-ids\x08responses\x01\0\x04\0\x10on-http\
-response\x01\0\x04\x01*hermes:http-request/event-on-http-response\x05B\x04\x01\x12\
hermes:wasi/hermes\x04\0\x0b\x0c\x01\0\x06hermes\x03\0\0\0G\x09producers\x01\x0c\
processed-by\x02\x0dwit-component\x070.215.0\x10wit-bindgen-rust\x060.29.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

