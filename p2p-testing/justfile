# ==============================================================================
# Hermes P2P Testing Environment
# ==============================================================================
#
# 6-node Docker setup for testing P2P features:
# - Persistent IPFS keypairs (peer IDs stable across stop/restart)
# - Dynamic bootstrap discovery (syncs docker-compose.yml after volume clean)
# - Bootstrap retry logic (automatic reconnection on failures)
# - Gossipsub v1.2 PubSub with on-topic event handler
# - Full mesh connectivity on isolated network (172.20.0.0/16)
#
# WHY 6 NODES?
#   Gossipsub's mesh_n parameter (default: 6) defines the target number of peers
#   each node maintains in its PubSub mesh. With fewer than 6 peers, publish
#   operations block waiting for the mesh to reach target size. Alternative would
#   be forking rust-ipfs to make mesh_n configurable for small test environments.
#
# QUICK START (first time):
#   just quickstart     # Does everything: build, start, test, verify
#
# MANUAL SETUP (if you prefer step-by-step):
#   just build-all && just build-images  # Build everything (auto-detects platform)
#   just init-bootstrap                  # Discover peer IDs (REQUIRED after clean)
#   just test-pubsub-propagation         # Test message propagation
#
# NOTE: Builds auto-detect your platform (Linux/Mac/Windows) and use the
#       appropriate build method. Mac/Windows users need Earthly installed.
#
# DAILY WORKFLOW:
#   just start                    # Start nodes (preserves peer IDs)
#   just test-pubsub-propagation  # Test message propagation (with visualization)
#   just logs                     # Monitor activity
#   just stop                     # Stop nodes (keeps data)
#
# AFTER CLEANING VOLUMES:
#   just clean && just quickstart        # Handles init-bootstrap automatically
#   # OR manually: just clean â†’ just init-bootstrap â†’ just start
#
# CI/CD:
#   just start-ci && just test-ci && just clean
#
# NODE ENDPOINTS:
#   Node 1: http://localhost:5000 (IPFS: 4001, API: 5001) [172.20.0.10]
#   Node 2: http://localhost:5002 (IPFS: 4002, API: 5003) [172.20.0.11]
#   Node 3: http://localhost:5004 (IPFS: 4003, API: 5005) [172.20.0.12]
#   Node 4: http://localhost:5006 (IPFS: 4004, API: 5007) [172.20.0.13]
#   Node 5: http://localhost:5008 (IPFS: 4005, API: 5009) [172.20.0.14]
#   Node 6: http://localhost:5010 (IPFS: 4006, API: 5011) [172.20.0.15]
#
# PEER IDS:
#   Auto-generated on first run, persist in volumes, stable across restarts
#   'just clean' deletes volumes â†’ new IDs generated â†’ 'just init-bootstrap' required
#
# PREREQUISITES:
#   - Docker & Docker Compose
#   - Just (https://just.systems)
#   - Rust toolchain (builds use cargo directly, bypassing Earthly)
#
# TEST:
#   just test-pubsub-propagation         # Test message propagation
#   just test-bidirectional-sync         # Test bidirectional sync
#   just test-late-join-sync             # Test node late join with keepalive sync
#
# ==============================================================================

# Show available commands (default)
default:
    @just --list

# ==============================================================================
# HELPER FUNCTIONS & UTILITIES
# ==============================================================================
# Internal helpers (prefix: _) - implementation details for public commands,
# not shown in 'just --list', not meant for direct user invocation

# Check if all 6 nodes are running
_check-nodes-running:
    #!/usr/bin/env bash
    RUNNING=$(docker compose ps | grep -c "Up" || echo "0")
    if [ "$RUNNING" -eq 6 ]; then
        exit 0
    else
        echo "âŒ Only $RUNNING/6 nodes running" >&2
        exit 1
    fi

# Wait for node's HTTP endpoint to respond (checks /health or / with timeout)
# Retries with exponential backoff, exits 0 on success, 1 on failure
# Usage: just _wait-for-http [max_retries] [delay_seconds]
_wait-for-http retries="6" delay="5":
    #!/usr/bin/env bash
    MAX_RETRIES={{retries}}
    DELAY={{delay}}

    for ((i=1; i<=MAX_RETRIES; i++)); do
        if curl -s -f -m 5 http://localhost:5000/health >/dev/null 2>&1 || \
           curl -s -f -m 5 http://localhost:5000/ >/dev/null 2>&1; then
            exit 0
        fi

        if [ $i -lt $MAX_RETRIES ]; then
            echo "â³ Waiting for HTTP endpoint... (attempt $i/$MAX_RETRIES)" >&2
            sleep $DELAY
        fi
    done

    echo "âŒ HTTP endpoint not ready after $MAX_RETRIES attempts" >&2
    exit 1

# Helper: Post message to doc-sync with retries
# Usage: just _post-message "message text" [max_retries]
_post-message message retries="3":
    #!/usr/bin/env bash
    MAX_RETRIES={{retries}}
    MESSAGE="{{message}}"

    for ((i=1; i<=MAX_RETRIES; i++)); do
        RESPONSE=$(curl -s -X POST http://localhost:5000/api/doc-sync/post \
          -H "Host: athena.hermes.local" \
          -H "Content-Type: text/plain" \
          -d "$MESSAGE" 2>&1)

        SUCCESS=$(echo "$RESPONSE" | jq -r '.success' 2>/dev/null || echo "false")

        if [ "$SUCCESS" = "true" ]; then
            echo "$RESPONSE"
            exit 0
        fi

        if [ $i -lt $MAX_RETRIES ]; then
            echo "âš ï¸  Post failed, retrying... (attempt $((i+1))/$MAX_RETRIES)" >&2
            sleep 5
        fi
    done

    echo "âŒ Failed to post message after $MAX_RETRIES attempts" >&2
    echo "$RESPONSE" >&2
    exit 1

# Helper: Count nodes that received a specific message (by timestamp)
# Usage: just _count-received-nodes timestamp
_count-received-nodes timestamp:
    #!/usr/bin/env bash
    TIMESTAMP="{{timestamp}}"
    COUNT=0

    for NODE in {2..6}; do
        if docker compose logs "hermes-node$NODE" 2>&1 | \
           grep "RECEIVED PubSub message" | grep -q "$TIMESTAMP"; then
            COUNT=$((COUNT + 1))
        fi
    done

    echo $COUNT

# Helper: Get peer count for a specific node
_get-node-peer-count node:
    #!/usr/bin/env bash
    NODE={{node}}
    docker compose logs "hermes-node$NODE" 2>&1 | grep "peer connected" | wc -l

# Helper: Wait for mesh to form (checks for sufficient peer connections)
_wait-for-mesh min_connections="25" max_wait="60":
    #!/usr/bin/env bash
    MIN_CONNECTIONS={{min_connections}}
    MAX_WAIT={{max_wait}}

    echo "â³ Waiting for mesh formation..." >&2

    for ((i=0; i<MAX_WAIT; i+=5)); do
        CONNECTIONS=$(docker compose logs 2>&1 | grep "peer connected" | wc -l || echo "0")

        if [ "$CONNECTIONS" -ge "$MIN_CONNECTIONS" ]; then
            echo "âœ… Mesh formed ($CONNECTIONS connections)" >&2
            exit 0
        fi

        if [ $i -lt $((MAX_WAIT - 5)) ]; then
            echo "   Current: $CONNECTIONS connections (target: $MIN_CONNECTIONS)" >&2
            sleep 5
        fi
    done

    echo "âš ï¸  Mesh not fully formed after ${MAX_WAIT}s ($CONNECTIONS connections)" >&2
    exit 1

# Helper: Extract CID from curl response
_extract-cid response:
    #!/usr/bin/env bash
    echo "{{response}}" | jq -r '.cid' 2>/dev/null || echo "unknown"

# ==============================================================================
# QUICK START
# ==============================================================================

# Complete end-to-end setup and test (for first-time users)
# NOTE: Uses existing binaries if present. If you changed code, run 'just build-all' first.
quickstart:
    #!/usr/bin/env bash
    set -euo pipefail
    GREEN='\033[32m'; RED='\033[31m'; YELLOW='\033[33m'
    BLUE='\033[34m'; BOLD='\033[1m'; RESET='\033[0m'

    echo ""
    echo -e "${BOLD}${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
    echo -e "${BOLD}${BLUE}â•‘          Hermes P2P Testing - Quick Start                 â•‘${RESET}"
    echo -e "${BOLD}${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo ""

    # Step 1: Validate prerequisites
    echo -e "${BOLD}Step 1/7:${RESET} Validating prerequisites..."
    if ! just validate-prereqs; then
        echo ""
        echo -e "${RED}âŒ Quickstart failed: Prerequisites not met${RESET}"
        exit 1
    fi

    # Step 2: Check/build artifacts
    echo -e "${BOLD}Step 2/7:${RESET} Checking build artifacts..."
    if [ ! -f "../hermes/target/release/hermes" ] || [ ! -f "../hermes/apps/athena/athena.happ" ]; then
        echo -e "  ${YELLOW}Building Hermes and Athena...${RESET}"
        just build-all || {
            echo -e "${RED}âŒ Build failed${RESET}"
            exit 1
        }
    else
        echo -e "  ${GREEN}âœ… Artifacts already exist (using existing binaries)${RESET}"
        echo -e "  ${BLUE}â„¹ï¸  Note: If you changed code, run 'just build-all' first to rebuild${RESET}"
    fi

    # Step 3: Build Docker images
    echo ""
    echo -e "${BOLD}Step 3/7:${RESET} Building Docker images..."
    just build-images || {
        echo -e "${RED}âŒ Image build failed${RESET}"
        exit 1
    }

    # Step 4: Start nodes
    echo ""
    echo -e "${BOLD}Step 4/7:${RESET} Starting 6-node environment..."

    # Check if nodes already running
    if docker compose ps | grep -q "Up"; then
        echo -e "  ${YELLOW}âš ï¸  Nodes already running. Restarting...${RESET}"
        docker compose down
        sleep 2
    fi

    # Check if volumes exist (first time needs init-bootstrap)
    VOLUME_EXISTS=$(docker volume ls | grep p2p-testing_node1-data || echo "")
    if [ -z "$VOLUME_EXISTS" ]; then
        echo -e "  ${BLUE}â„¹ï¸  First time setup - initializing bootstrap...${RESET}"
        just init-bootstrap || {
            echo -e "${RED}âŒ Bootstrap initialization failed${RESET}"
            exit 1
        }
    else
        docker compose up -d || {
            echo -e "${RED}âŒ Failed to start nodes${RESET}"
            exit 1
        }
    fi

    # Step 5: Wait for mesh formation
    echo ""
    echo -e "${BOLD}Step 5/7:${RESET} Waiting for mesh formation..."
    for i in {30..1}; do
        echo -ne "  â³ ${i}s remaining...\r"
        sleep 1
    done
    echo -e "  ${GREEN}âœ… Wait complete${RESET}                    "

    # Step 6: Health check
    echo ""
    echo -e "${BOLD}Step 6/7:${RESET} Running health check..."
    if just test-pubsub-propagation; then
        echo ""
    else
        echo ""
        echo -e "${YELLOW}âš ï¸  Health check found issues, but continuing...${RESET}"
        echo ""
    fi

    # Step 7: Test propagation
    echo -e "${BOLD}Step 7/7:${RESET} Testing PubSub propagation..."
    echo ""
    if just test-pubsub-propagation; then
        echo ""
        echo -e "${BOLD}${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
        echo -e "${BOLD}${GREEN}â•‘                  ğŸ‰ SUCCESS! ğŸ‰                            â•‘${RESET}"
        echo -e "${BOLD}${GREEN}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${RESET}"
        echo -e "${BOLD}${GREEN}â•‘  P2P mesh is operational and message propagation works!   â•‘${RESET}"
        echo -e "${BOLD}${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
        echo ""
        echo -e "${BOLD}Node Endpoints:${RESET}"
        echo "  â€¢ Node 1: http://localhost:5000"
        echo "  â€¢ Node 2: http://localhost:5002"
        echo "  â€¢ Node 3: http://localhost:5004"
        echo "  â€¢ Node 4: http://localhost:5006"
        echo "  â€¢ Node 5: http://localhost:5008"
        echo "  â€¢ Node 6: http://localhost:5010"
        echo ""
        echo -e "${BOLD}Next Steps:${RESET}"
        echo -e "  â€¢ View logs: ${BLUE}just logs${RESET}"
        echo -e "  â€¢ Check status: ${BLUE}just test-pubsub-propagation${RESET}"
        echo -e "  â€¢ Test again: ${BLUE}just test-pubsub-propagation${RESET}"
        echo -e "  â€¢ Stop nodes: ${BLUE}just stop${RESET}"
        echo ""
    else
        echo ""
        echo -e "${RED}âŒ Propagation test failed${RESET}"
        echo ""
        echo "Troubleshooting:"
        echo -e "  â€¢ Check logs: ${BLUE}just logs${RESET}"
        echo -e "  â€¢ Run diagnostics: ${BLUE}just troubleshoot${RESET}"
        echo -e "  â€¢ Try restarting: ${BLUE}just restart${RESET}"
        exit 1
    fi

# ==============================================================================
# BUILD COMMANDS
# ==============================================================================

# Build Hermes binary (auto-detects platform and uses appropriate method)
build:
    #!/usr/bin/env bash
    set -euo pipefail
    cd ..

    # Auto-detect platform
    OS=$(uname -s)
    if [ "$OS" = "Linux" ]; then
        echo "ğŸ”¨ Building Hermes (fast local build for Linux)..."
        just get-local-hermes-fast
    else
        echo "ğŸ”¨ Building Hermes (cross-platform with Earthly for $OS)..."
        echo "   â„¹ï¸  Using containerized build to produce Linux binaries"
        just get-local-hermes
    fi

# Build Hermes + Athena WASM modules (auto-detects platform)
build-all:
    #!/usr/bin/env bash
    set -euo pipefail
    cd ..

    # Auto-detect platform
    OS=$(uname -s)
    if [ "$OS" = "Linux" ]; then
        echo "ğŸš€ Building Hermes and Athena (fast local build)..."
        just get-local-hermes-fast
        just get-local-athena-fast
    else
        echo "ğŸš€ Building Hermes and Athena (cross-platform with Earthly for $OS)..."
        echo "   â„¹ï¸  Using containerized build to produce Linux binaries"
        echo "   â±ï¸  This may take longer than local builds but works on all platforms"
        just get-local-hermes
        just get-local-athena
    fi

    echo "ğŸ“¦ Packaging modules..."
    cd hermes/apps/athena
    for module_path in modules/*/lib/manifest_module.json; do
        if [ -f "$module_path" ]; then
            echo "  ğŸ“¦ Packaging $(dirname $(dirname $module_path))..."
            ../../../target/release/hermes module package "$module_path" &
        fi
    done
    wait

    echo "ğŸ“¦ Packaging application..."
    ../../../target/release/hermes app package manifest_app.json
    echo "âœ… Build complete!"

# Build Docker images from built artifacts
build-images:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "ğŸ³ Building Docker images..."
    docker compose build

# Build everything (CI mode: no prompts, always clean build)
build-ci: build-all build-images

# ==============================================================================
# VALIDATION & DIAGNOSTICS
# ==============================================================================

# Validate all prerequisites before running tests
validate-prereqs:
    #!/usr/bin/env bash
    set -euo pipefail
    GREEN='\033[32m'; RED='\033[31m'; YELLOW='\033[33m'
    BLUE='\033[34m'; BOLD='\033[1m'; RESET='\033[0m'

    echo -e "${BLUE}ğŸ” Validating Prerequisites${RESET}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    ERRORS=0

    # Check Docker daemon
    echo -n "  Docker daemon... "
    if docker info &>/dev/null; then
        echo -e "${GREEN}âœ…${RESET}"
    else
        echo -e "${RED}âŒ${RESET}"
        echo -e "    ${RED}Docker is not running${RESET}"
        echo -e "    ${YELLOW}â†’ Start Docker: sudo systemctl start docker${RESET}"
        ERRORS=$((ERRORS + 1))
    fi

    # Check Docker Compose
    echo -n "  Docker Compose... "
    if command -v docker &>/dev/null && docker compose version &>/dev/null; then
        echo -e "${GREEN}âœ…${RESET}"
    else
        echo -e "${RED}âŒ${RESET}"
        echo -e "    ${RED}Docker Compose not found${RESET}"
        echo -e "    ${YELLOW}â†’ Install: https://docs.docker.com/compose/install/${RESET}"
        ERRORS=$((ERRORS + 1))
    fi

    # Check Hermes binary (informational - will be built by quickstart if needed)
    echo -n "  Hermes binary... "
    if [ -f "../hermes/target/release/hermes" ]; then
        echo -e "${GREEN}âœ…${RESET}"
    else
        echo -e "${YELLOW}âš ï¸  Not found (will be built)${RESET}"
    fi

    # Check Athena app (informational - will be built by quickstart if needed)
    echo -n "  Athena app... "
    if [ -f "../hermes/apps/athena/athena.happ" ]; then
        echo -e "${GREEN}âœ…${RESET}"
    else
        echo -e "${YELLOW}âš ï¸  Not found (will be built)${RESET}"
    fi

    # Check disk space
    echo -n "  Disk space... "
    AVAILABLE=$(df -BG . | tail -1 | awk '{print $4}' | sed 's/G//')
    if [ "$AVAILABLE" -gt 5 ]; then
        echo -e "${GREEN}âœ… ${AVAILABLE}GB available${RESET}"
    else
        echo -e "${YELLOW}âš ï¸  Only ${AVAILABLE}GB available${RESET}"
        echo -e "    ${YELLOW}â†’ Consider freeing up space: docker system prune${RESET}"
    fi

    # Check ports (only if Docker is running)
    if docker info &>/dev/null; then
        echo -n "  Port availability... "
        PORTS_IN_USE=()
        for PORT in 5000 5002 5004 5006 5008 5010 4001 4002 4003 4004 4005 4006; do
            if ss -tuln 2>/dev/null | grep -q ":$PORT " || netstat -tuln 2>/dev/null | grep -q ":$PORT "; then
                # Check if it's our own containers
                if ! docker compose ps 2>/dev/null | grep -q "Up.*:$PORT"; then
                    PORTS_IN_USE+=($PORT)
                fi
            fi
        done

        if [ ${#PORTS_IN_USE[@]} -eq 0 ]; then
            echo -e "${GREEN}âœ…${RESET}"
        else
            echo -e "${YELLOW}âš ï¸  Ports in use: ${PORTS_IN_USE[*]}${RESET}"
            echo -e "    ${YELLOW}â†’ Check what's using them: lsof -i :PORT${RESET}"
            echo -e "    ${YELLOW}â†’ Or stop our nodes: just stop${RESET}"
        fi
    fi

    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    if [ $ERRORS -eq 0 ]; then
        echo -e "${GREEN}âœ… All prerequisites satisfied!${RESET}"
        echo ""
        exit 0
    else
        echo -e "${RED}âŒ Found $ERRORS issue(s). Please fix them before continuing.${RESET}"
        echo ""
        exit 1
    fi

# Comprehensive troubleshooting diagnostics
troubleshoot:
    #!/usr/bin/env bash
    set -euo pipefail
    GREEN='\033[32m'; RED='\033[31m'; YELLOW='\033[33m'
    BLUE='\033[34m'; RESET='\033[0m'

    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    REPORT_FILE="p2p-troubleshoot-$TIMESTAMP.txt"

    echo -e "${BLUE}ğŸ”§ Running Troubleshooting Diagnostics${RESET}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Generating report: $REPORT_FILE"
    echo ""

    # Start report
    {
        echo "Hermes P2P Testing - Troubleshooting Report"
        echo "Generated: $(date)"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
    } > "$REPORT_FILE"

    # 1. Prerequisites check
    echo -e "${BLUE}1. Checking prerequisites...${RESET}"
    {
        echo "1. PREREQUISITES"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo ""
    } >> "$REPORT_FILE"
    just validate-prereqs 2>&1 | tee -a "$REPORT_FILE" || true
    echo "" | tee -a "$REPORT_FILE"

    # 2. Docker status
    echo -e "${BLUE}2. Checking Docker status...${RESET}"
    {
        echo "2. DOCKER STATUS"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        docker compose ps 2>&1 || echo "Failed to get container status"
        echo ""
    } >> "$REPORT_FILE"

    # 3. Docker network
    echo -e "${BLUE}3. Checking Docker network...${RESET}"
    {
        echo "3. DOCKER NETWORK"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        docker network ls | grep hermes-p2p || echo "Network not found"
        echo ""
        docker network inspect hermes-p2p 2>&1 || echo "Failed to inspect network"
        echo ""
    } >> "$REPORT_FILE"

    # 4. Volume status
    echo -e "${BLUE}4. Checking volumes...${RESET}"
    {
        echo "4. DOCKER VOLUMES"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        docker volume ls | grep p2p-testing || echo "No volumes found"
        echo ""
    } >> "$REPORT_FILE"

    # 5. Recent logs from each node
    echo -e "${BLUE}5. Collecting logs from all nodes...${RESET}"
    {
        echo "5. NODE LOGS (Last 50 lines per node)"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo ""
    } >> "$REPORT_FILE"

    for i in {1..6}; do
        {
            echo "Node $i Logs:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            docker compose logs --tail=50 hermes-node$i 2>&1 || echo "Failed to get logs for node$i"
            echo ""
            echo ""
        } >> "$REPORT_FILE"
    done

    # 6. Peer connections summary
    echo -e "${BLUE}6. Analyzing peer connections...${RESET}"
    {
        echo "6. PEER CONNECTIONS"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo "Total 'New peer connected' messages:"
        docker compose logs 2>&1 | grep "New peer connected" | wc -l
        echo ""
        echo "Recent peer connections:"
        docker compose logs 2>&1 | grep "New peer connected" | tail -10
        echo ""
    } >> "$REPORT_FILE"

    # 7. Error analysis
    echo -e "${BLUE}7. Analyzing errors...${RESET}"
    {
        echo "7. ERROR ANALYSIS"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo "Recent errors (last 20):"
        docker compose logs 2>&1 | grep -iE "(error|panic|failed)" | tail -20 || echo "No errors found"
        echo ""
    } >> "$REPORT_FILE"

    # 8. Port check
    echo -e "${BLUE}8. Checking ports...${RESET}"
    {
        echo "8. PORT STATUS"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        for PORT in 5000 5002 5004 5006 5008 5010; do
            if ss -tuln 2>/dev/null | grep -q ":$PORT " || netstat -tuln 2>/dev/null | grep -q ":$PORT "; then
                echo "Port $PORT: IN USE"
            else
                echo "Port $PORT: AVAILABLE"
            fi
        done
        echo ""
    } >> "$REPORT_FILE"

    # 9. Common issues check
    {
        echo "9. COMMON ISSUES CHECK"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo ""

        # Check for peer ID mismatches
        PEER_ID_ERRORS=$(docker compose logs 2>&1 | grep -i "wrong peer id" | wc -l)
        if [ "$PEER_ID_ERRORS" -gt 0 ]; then
            echo "âš ï¸  Peer ID mismatches detected ($PEER_ID_ERRORS occurrences)"
            echo "   â†’ Solution: just init-bootstrap"
            echo ""
        fi

        # Check for port conflicts
        if ss -tuln 2>/dev/null | grep -qE ":(5000|5002|5004)" || netstat -tuln 2>/dev/null | grep -qE ":(5000|5002|5004)"; then
            echo "âš ï¸  Port conflicts detected"
            echo "   â†’ Solution: just stop"
            echo ""
        fi

        # Check if volumes exist but nodes not running
        VOLUME_COUNT=$(docker volume ls | grep -c p2p-testing || echo "0")
        RUNNING_COUNT=$(docker compose ps | grep -c "Up" || echo "0")
        if [ "$VOLUME_COUNT" -gt 0 ] && [ "$RUNNING_COUNT" -eq 0 ]; then
            echo "â„¹ï¸  Volumes exist but nodes not running"
            echo "   â†’ Solution: just start"
            echo ""
        fi

        echo "End of diagnostics"
    } >> "$REPORT_FILE"

    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo -e "${GREEN}âœ… Troubleshooting report generated: $REPORT_FILE${RESET}"
    echo ""
    echo "Review the report for detailed diagnostics."
    echo ""
    echo "Common solutions:"
    echo -e "  â€¢ Peer ID issues: ${BLUE}just init-bootstrap${RESET}"
    echo -e "  â€¢ Port conflicts: ${BLUE}just stop${RESET}"
    echo -e "  â€¢ Full reset: ${BLUE}just clean && just start${RESET}"
    echo -e "  â€¢ View logs: ${BLUE}just logs${RESET}"
    echo ""

# ==============================================================================
# NODE MANAGEMENT
# ==============================================================================

# Start 3-node test environment (interactive: prompts to rebuild if artifacts exist)
start:
    #!/usr/bin/env bash
    set -euo pipefail

    # Check if artifacts exist
    if [ -f "../hermes/target/release/hermes" ] && [ -f "../hermes/apps/athena/athena.happ" ]; then
        echo "ğŸ“¦ Found existing build artifacts"
        read -p "   Rebuild? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            just build-all
        fi
    else
        echo "ğŸ—ï¸  No artifacts found, building..."
        just build-all
    fi

    just build-images
    echo ""
    echo "ğŸŒ Starting nodes..."
    docker compose up -d

    echo ""
    echo "â³ Waiting for nodes to initialize..."
    sleep 5

    echo ""
    just status

# Start nodes (CI mode: no prompts, always rebuilds from clean state)
start-ci:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "ğŸš€ Starting P2P test environment (CI mode)..."

    # Ensure clean state
    if docker compose ps | grep -q "Up"; then
        echo "ğŸ§¹ Cleaning existing environment..."
        docker compose down -v
    fi

    just build-ci
    just init-bootstrap
    echo ""
    just status

# Stop nodes (preserves data in Docker volumes)
stop:
    @echo "ğŸ›‘ Stopping nodes..."
    @docker compose down
    @echo "âœ… Nodes stopped (data preserved in volumes)"
    @echo "ğŸ’¡ To remove data: just clean"

# Stop nodes and remove all data (volumes deleted)
# WARNING: After clean, you must run 'just init-bootstrap' to rediscover peer IDs
clean:
    @echo "ğŸ§¹ Stopping nodes and cleaning data..."
    @docker compose down -v
    @echo "âœ… All nodes stopped and data cleaned"
    @echo ""
    @echo "âš ï¸  IMPORTANT: Peer identities were deleted!"
    @echo "   Run 'just init-bootstrap' before 'just start' to rediscover peer IDs"

# ==============================================================================
# BOOTSTRAP PEER DISCOVERY
# ==============================================================================
#
# TL;DR: After 'just clean', run 'just init-bootstrap' to sync peer IDs in
#        docker-compose.yml. Otherwise nodes can't find each other and mesh fails.
#
# BACKGROUND:
#   Hermes persists IPFS keypairs in Docker volumes
#   - Keypair location: /home/hermes/.hermes/ipfs/keypair (inside volume)
#   - Peer IDs remain stable across stop/restart (volumes preserved)
#   - This works great for normal operations
#
# THE PROBLEM:
#   docker-compose.yml has HARDCODED bootstrap peer IDs in IPFS_BOOTSTRAP_PEERS
#   - Each node's env var contains specific peer IDs (e.g., /ip4/172.20.0.11/tcp/4001/p2p/12D3KooW...)
#   - When 'just clean' deletes volumes â†’ new keypairs generated â†’ new peer IDs
#   - Hardcoded IDs in docker-compose.yml become stale â†’ mesh formation fails
#   - Errors: "wrong peer id", "Unexpected peer ID", no PubSub propagation
#
# THE SOLUTION:
#   init-bootstrap command (dynamic discovery)
#   1. Start bootstrap nodes (1-3) to generate/load keypairs
#   2. Extract actual peer IDs from logs
#   3. Update docker-compose.yml with discovered IDs (creates backup)
#   4. Restart all nodes with correct bootstrap configuration
#
# WHEN TO RUN:
#   âœ… After 'just clean' (volumes deleted â†’ new keypairs â†’ new peer IDs)
#   âœ… First time setup (no volumes exist yet)
#   âŒ NOT after 'just stop/restart' (volumes preserved â†’ peer IDs unchanged)
#
# PRODUCTION DEPLOYMENT ALTERNATIVE:
#   For production, use pre-generated stable bootstrap keypairs instead:
#   - Generate keypairs: p2p-testing/identities/bootstrap-node{1-3}.keypair
#   - Add to Dockerfile: COPY identities/*.keypair /home/hermes/.hermes/ipfs/
#   - Hardcode well-known peer IDs: /dns4/bootstrap1.hermes.io/tcp/4001/p2p/12D3KooW...
#   - Benefit: New nodes can connect immediately, no init-bootstrap needed
#   - Reason: GossipSub requires stable entry points for mesh formation
#
# ==============================================================================

# Sync docker-compose.yml bootstrap peer IDs with actual keypairs
# Required after 'just clean' or first setup
init-bootstrap:
    #!/usr/bin/env bash
    set -euo pipefail

    echo "ğŸ” Bootstrap Peer Discovery"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "Syncing docker-compose.yml bootstrap config with actual peer IDs"
    echo "(Needed after 'just clean' or first setup)"
    echo ""

    # Check if nodes are running
    if docker compose ps | grep -q "Up"; then
        echo "âš ï¸  Nodes are running. Stopping them first..."
        docker compose down
        sleep 2
    fi

    # Start bootstrap nodes (1-3) without full mesh bootstrap config
    echo "ğŸ“¡ Phase 1: Starting bootstrap nodes (1-3) without inter-node bootstrap..."
    echo "   (They will generate or load their peer identities)"

    # Temporarily disable bootstrap for initial startup
    IPFS_BOOTSTRAP_PEERS="" docker compose up -d hermes-node1 hermes-node2 hermes-node3

    echo "â³ Waiting 30 seconds for nodes to initialize and generate peer IDs..."
    sleep 30

    # Extract peer IDs from running nodes
    echo ""
    echo "ğŸ” Phase 2: Discovering peer IDs from running nodes..."

    PEER_ID_1=$(docker compose logs hermes-node1 2>&1 | grep -E '(Generated new keypair|Loaded keypair) with Peer ID:' | grep -oP '12D3[^ "]+' | head -1)
    PEER_ID_2=$(docker compose logs hermes-node2 2>&1 | grep -E '(Generated new keypair|Loaded keypair) with Peer ID:' | grep -oP '12D3[^ "]+' | head -1)
    PEER_ID_3=$(docker compose logs hermes-node3 2>&1 | grep -E '(Generated new keypair|Loaded keypair) with Peer ID:' | grep -oP '12D3[^ "]+' | head -1)

    if [ -z "$PEER_ID_1" ] || [ -z "$PEER_ID_2" ] || [ -z "$PEER_ID_3" ]; then
        echo "âŒ Failed to discover peer IDs from logs"
        echo "   Node 1: ${PEER_ID_1:-NOT FOUND}"
        echo "   Node 2: ${PEER_ID_2:-NOT FOUND}"
        echo "   Node 3: ${PEER_ID_3:-NOT FOUND}"
        echo ""
        echo "ğŸ’¡ Check logs: docker compose logs"
        exit 1
    fi

    echo "   âœ… Node 1 (172.20.0.10): $PEER_ID_1"
    echo "   âœ… Node 2 (172.20.0.11): $PEER_ID_2"
    echo "   âœ… Node 3 (172.20.0.12): $PEER_ID_3"

    # Update docker-compose.yml with discovered peer IDs
    echo ""
    echo "ğŸ“ Phase 3: Updating docker-compose.yml with discovered peer IDs..."

    # Create backup
    cp docker-compose.yml docker-compose.yml.backup

    # Update bootstrap peers using sed (portable across Linux/Mac)
    # Node 1: bootstrap from nodes 2,3
    sed -i.tmp "s|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.11/tcp/4001/p2p/[^,]*,/ip4/172.20.0.12/tcp/4001/p2p/[^\"]*|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.11/tcp/4001/p2p/$PEER_ID_2,/ip4/172.20.0.12/tcp/4001/p2p/$PEER_ID_3|g" docker-compose.yml

    # Node 2: bootstrap from nodes 1,3
    sed -i.tmp "s|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.10/tcp/4001/p2p/[^,]*,/ip4/172.20.0.12/tcp/4001/p2p/[^\"]*|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.10/tcp/4001/p2p/$PEER_ID_1,/ip4/172.20.0.12/tcp/4001/p2p/$PEER_ID_3|g" docker-compose.yml

    # Node 3: bootstrap from nodes 1,2 (only 2 peers, not 3)
    sed -i.tmp "s|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.10/tcp/4001/p2p/[^,]*,/ip4/172.20.0.11/tcp/4001/p2p/[^\"]*|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.10/tcp/4001/p2p/$PEER_ID_1,/ip4/172.20.0.11/tcp/4001/p2p/$PEER_ID_2|g" docker-compose.yml

    # Nodes 4-6: bootstrap from nodes 1,2,3 (3 peers)
    sed -i.tmp "s|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.10/tcp/4001/p2p/[^,]*,/ip4/172.20.0.11/tcp/4001/p2p/[^,]*,/ip4/172.20.0.12/tcp/4001/p2p/[^\"]*|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.10/tcp/4001/p2p/$PEER_ID_1,/ip4/172.20.0.11/tcp/4001/p2p/$PEER_ID_2,/ip4/172.20.0.12/tcp/4001/p2p/$PEER_ID_3|g" docker-compose.yml    
    rm -f docker-compose.yml.tmp

    echo "   âœ… docker-compose.yml updated (backup saved as docker-compose.yml.backup)"

    # Restart all nodes with new bootstrap config
    echo ""
    echo "ğŸ”„ Phase 4: Restarting all nodes with correct bootstrap configuration..."
    docker compose down
    sleep 2
    docker compose up -d

    echo "â³ Waiting for mesh to form..."
    sleep 15

    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "âœ… Bootstrap configuration synced!"
    echo ""
    echo "ğŸ“‹ Current Peer IDs (now in docker-compose.yml):"
    echo "   Node 1: $PEER_ID_1"
    echo "   Node 2: $PEER_ID_2"
    echo "   Node 3: $PEER_ID_3"
    echo ""
    echo "ğŸ’¡ Keypairs persist in Docker volumes"
    echo "   - Normal stop/restart: No action needed, peer IDs stay the same"
    echo "   - After 'just clean': Must run 'just init-bootstrap' again"
    echo ""
    echo "ğŸ”® Future: Pre-generate test keypairs to skip this step entirely"
    echo "   See FUTURE IMPROVEMENT in justfile comments"
    echo ""

    just status

# Restart nodes (stop + start, preserves data)
restart: stop start

# Full reset (clean + start fresh with new volumes)
reset: clean start

# ==============================================================================
# MONITORING
# ==============================================================================

# Show node status and endpoints
status:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "ğŸ“Š Node Status:"
    docker compose ps
    echo ""
    echo "ğŸ“¡ Endpoints:"
    echo "   Node 1: http://localhost:5000 (IPFS: 4001, API: 5001) [172.20.0.10]"
    echo "   Node 2: http://localhost:5002 (IPFS: 4002, API: 5003) [172.20.0.11]"
    echo "   Node 3: http://localhost:5004 (IPFS: 4003, API: 5005) [172.20.0.12]"
    echo "   Node 4: http://localhost:5006 (IPFS: 4004, API: 5007) [172.20.0.13]"
    echo "   Node 5: http://localhost:5008 (IPFS: 4005, API: 5009) [172.20.0.14]"
    echo "   Node 6: http://localhost:5010 (IPFS: 4006, API: 5011) [172.20.0.15]"

# Follow logs from all nodes
logs:
    @docker compose logs -f

# Follow logs from specific node (1, 2, or 3)
logs-node node:
    @docker compose logs -f hermes-node{{node}}

# Check P2P connectivity (bootstrap, gossipsub, listening addresses)
check-connectivity:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "ğŸ” Checking P2P connectivity..."
    echo ""

    echo "ğŸ“‹ Bootstrap status:"
    docker compose logs 2>&1 | grep "All bootstrap peers connected" | tail -3 || echo "   âš ï¸  No successful bootstrap connections logged yet"

    echo ""
    echo "ğŸ”— Gossipsub peer connections:"
    docker compose logs 2>&1 | grep "New peer connected" | tail -10 || echo "   âš ï¸  No peer connections found"

    echo ""
    echo "ğŸ‘‚ Listening addresses:"
    docker compose logs 2>&1 | grep "listening on 0.0.0.0:4001" | head -3 || echo "   âš ï¸  Nodes may not be listening on port 4001"

# ==============================================================================
# TESTING
# ==============================================================================

# Run integration tests on all nodes (requires Athena WASM modules)
test: test-node1 test-node2 test-node3 test-node4 test-node5 test-node6
    @echo ""
    @echo "âœ… All nodes tested!"

# Run integration tests on node 1
test-node1:
    @echo "ğŸ§ª Testing Node 1..."
    @docker exec hermes-node1 /usr/local/bin/hermes test || echo "   âš ï¸  Tests not available (Athena not loaded)"

# Run integration tests on node 2
test-node2:
    @echo "ğŸ§ª Testing Node 2..."
    @docker exec hermes-node2 /usr/local/bin/hermes test || echo "   âš ï¸  Tests not available (Athena not loaded)"

# Run integration tests on node 3
test-node3:
    @echo "ğŸ§ª Testing Node 3..."
    @docker exec hermes-node3 /usr/local/bin/hermes test || echo "   âš ï¸  Tests not available (Athena not loaded)"

# Run integration tests on node 4
test-node4:
    @echo "ğŸ§ª Testing Node 4..."
    @docker exec hermes-node4 /usr/local/bin/hermes test || echo "   âš ï¸  Tests not available (Athena not loaded)"

# Run integration tests on node 5
test-node5:
    @echo "ğŸ§ª Testing Node 5..."
    @docker exec hermes-node5 /usr/local/bin/hermes test || echo "   âš ï¸  Tests not available (Athena not loaded)"

# Run integration tests on node 6
test-node6:
    @echo "ğŸ§ª Testing Node 6..."
    @docker exec hermes-node6 /usr/local/bin/hermes test || echo "   âš ï¸  Tests not available (Athena not loaded)"

# Test PubSub message propagation (minimal output, for CI)
test-pubsub:
    #!/usr/bin/env bash
    set -euo pipefail

    # Check if nodes are running using helper
    just _check-nodes-running || exit 1

    # Wait for nodes to fully initialize (HTTP gateway, Athena app, IPFS)
    echo "â³ Waiting for nodes to initialize..."
    sleep 30

    # Post test message using helper (handles retries)
    TIMESTAMP=$(date +%s)
    TEST_MESSAGE="PubSub Test - Timestamp: $TIMESTAMP"

    echo "ğŸ“¤ Publishing message..."
    RESPONSE=$(just _post-message "$TEST_MESSAGE" 3)
    if [ $? -ne 0 ]; then
        echo "âŒ Failed to post message"
        exit 1
    fi

    echo "âœ… Message published"

    # Wait for propagation
    sleep 3

    # Check reception using helper
    echo "â³ Checking message reception..."
    RECEIVED_COUNT=$(just _count-received-nodes "$TIMESTAMP")

    # Evaluate results
    if [ "$RECEIVED_COUNT" -ge 4 ]; then
        echo "âœ… PubSub propagation successful ($RECEIVED_COUNT/5 nodes received)"
        exit 0
    else
        echo "âŒ PubSub propagation failed (only $RECEIVED_COUNT/5 nodes received)"
        exit 1
    fi

# Test PubSub message propagation with full visualization (for interactive use)
test-pubsub-propagation:
    @just _test-pubsub-explain
    @just _test-pubsub-execute
    @just _test-pubsub-visualize

# Internal: Show explanation and topology
_test-pubsub-explain:
    #!/usr/bin/env bash
    set -euo pipefail
    GREEN='\033[32m'; YELLOW='\033[33m'; BLUE='\033[34m'
    BOLD='\033[1m'; RESET='\033[0m'

    echo ""
    echo -e "${BOLD}${BLUE}ğŸ§ª Testing PubSub Message Propagation${RESET}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo ""
    echo -e "${BOLD}What's happening:${RESET}"
    echo -e "  â€¢ All 6 nodes are subscribed to the ${BLUE}doc-sync${RESET} PubSub topic"
    echo -e "  â€¢ Node 1 will publish a message to this topic"
    echo -e "  â€¢ ${BOLD}Gossipsub${RESET} protocol propagates the message through the mesh"
    echo -e "  â€¢ Each node receives and validates the message"
    echo ""
    echo -e "${BOLD}Why Node 1 is the Publisher:${RESET}"
    echo ""
    echo -e "  ${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${RESET}"
    echo -e "  ${BLUE}â”‚${RESET}  Our test sends HTTP POST to Node 1's endpoint:  ${BLUE}â”‚${RESET}"
    echo -e "  ${BLUE}â”‚${RESET}  ${BOLD}http://localhost:5000/api/doc-sync/post${RESET}        ${BLUE}â”‚${RESET}"
    echo -e "  ${BLUE}â”‚${RESET}                                                   ${BLUE}â”‚${RESET}"
    echo -e "  ${BLUE}â”‚${RESET}  â†’ Node 1 receives the message via HTTP          ${BLUE}â”‚${RESET}"
    echo -e "  ${BLUE}â”‚${RESET}  â†’ Node 1 publishes to PubSub topic 'doc-sync'   ${BLUE}â”‚${RESET}"
    echo -e "  ${BLUE}â”‚${RESET}  â†’ Gossipsub propagates to all subscribers       ${BLUE}â”‚${RESET}"
    echo -e "  ${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${RESET}"
    echo ""
    echo -e "${BOLD}P2P Mesh Network (Full Connectivity):${RESET}"
    echo ""
    echo "              HTTP POST â¬‡ï¸"
    echo "              (localhost:5000)"
    echo "                    â”‚"
    echo "         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo "         â”‚      Node 1         â”‚ ğŸ“¤ Publisher"
    echo "         â”‚  (Receives HTTP)    â”‚"
    echo "         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
    echo "                    â”‚ Gossipsub"
    echo "            â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”"
    echo "            â”‚       â”‚       â”‚"
    echo "        â”Œâ”€â”€â”€â–¼â”€â”€â”€â” â”Œâ”€â–¼â”€â”€â”€â” â”Œâ”€â–¼â”€â”€â”€â”"
    echo "        â”‚Node 2 â”‚ â”‚Node3â”‚ â”‚Node4â”‚ ğŸ“¥ Subscribers"
    echo "        â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜"
    echo "            â”‚       â”‚       â”‚"
    echo "            â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”˜"
    echo "                    â”‚"
    echo "            â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”"
    echo "            â”‚               â”‚"
    echo "        â”Œâ”€â”€â”€â–¼â”€â”€â”€â”       â”Œâ”€â”€â”€â–¼â”€â”€â”€â”"
    echo "        â”‚Node 5 â”‚       â”‚Node 6 â”‚ ğŸ“¥ Subscribers"
    echo "        â””â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”˜"
    echo ""
    echo -e "  ${BLUE}â„¹ï¸  Each node is connected to all others (30 total connections)${RESET}"
    echo -e "  ${BLUE}â„¹ï¸  Any node can be a publisher - depends on which receives HTTP POST${RESET}"
    echo ""
    echo -e "${BOLD}Why Node 1 is the Publisher:${RESET}"
    echo ""
    echo -e "  The test sends an HTTP POST to Node 1's endpoint:"
    echo ""
    echo -e "  ${BLUE}curl -X POST http://localhost:5000/api/doc-sync/post${RESET} \\"
    echo -e "       ${BLUE}-H \"Host: athena.hermes.local\"${RESET} \\"
    echo -e "       ${BLUE}-H \"Content-Type: text/plain\"${RESET} \\"
    echo -e "       ${BLUE}-d \"PubSub Test - Timestamp: <timestamp>\"${RESET}"
    echo ""
    echo -e "  ${GREEN}â†’${RESET} Node 1 receives the HTTP request"
    echo -e "  ${GREEN}â†’${RESET} Node 1's Athena app publishes to the PubSub topic"
    echo -e "  ${GREEN}â†’${RESET} Gossipsub propagates the message to all subscribed nodes"
    echo ""
    echo -e "  ${YELLOW}Note:${RESET} Any node could be the publisher if you POST to its endpoint"
    echo -e "        (e.g., POST to localhost:5002 would make Node 2 the publisher)"
    echo ""

# Internal: Execute core test and store results
_test-pubsub-execute:
    #!/usr/bin/env bash
    set -euo pipefail
    GREEN='\033[32m'; RED='\033[31m'; YELLOW='\033[33m'
    BLUE='\033[34m'; BOLD='\033[1m'; RESET='\033[0m'

    # Check nodes using helper
    if ! just _check-nodes-running >/dev/null 2>&1; then
        RUNNING=$(docker compose ps | grep -c "Up" || echo "0")
        echo -e "${RED}âŒ Only $RUNNING/6 nodes running${RESET}"
        echo ""
        echo -e "  ${BLUE}â†’ Start nodes: just start${RESET}"
        exit 1
    fi
    echo -e "${GREEN}âœ“${RESET} All 6 nodes running"
    echo ""

    # Wait for endpoints (HTTP gateway requires Host header)
    echo -e "${BLUE}Waiting for HTTP endpoints to initialize...${RESET}"
    sleep 5
    echo -n "  Checking Node 1 HTTP endpoint... "
    if curl -s -f -m 5 -H "Host: athena.hermes.local" http://localhost:5000/ >/dev/null 2>&1; then
        echo -e "${GREEN}âœ“${RESET}"
    else
        echo -e "${YELLOW}âš ï¸  Not responding yet, waiting...${RESET}"
        sleep 10
    fi
    echo ""

    # Publish message
    echo -e "${BOLD}Step 1/3:${RESET} Publishing message to PubSub topic..."
    TIMESTAMP=$(date +%s)
    TEST_MESSAGE="PubSub Test - Timestamp: $TIMESTAMP"
    echo ""
    echo -e "  ${BLUE}â„¹ï¸  Node 1 publishes to topic: ${BOLD}doc-sync${RESET}"
    echo -e "  ${BOLD}ğŸ“¨ Message:${RESET} ${BLUE}\"$TEST_MESSAGE\"${RESET}"
    echo ""

    RESPONSE=$(curl -s -X POST http://localhost:5000/api/doc-sync/post \
      -H "Host: athena.hermes.local" \
      -H "Content-Type: text/plain" \
      -d "$TEST_MESSAGE" 2>&1)

    CID=$(echo "$RESPONSE" | jq -r '.cid' 2>/dev/null || echo "unknown")
    SUCCESS=$(echo "$RESPONSE" | jq -r '.success' 2>/dev/null || echo "false")

    if [ "$SUCCESS" != "true" ]; then
        echo -e "${RED}âŒ Failed to post message!${RESET}"
        echo "$RESPONSE" | head -20
        echo ""
        echo -e "  ${BLUE}â†’ Full diagnostics: just troubleshoot${RESET}"
        exit 1
    fi

    echo -e "${GREEN}âœ“${RESET} Message published successfully"
    echo -e "  ${BOLD}ğŸ”‘ CID:${RESET} ${BLUE}$CID${RESET}"
    echo -e "  ${BLUE}â„¹ï¸  CID is the IPFS content hash (cryptographic fingerprint)${RESET}"
    echo ""

    # Wait for propagation
    echo -e "${BOLD}Step 2/3:${RESET} Waiting for P2P propagation..."
    echo -e "  ${BLUE}â„¹ï¸  Gossipsub forwards message through peer connections${RESET}"
    for i in {3..1}; do
        echo -ne "  â³ ${i}s remaining...\r"
        sleep 1
    done
    echo -e "${GREEN}âœ“${RESET} Initial wait complete              "
    echo ""

    # Check reception
    echo -e "${BOLD}Step 3/3:${RESET} Monitoring message reception..."
    echo ""

    RECEIVED_COUNT=0
    START_TIME=$(date +%s%3N)  # Milliseconds for accurate timing
    declare -A NODE_STATUS NODE_RECEIVE_TIME

    for i in {2..6}; do
        NODE_STATUS[$i]="â³"
        NODE_RECEIVE_TIME[$i]="0"
    done

    MAX_WAIT=5
    for SECOND in $(seq 1 $MAX_WAIT); do
        for NODE in {2..6}; do
            if [ "${NODE_STATUS[$NODE]}" = "â³" ]; then
                # Check if the node has received the message should non-empty CIDs array
                GREP_RESULT=$(docker compose logs "hermes-node$NODE" 2>&1 | grep 'RECEIVED PubSub message with CIDs: \[' | grep -v '\[\]' | wc -l)                
                if [ "$GREP_RESULT" -gt 0 ]; then
                    NODE_STATUS[$NODE]="âœ…"
                    NODE_RECEIVE_TIME[$NODE]=$(date +%s%3N)
                    RECEIVED_COUNT=$((RECEIVED_COUNT + 1))
                    LATENCY_MS=$((NODE_RECEIVE_TIME[$NODE] - START_TIME))
                    LATENCY_SEC=$(echo "scale=3; $LATENCY_MS / 1000" | bc)
                    echo -e "  ${GREEN}âœ¨ Node $NODE received message${RESET} (${LATENCY_SEC}s)"
                fi
            fi
        done

        if [ $RECEIVED_COUNT -lt 5 ]; then
            echo -ne "\r  Waiting... ${SECOND}s  [${NODE_STATUS[2]} ${NODE_STATUS[3]} ${NODE_STATUS[4]} ${NODE_STATUS[5]} ${NODE_STATUS[6]}]"
            sleep 1
        else
            echo -ne "\r  ${GREEN}âœ… All nodes received!${RESET}                                    \n"
            break
        fi
    done
    echo ""

    # Store results in temp file for visualization
    RESULTS_FILE="/tmp/p2p-test-results-$TIMESTAMP.txt"
    echo "TIMESTAMP=$TIMESTAMP" > "$RESULTS_FILE"
    echo "TEST_MESSAGE=\"$TEST_MESSAGE\"" >> "$RESULTS_FILE"
    # Base64 encode CID to handle binary data safely
    CID_B64=$(echo -n "$CID" | base64 -w0)
    echo "CID_B64=\"$CID_B64\"" >> "$RESULTS_FILE"
    echo "RECEIVED_COUNT=$RECEIVED_COUNT" >> "$RESULTS_FILE"
    echo "START_TIME=$START_TIME" >> "$RESULTS_FILE"
    for NODE in {2..6}; do
        echo "NODE_STATUS_$NODE=\"${NODE_STATUS[$NODE]}\"" >> "$RESULTS_FILE"
        echo "NODE_RECEIVE_TIME_$NODE=${NODE_RECEIVE_TIME[$NODE]}" >> "$RESULTS_FILE"
    done

# Internal: Show detailed visualization and statistics for PubSub test
_test-pubsub-visualize:
    #!/usr/bin/env bash
    set -euo pipefail
    GREEN='\033[32m'; RED='\033[31m'; YELLOW='\033[33m'
    BLUE='\033[34m'; BOLD='\033[1m'; RESET='\033[0m'

    # Load results from temp file
    RESULTS_FILE=$(ls -t /tmp/p2p-test-results-*.txt 2>/dev/null | head -1)
    if [ -z "$RESULTS_FILE" ]; then
        echo "âŒ No test results found"
        exit 1
    fi

    source "$RESULTS_FILE"

    # Decode base64 CID
    CID=$(echo -n "$CID_B64" | base64 -d 2>/dev/null || echo "unknown")

    declare -A NODE_STATUS NODE_RECEIVE_TIME
    for NODE in {2..6}; do
        eval "NODE_STATUS[$NODE]=\$NODE_STATUS_$NODE"
        eval "NODE_RECEIVE_TIME[$NODE]=\$NODE_RECEIVE_TIME_$NODE"
    done

    END_TIME=$(date +%s)
    TOTAL_TIME=$((END_TIME - START_TIME))
    MSG_SIZE=$(echo -n "$TEST_MESSAGE" | wc -c)
    CID_SIZE=${#CID}

    # Timeline
    echo ""
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo -e "${BOLD}1. PROPAGATION TIMELINE â±ï¸${RESET}"
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo ""
    echo -e "  ${BLUE}0.000s${RESET} â†’ ${BOLD}Node 1 publishes message${RESET}"
    for NODE in {2..6}; do
        if [ "${NODE_STATUS[$NODE]}" = "âœ…" ]; then
            RECV_TIME_MS=$((NODE_RECEIVE_TIME[$NODE] - START_TIME))
            RECV_TIME_SEC=$(echo "scale=3; $RECV_TIME_MS / 1000" | bc)
            echo -e "  ${GREEN}${RECV_TIME_SEC}s${RESET} â†’ Node $NODE received (${GREEN}+${RECV_TIME_SEC}s${RESET})"
        else
            echo -e "  ${RED}---${RESET} â†’ Node $NODE ${RED}did not receive${RESET}"
        fi
    done

    # Statistics
    echo ""
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo -e "${BOLD}2. NETWORK STATISTICS ğŸ“Š${RESET}"
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo ""
    echo -e "  ${BOLD}Message Metrics:${RESET}"
    echo -e "    â€¢ Message Size: ${BLUE}${MSG_SIZE} bytes${RESET}"
    echo -e "    â€¢ CID Size: ${BLUE}${CID_SIZE} bytes${RESET}"
    echo -e "    â€¢ Total Payload: ${BLUE}$((MSG_SIZE + CID_SIZE)) bytes${RESET}"
    echo ""
    echo -e "  ${BOLD}Network Metrics:${RESET}"
    echo -e "    â€¢ Total Nodes: ${BLUE}6${RESET}"
    echo -e "    â€¢ Total Connections: ${BLUE}30${RESET} (full mesh)"
    echo -e "    â€¢ Subscriber Nodes: ${BLUE}5${RESET}"
    echo -e "    â€¢ Success Rate: ${GREEN}$((RECEIVED_COUNT * 100 / 5))%${RESET} (${RECEIVED_COUNT}/5)"
    echo -e "    â€¢ Protocol: ${BLUE}Gossipsub v1.2 (libp2p)${RESET}"

    # Log Preview
    echo ""
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo -e "${BOLD}3. LIVE LOG PREVIEW ğŸ“œ${RESET}"
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo ""
    for NODE in {2..3}; do
        if [ "${NODE_STATUS[$NODE]}" = "âœ…" ]; then
            echo -e "  ${BLUE}[Node $NODE]${RESET}"
            docker compose logs hermes-node$NODE 2>&1 | grep -E "(RECEIVED PubSub|gossipsub|doc-sync)" | grep "$TIMESTAMP" | tail -1 | sed 's/^/    /' || echo "    (no detailed logs)"
            echo ""
        fi
    done

    # Peer Connections
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo -e "${BOLD}4. PEER CONNECTIONS ğŸ”—${RESET}"
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo ""
    PEER_CONN=$(docker compose logs 2>&1 | grep -c "New peer connected" || echo "0")
    echo -e "  ${BOLD}Active P2P Connections:${RESET}"
    echo -e "    â€¢ Total peer connections logged: ${BLUE}${PEER_CONN}${RESET}"
    echo -e "    â€¢ Expected connections: ${BLUE}30${RESET} (each node connects to 5 others)"
    echo ""
    echo -e "  ${BOLD}Connection Matrix (Full Mesh):${RESET}"
    for NODE in {1..6}; do
        echo -n "    Node $NODE âŸ· "
        OTHERS=()
        for OTHER in {1..6}; do
            [ $NODE -ne $OTHER ] && OTHERS+=("Node $OTHER")
        done
        # Use printf to join with ", " separator
        printf "%s, " "${OTHERS[@]:0:${#OTHERS[@]}-1}"
        echo "${OTHERS[-1]}"
    done
    echo ""
    echo -e "  ${BLUE}â„¹ï¸  Each node maintains 5 peer connections (5 peers Ã— 6 nodes = 30 total)${RESET}"

    # Final Status
    echo ""
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo -e "${BOLD}FINAL STATUS ğŸ“‹${RESET}"
    echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo ""
    echo -e "  ${BOLD}ğŸ“¨ Message:${RESET} ${BLUE}\"$TEST_MESSAGE\"${RESET}"
    echo -e "  ${BOLD}ğŸ”‘ CID:${RESET} ${BLUE}$CID${RESET}"
    echo -e "  ${BOLD}ğŸ“¡ Topic:${RESET} ${BLUE}doc-sync${RESET}"
    echo ""
    echo -e "  ${BOLD}Reception Status:${RESET}"
    for NODE in {2..6}; do
        if [ "${NODE_STATUS[$NODE]}" = "âœ…" ]; then
            RECV_TIME_MS=$((NODE_RECEIVE_TIME[$NODE] - START_TIME))
            RECV_TIME_SEC=$(echo "scale=3; $RECV_TIME_MS / 1000" | bc)
            echo -e "    ${GREEN}âœ… Node $NODE: RECEIVED${RESET} (${RECV_TIME_SEC}s)"
        else
            echo -e "    ${RED}âŒ Node $NODE: Did NOT receive${RESET}"
        fi
    done

    echo ""
    echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
    echo ""

    # Evaluate results
    if [ "$RECEIVED_COUNT" -eq 5 ]; then
        echo -e "${BOLD}${GREEN}âœ… SUCCESS - Perfect Propagation!${RESET}"
        echo ""
        echo -e "  â€¢ ${GREEN}All 5 nodes${RESET} received the message"
        echo -e "  â€¢ Mesh status: ${GREEN}Healthy${RESET}"
        echo ""
        rm -f "$RESULTS_FILE"
        exit 0
    elif [ "$RECEIVED_COUNT" -ge 4 ]; then
        echo -e "${BOLD}${GREEN}âœ… SUCCESS - Good Propagation${RESET}"
        echo ""
        echo -e "  â€¢ ${GREEN}$RECEIVED_COUNT/5 nodes${RESET} received the message"
        echo -e "  â€¢ Mesh status: ${GREEN}Operational${RESET}"
        echo ""
        rm -f "$RESULTS_FILE"
        exit 0
    elif [ "$RECEIVED_COUNT" -gt 0 ]; then
        echo -e "${BOLD}${YELLOW}âš ï¸  PARTIAL - Incomplete Propagation${RESET}"
        echo ""
        echo -e "  â€¢ Only ${YELLOW}$RECEIVED_COUNT/5 nodes${RESET} received the message"
        echo -e "  â€¢ Mesh status: ${YELLOW}Degraded${RESET}"
        echo ""
        echo "Troubleshooting:"
        echo -e "  ${BLUE}â†’ Check health: just test-pubsub-propagation${RESET}"
        echo -e "  ${BLUE}â†’ View logs: just logs | grep -i pubsub${RESET}"
        rm -f "$RESULTS_FILE"
        exit 1
    else
        echo -e "${BOLD}${RED}âŒ FAILED - No Propagation${RESET}"
        echo ""
        echo -e "  â€¢ ${RED}No nodes${RESET} received the message"
        echo -e "  â€¢ Mesh status: ${RED}Broken${RESET}"
        echo ""
        echo "Troubleshooting:"
        echo -e "  ${BLUE}â†’ Full diagnostics: just troubleshoot${RESET}"
        echo -e "  ${BLUE}â†’ Check logs: just logs | grep -E '(RECEIVED|gossipsub|bootstrap)'${RESET}"
        rm -f "$RESULTS_FILE"
        exit 1
    fi

# Full CI test suite (status + connectivity + pubsub)
# TODO: Integrate this into GitHub Actions runners for automated PR testing
test-ci:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "ğŸ§ª Running CI test suite..."
    echo ""

    # Check node status
    echo "ğŸ“Š Node status check..."
    RUNNING=$(docker compose ps | grep -c "Up" || true)
    if [ "$RUNNING" -ne 6 ]; then
        echo "âŒ Expected 6 nodes running, found $RUNNING"
        exit 1
    fi
    echo "   âœ… All 6 nodes running"

    # Wait for initialization
    echo ""
    echo "â³ Waiting for nodes to initialize (15s)..."
    sleep 15

    # Check connectivity
    echo ""
    echo "ğŸ”— Connectivity check..."
    just check-connectivity

    # Test PubSub message propagation (end-to-end, minimal output for CI)
    echo ""
    echo "ğŸ§ª PubSub propagation test..."
    just test-pubsub

    echo ""
    echo "âœ… CI test suite passed!"

# ==============================================================================
# HELP
# ==============================================================================

# Show detailed help with examples
help:
    @echo "================================================================================"
    @echo "Hermes P2P Testing Environment"
    @echo "================================================================================"
    @echo ""
    @echo "QUICK START (First Time):"
    @echo "  just quickstart         # Does everything: build, start, test, verify!"
    @echo ""
    @echo "QUICK START (Daily):"
    @echo "  just start                     # Start 6 nodes (waits for mesh formation)"
    @echo "  just test-pubsub-propagation   # Test message propagation"
    @echo "  just logs                      # Monitor activity"
    @echo "  just stop                      # Stop nodes (preserves peer IDs)"
    @echo ""
    @echo "COMMON WORKFLOWS:"
    @echo ""
    @echo "  First-Time Setup:"
    @echo "    just quickstart       # Complete end-to-end setup and test"
    @echo ""
    @echo "  Developer Testing:"
    @echo "    just validate-prereqs        # Check prerequisites"
    @echo "    just start                   # Interactive mode, prompts to rebuild"
    @echo "    just logs-node 1             # Debug specific node"
    @echo "    just restart                 # Apply code changes"
    @echo "    just test-pubsub-propagation # Test message propagation"
    @echo "    just test-bidirectional-sync         # Test bidirectional sync"
    @echo "    just test-late-join-sync             # Test node late join with keepalive sync"
    @echo ""
    @echo "  CI/CD Pipeline:"
    @echo "    just start-ci         # CI mode: non-interactive, always rebuilds"
    @echo "    just test-ci          # Full validation suite"
    @echo "    just clean            # Cleanup (deletes peer IDs)"
    @echo ""
    @echo "  Troubleshooting:"
    @echo "    just test-pubsub-propagation # Test message propagation"
    @echo "    just troubleshoot            # Generate diagnostic report (saves to file)"
    @echo "    just check-connectivity      # Check P2P connectivity"
    @echo "    just init-bootstrap          # Reset bootstrap (auto-runs on first start)"
    @echo ""
    @echo "  From Scratch (simulates fresh git clone):"
    @echo "    just clean            # Remove everything"
    @echo "    just quickstart       # Builds automatically and starts"
    @echo "    # OR: just build-all && just quickstart  # Manual build first"
    @echo ""
    @echo "BUILD COMMANDS:"
    @echo "  build                   Build Hermes binary only (fast)"
    @echo "  build-all               Build Hermes + Athena WASM (fast, ~1-2 min)"
    @echo "  build-images            Build Docker images"
    @echo "  build-ci                Build everything (CI mode)"
    @echo ""
    @echo "VALIDATION & DIAGNOSTICS:"
    @echo "  validate-prereqs        Check all prerequisites"
    @echo "  troubleshoot            Generate full diagnostic report"
    @echo "  check-connectivity      Check P2P connectivity status"
    @echo ""
    @echo "NODE MANAGEMENT:"
    @echo "  quickstart              Complete end-to-end setup and test"
    @echo "  start                   Start nodes (interactive mode, prompts)"
    @echo "  start-ci                Start nodes (CI mode, always rebuilds, no prompts)"
    @echo "  init-bootstrap          Initialize/reset bootstrap (auto-runs on first start)"
    @echo "  stop                    Stop nodes (preserves peer IDs)"
    @echo "  clean                   Stop and remove data (DELETES PEER IDs)"
    @echo "  restart                 Stop + start"
    @echo "  reset                   Clean + start fresh (regenerates peer IDs)"
    @echo ""
    @echo "MONITORING:"
    @echo "  status                  Show node status and endpoints"
    @echo "  logs                    Follow all logs"
    @echo "  logs-node N             Follow node N logs (1-6)"
    @echo ""
    @echo "TESTING:"
    @echo "  test                    Run integration tests on all nodes"
    @echo "  test-nodeN              Test specific node (1-6)"
    @echo "  test-pubsub             Test PubSub infrastructure"
    @echo "  test-pubsub-propagation Test end-to-end message propagation"
    @echo "  test-ci                 Full CI test suite"
    @echo ""
    @echo "NODE ENDPOINTS:"
    @echo "  Node 1: http://localhost:5000 (IPFS: 4001) [172.20.0.10]"
    @echo "  Node 2: http://localhost:5002 (IPFS: 4002) [172.20.0.11]"
    @echo "  Node 3: http://localhost:5004 (IPFS: 4003) [172.20.0.12]"
    @echo "  Node 4: http://localhost:5006 (IPFS: 4004) [172.20.0.13]"
    @echo "  Node 5: http://localhost:5008 (IPFS: 4005) [172.20.0.14]"
    @echo "  Node 6: http://localhost:5010 (IPFS: 4006) [172.20.0.15]"
    @echo ""
    @echo "IMPORTANT NOTES:"
    @echo "  â€¢ After 'just clean', peer IDs are regenerated on next start"
    @echo "  â€¢ Mesh formation happens automatically after startup"
    @echo "  â€¢ 'start' = interactive (prompts), 'start-ci' = CI mode (always rebuilds)"
    @echo "  â€¢ Use 'just stop' (not clean) to preserve peer IDs between restarts"
    @echo ""
    @echo "WHY 6 NODES:"
    @echo "  Gossipsub default mesh_n=6 requires 6+ peers for optimal operation."
    @echo "  With fewer nodes, PubSub publish operations block waiting for mesh."
    @echo "  Alternative: fork rust-ipfs to add small mesh configuration support."
    @echo ""
    @echo ""
    @echo "DOCUMENTATION:"
    @echo "  README.md               Quick start guide"
    @echo "  TROUBLESHOOTING.md      Comprehensive debugging guide"
    @echo "  justfile                Full command documentation (cat justfile)"
    @echo ""
    @echo "For more info: cat justfile or just --list"
    @echo "================================================================================"

# Test: Test basic pub/sub propagation and bidirectional sync
#
# Prerequisites:
#  - All nodes are started
# 
# 1. If nodes not started, start them
# 2. Cleaning all node data (database + SMT)
# 3. Verify that all nodes subscribed to .new topic
# 4. Post a document to Node1 via HTTP Post
# 5. Extract the CID from the response
# 6. Check if other nodes received the message
# 7. Check database for all nodes where CID is equal to CID extracted from response
#
# Test basic pub/sub propagation and bidirectional sync
test-bidirectional-sync:
    #!/usr/bin/env bash
    set -euo pipefail
    YELLOW='\033[33m';BLUE='\033[34m'; BOLD='\033[1m'; RESET='\033[0m'

    # ---------- Test: Basic Pub/Sub Propagation and Bidirectional Sync ----------
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo -e "${BOLD}${BLUE}Test: Basic Pub/Sub Propagation and Bidirectional Sync${RESET}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    # ---------- If nodes not started, start them ----------
    just _node_not_start_start_node
    echo ""

    # # ---------- Clean all node data ----------
    # echo -e "${YELLOW}ğŸ§¼ Cleaning node data...${RESET}"
    # for NODE in {1..6}; do
    #     just _clean-node-data $NODE
    # done
    # echo ""

    # ---------- Verify that all nodes are subscribed to the .new topic ----------
    echo -e "${YELLOW}Checking if all nodes are subscribed to the .new topic... ${RESET}"
    for NODE in {1..6}; do
        just _node-subscribe $NODE ".new"
    done
    echo "âœ… All nodes are subscribed to .new topic"
    echo ""

    CID_LIST=()
    # ---------- Post document and get the CID ----------
    echo -e "${YELLOW}Posting document to Node1...${RESET}"
    TIMESTAMP=$(date +%s)
    # TODO - replace this with real document
    DOC="Test Document sync - Timestamp: $TIMESTAMP"
    CID=$(just _post-document "$DOC" "5000")
    CID_LIST+=($CID)

    echo ""
    echo "ğŸ¥ List of CIDs: $(printf '%s\n' "${CID_LIST[@]}" | jq -R . | jq -s .)"
    echo ""

    # ---------- Check whether other nodes received the message ----------
    echo -e "${YELLOW}Checking if nodes 2-6 received message...${RESET}"
    for NODE in {2..6}; do
        echo "ğŸ Node $NODE"
        for C in ${CID_LIST[@]}; do
            just _check-document-received $NODE $C
        done
    done
    echo "âœ… All nodes (2-6) received the messages!"
    echo ""

    # ---------- Check database for all nodes ----------
    echo -e "${YELLOW}Checking database for all nodes...${RESET}"
    for NODE in {1..6}; do
        echo "ğŸŠ Node $NODE"
        for C in ${CID_LIST[@]}; do
            just _check-database-document $NODE $C
        done
    done
    echo "âœ… All nodes contains documents"

    echo ""
    echo -e "${BOLD}${BLUE}Test completed! ğŸ‰${RESET}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Test: Late joining node with keepalive sync
#
# Prerequisites:
#  - All nodes are started
#
# 1. If nodes not started, start them
# 2. Cleaning all node data (database + SMT)
# 3. Stop a node (node 6)
# 4. Post a document to Node1 via HTTP Post
# 5. Extract the CID from the response
# 6. Check if other nodes received the message
# 7. Check database for all nodes where CID is equal to CID extracted from response
# 8. Start node 6
# 9. Check database for node6 where CID is equal to CID extracted from response
#
# Test late joining node with keepalive sync
test-late-join-sync:
    #!/usr/bin/env bash
    set -euo pipefail
    GREEN='\033[32m'; RED='\033[31m'; YELLOW='\033[33m'
    BLUE='\033[34m'; BOLD='\033[1m'; RESET='\033[0m'

    # ---------- Test: Late joining node with keepalive sync ----------
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo -e "${BOLD}${BLUE}Test: Late Joining Node with Keepalive Sync${RESET}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    # ---------- If nodes not started, start them ----------
    just _node_not_start_start_node
    echo ""

    # ---------- Clean all node data ----------
    echo -e "${YELLOW}ğŸ§¼ Cleaning node data...${RESET}"
    for NODE in {1..6}; do
        just _clean-node-data $NODE
    done
    echo ""

    # ---------- Stop a node (node 6) ----------
    echo -e "${YELLOW}Stopping node 6...${RESET}"
    docker compose stop hermes-node6
    echo "âœ… Successfully stopped node 6"
    echo ""

    CID_LIST=()
    # ---------- Post documents and get the CID ----------
    echo -e "${YELLOW}Posting document to Node1...${RESET}"
    TIMESTAMP=$(date +%s)
    # TODO - replace this with real document
    DOC="Test Document 1 - Timestamp: $TIMESTAMP"
    CID=$(just _post-document "$DOC" "5000")
    CID_LIST+=($CID)
    echo ""

    echo -e "${YELLOW}Posting document to Node1...${RESET}"
    TIMESTAMP=$(date +%s)
    # TODO - replace this with real document
    DOC="Test Document 1.1 - Timestamp: $TIMESTAMP"
    CID=$(just _post-document "$DOC" "5000")
    CID_LIST+=($CID)
    echo ""

    echo -e "${YELLOW}Posting document to Node1...${RESET}"
    TIMESTAMP=$(date +%s)
    # TODO - replace this with real document
    DOC="Test Document 2 - Timestamp: $TIMESTAMP"
    CID=$(just _post-document "$DOC" "5000")
    CID_LIST+=($CID)
    echo ""

    echo -e "${YELLOW}Posting document to Node1...${RESET}"
    TIMESTAMP=$(date +%s)
    # TODO - replace this with real document
    DOC="Test Document 3 - Timestamp: $TIMESTAMP"
    CID=$(just _post-document "$DOC" "5000")
    CID_LIST+=($CID)
    echo ""

    echo ""
    echo "ğŸ¥ List of CIDs: $(printf '%s\n' "${CID_LIST[@]}" | jq -R . | jq -s .)"
    echo ""

    # ---------- Check whether other nodes received the message (omit node 6) ----------
    echo -e "${YELLOW}Checking if nodes 2-5 received message...${RESET}"
    for NODE in {2..5}; do
        echo "ğŸ Node $NODE"
        for C in ${CID_LIST[@]}; do
            just _check-document-received $NODE $C
        done
    done
    echo "âœ… All nodes (2-5) received the message!"
    echo ""

    # ---------- Check database for all nodes (omit node 6) ----------
    echo -e "${YELLOW}Checking database for all nodes...${RESET}"
    for NODE in {1..5}; do
        echo "ğŸŠ Node $NODE"
        for C in ${CID_LIST[@]}; do
            just _check-database-document $NODE $C
        done
    done
    echo "âœ… All nodes contains documents"
    echo ""

    # ---------- Start node 6 ----------
    echo -e "${YELLOW}Starting node 6...${RESET}"
    docker compose start hermes-node6
    echo "âœ… Successfully started node 6"
    echo ""

    # ---------- Wait for some time to let the keepalive sync to happen ----------
    # Keepalive timer is in range of 20-60 seconds
    echo -e "${YELLOW}Waiting for keepalive sync to happen...${RESET}"
    sleep 70
    echo "âŒ›ï¸ Timeout done"
    echo ""

    # ---------- Check node 6 sync ----------
    # Node 6 should have received the document that other node have
    echo -e "${YELLOW}Checking database, to see if node 6 sync with other nodes...${RESET}"
    for C in ${CID_LIST[@]}; do
        just _check-database-document 6 $C
    done
    echo "âœ… Node 6 has document with CID ${CID_LIST[@]}"

    echo ""
    echo -e "${BOLD}${BLUE}Test completed! ğŸ‰${RESET}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# -------------------- Helper function -------------------------

# Clean node data
# - Delete all data from the document table
# TODO - Clean the SMT
_clean-node-data nodeN:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Removing data from table document..."
    docker exec hermes-node{{nodeN}} sqlite3 /data/hermes_datastore.db.athena "DELETE FROM document;" || {
        echo "âŒ Failed to remove data from table document"
        exit 1
    }
    echo "ğŸ§¹Node {{nodeN}} data cleaned!"

_node-subscribe nodeN topic:
    #!/usr/bin/env bash
    set -euo pipefail
    GREP_RESULT=$(docker compose logs "hermes-node{{nodeN}}" 2>&1 | grep "Subscribed to {{topic}} with base" | wc -l)
    if [ "$GREP_RESULT" -lt 1 ]; then
        echo "âŒ Node {{nodeN}} did NOT subscribe to topic {{topic}}"
        exit 1
    fi
    echo "Node {{nodeN}} subscribed to topic {{topic}}"

_post-document doc port:
    #!/usr/bin/env bash
    set -euo pipefail
    DOCUMENT="{{doc}}"
    RESPONSE=$(curl -s -X POST "http://localhost:{{port}}/api/doc-sync/post" \
        -H "Host: athena.hermes.local" \
        -H "Content-Type: text/plain" \
        -d "$DOCUMENT" 2>&1)
    CID=$(echo "$RESPONSE" | jq -r '.cid' 2>/dev/null || echo "unknown")
    SUCCESS=$(echo "$RESPONSE" | jq -r '.success' 2>/dev/null || echo "false")
    if [ "$SUCCESS" != "true" ]; then
        echo "âŒ Failed to post document" >&2
        exit 1
    fi
    echo "âœ… Document posted successfully" >&2
    echo "Response: $(echo "$RESPONSE" | jq -r '.')" >&2
    echo "$CID"

_check-document-received nodeN cid:
    #!/usr/bin/env bash
    set -euo pipefail
    GREEN='\033[32m'; RESET='\033[0m'; RED='\033[31m';
    GREP_RESULT=$(docker compose logs "hermes-node{{nodeN}}" 2>&1 | \
        grep "RECEIVED PubSub message with CIDs: \[" | \
        grep -v '\[\]' | \
        grep "{{cid}}" | \
        wc -l)
    if [ "$GREP_RESULT" -ge 1 ]; then
        echo -e "Received document with CID ${GREEN}{{cid}}${RESET}"
    else
        echo -e "âŒ did NOT receive document with CID ${RED}{{cid}}${RESET}"
    fi


_check-database-document nodeN cid:
    #!/usr/bin/env bash
    set -euo pipefail
    GREEN='\033[32m'; RESET='\033[0m'; RED='\033[31m';
    RESULT=$(docker exec hermes-node{{nodeN}} sqlite3 /data/hermes_datastore.db.athena "SELECT * FROM document WHERE cid LIKE '{{cid}}';")
    # There should be some data in the db
    COUNT=$(docker exec hermes-node{{nodeN}} sqlite3 /data/hermes_datastore.db.athena "SELECT COUNT(*) FROM document;")
    echo -e "Database has ${GREEN}${COUNT}${RESET} document(s)"

    # Use this to capture the logs

    # set +e
    # LOG1=$(docker compose logs "hermes-node{{nodeN}}" 2>&1 | grep "RECEIVED PubSub message on channel")
    # echo "-----------------"
    # echo "${LOG1}"
    # echo "-----------------"
    # LOG2=$(docker compose logs "hermes-node{{nodeN}}" 2>&1 | grep "compute_cid")
    # echo "-----------------"
    # echo "${LOG2}"
    # echo "-----------------"

    # set ie

    if [ -n "$RESULT" ]; then
        echo -e "Has document with CID  ${GREEN}{{cid}}${RESET}"
    else
        echo -e "âŒ has no document with CID ${RED}{{cid}}${RESET}"
    fi
    echo ""


_node_not_start_start_node:
    #!/usr/bin/env bash
    set -euo pipefail
    for NODE in {1..6}; do
        if ! docker compose ps | grep -q "hermes-node$NODE"; then
            echo "ğŸŒˆ Node $NODE is not running, starting it..."
            docker compose start hermes-node$NODE
        fi
    done