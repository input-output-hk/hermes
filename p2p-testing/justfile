# ==============================================================================
# Hermes P2P Testing Environment
# ==============================================================================
#
# 6-node Docker setup for testing P2P features:
# - Persistent IPFS keypairs via PR#694 (peer IDs stable across stop/restart)
# - Dynamic bootstrap discovery (syncs docker-compose.yml after volume clean)
# - Bootstrap retry logic (automatic reconnection on failures)
# - Gossipsub v1.2 PubSub with on-topic event handler
# - Full mesh connectivity on isolated network (172.20.0.0/16)
#
# WHY 6 NODES?
#   Gossipsub default mesh_n=6 requires at least 6 peers for optimal operation.
#   With fewer nodes, PubSub publish operations block waiting for mesh to form.
#   Alternative would be forking rust-ipfs to add small mesh configuration support.
#
# QUICK START (first time):
#   just build-all && just build-images  # Build everything
#   just init-bootstrap                  # Discover peer IDs (REQUIRED after clean)
#   just test-pubsub                     # Verify PubSub works
#
# DAILY WORKFLOW:
#   just start          # Start nodes (preserves peer IDs)
#   just test-pubsub    # Test PubSub propagation
#   just logs           # Monitor activity
#   just stop           # Stop nodes (keeps data)
#
# AFTER CLEANING VOLUMES:
#   just clean          # Deletes volumes + peer identities
#   just init-bootstrap # REQUIRED: Rediscovers peer IDs before start
#
# CI/CD:
#   just start-ci && just test-ci && just clean
#
# NODE ENDPOINTS:
#   Node 1: http://localhost:5000 (IPFS: 4001, API: 5001) [172.20.0.10]
#   Node 2: http://localhost:5002 (IPFS: 4002, API: 5003) [172.20.0.11]
#   Node 3: http://localhost:5004 (IPFS: 4003, API: 5005) [172.20.0.12]
#   Node 4: http://localhost:5006 (IPFS: 4004, API: 5007) [172.20.0.13]
#   Node 5: http://localhost:5008 (IPFS: 4005, API: 5009) [172.20.0.14]
#   Node 6: http://localhost:5010 (IPFS: 4006, API: 5011) [172.20.0.15]
#
# PERSISTENT PEER IDS (nodes 1-3, 4-6 generated on first run):
#   Node 1: 12D3KooWBxass2EcccdN5FzC2e6er3uyuYJkTchMX11iKWaJ9aj1
#   Node 2: 12D3KooWBkdsbenzeixaTmEXdmpf5P2pXtyvm4Qb4sGZJ1Wi4BUB
#   Node 3: 12D3KooWA5tEBmYCXQfmAdt5zZonBouBt2KBN6umaUtdQVY39GPK
#
# PREREQUISITES:
#   - Docker & Docker Compose
#   - Just (https://just.systems)
#   - Earthly (https://earthly.dev) - for builds
#
# ==============================================================================

# Show available commands (default)
default:
    @just --list

# ==============================================================================
# BUILD COMMANDS
# ==============================================================================

# Build Hermes binary only (fast local build, ~3-5 min)
build:
    #!/usr/bin/env bash
    set -euo pipefail
    cd ..
    echo "üî® Building Hermes..."
    just get-local-hermes-fast

# Build Hermes + Athena WASM modules (fast local build, ~1-2 min)
build-all:
    #!/usr/bin/env bash
    set -euo pipefail
    cd ..
    echo "üöÄ Building Hermes and Athena..."
    just get-local-hermes-fast
    just get-local-athena-fast

    echo "üì¶ Packaging modules..."
    cd hermes/apps/athena
    for module_path in modules/*/lib/manifest_module.json; do
        if [ -f "$module_path" ]; then
            echo "  üì¶ Packaging $(dirname $(dirname $module_path))..."
            ../../../target/release/hermes module package "$module_path" &
        fi
    done
    wait

    echo "üì¶ Packaging application..."
    ../../../target/release/hermes app package manifest_app.json
    echo "‚úÖ Build complete!"

# Build Docker images from built artifacts
build-images:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "üê≥ Building Docker images..."
    docker compose build

# Build everything (CI mode: no prompts, always clean build)
build-ci: build-all build-images

# ==============================================================================
# NODE MANAGEMENT
# ==============================================================================

# Start 3-node test environment (interactive: prompts to rebuild if artifacts exist)
start:
    #!/usr/bin/env bash
    set -euo pipefail

    # Check if artifacts exist
    if [ -f "../hermes/target/release/hermes" ] && [ -f "../hermes/apps/athena/athena.happ" ]; then
        echo "üì¶ Found existing build artifacts"
        read -p "   Rebuild? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            just build-all
        fi
    else
        echo "üèóÔ∏è  No artifacts found, building..."
        just build-all
    fi

    just build-images
    echo ""
    echo "üåê Starting nodes..."
    docker compose up -d

    echo ""
    echo "‚è≥ Waiting for nodes to initialize..."
    sleep 5

    echo ""
    just status

# Start nodes (CI mode: no prompts, always rebuilds from clean state)
start-ci:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "üöÄ Starting P2P test environment (CI mode)..."

    # Ensure clean state
    if docker compose ps | grep -q "Up"; then
        echo "üßπ Cleaning existing environment..."
        docker compose down -v
    fi

    just build-ci
    just init-bootstrap
    echo ""
    just status

# Stop nodes (preserves data in Docker volumes)
stop:
    @echo "üõë Stopping nodes..."
    @docker compose down
    @echo "‚úÖ Nodes stopped (data preserved in volumes)"
    @echo "üí° To remove data: just clean"

# Stop nodes and remove all data (volumes deleted)
# WARNING: After clean, you must run 'just init-bootstrap' to rediscover peer IDs
clean:
    @echo "üßπ Stopping nodes and cleaning data..."
    @docker compose down -v
    @echo "‚úÖ All nodes stopped and data cleaned"
    @echo ""
    @echo "‚ö†Ô∏è  IMPORTANT: Peer identities were deleted!"
    @echo "   Run 'just init-bootstrap' before 'just start' to rediscover peer IDs"

# ==============================================================================
# BOOTSTRAP PEER DISCOVERY
# ==============================================================================
#
# BACKGROUND: Hermes persists IPFS keypairs in Docker volumes (PR#694)
#   - Keypair location: /home/hermes/.hermes/ipfs/keypair (inside volume)
#   - Peer IDs remain stable across stop/restart (volumes preserved)
#   - This works great for normal operations!
#
# THE PROBLEM: docker-compose.yml has HARDCODED bootstrap peer IDs
#   - Each node's IPFS_BOOTSTRAP_PEERS env var contains specific peer IDs
#   - Example: /ip4/172.20.0.11/tcp/4001/p2p/12D3KooW... (hardcoded)
#   - When 'just clean' deletes volumes, new keypairs = new peer IDs
#   - Hardcoded IDs in docker-compose.yml become stale ‚Üí mesh formation fails
#   - Errors: "wrong peer id", "Unexpected peer ID", no PubSub propagation
#
# THE SOLUTION: init-bootstrap command (dynamic discovery)
#   Phase 1: Start bootstrap nodes (1-3) to generate/load keypairs
#   Phase 2: Extract actual peer IDs from logs
#   Phase 3: Update docker-compose.yml with discovered IDs (creates backup)
#   Phase 4: Restart all nodes with correct bootstrap configuration
#
# WHEN NEEDED:
#   ‚úÖ After 'just clean' (volumes deleted ‚Üí new keypairs ‚Üí new peer IDs)
#   ‚úÖ First time setup (no volumes exist yet)
#   ‚ùå NOT after 'just stop/restart' (volumes preserved ‚Üí peer IDs unchanged)
#
# FUTURE IMPROVEMENT: Pre-generated test keypairs (optional convenience)
#   - Generate 6 test keypairs offline: p2p-testing/identities/node{1-6}.keypair
#   - Add to Dockerfile: COPY identities/*.keypair /home/hermes/.hermes/ipfs/
#   - Benefit: Deterministic peer IDs documented in docker-compose.yml comments
#   - Result: No init-bootstrap needed even after 'just clean'
#   - Trade-off: Adds repo size, but eliminates manual step for test environment
#
# ==============================================================================

# Initialize or reinitialize bootstrap configuration after volume changes
# Run this after 'just clean' or when peer IDs change
init-bootstrap:
    #!/usr/bin/env bash
    set -euo pipefail

    echo "üîç Bootstrap Peer Discovery"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo ""
    echo "Syncing docker-compose.yml bootstrap config with actual peer IDs"
    echo "(Needed after 'just clean' or first setup)"
    echo ""

    # Check if nodes are running
    if docker compose ps | grep -q "Up"; then
        echo "‚ö†Ô∏è  Nodes are running. Stopping them first..."
        docker compose down
        sleep 2
    fi

    # Start bootstrap nodes (1-3) without full mesh bootstrap config
    echo "üì° Phase 1: Starting bootstrap nodes (1-3) without inter-node bootstrap..."
    echo "   (They will generate or load their peer identities)"

    # Temporarily disable bootstrap for initial startup
    IPFS_BOOTSTRAP_PEERS="" docker compose up -d hermes-node1 hermes-node2 hermes-node3

    echo "‚è≥ Waiting 15 seconds for nodes to initialize and generate peer IDs..."
    sleep 15

    # Extract peer IDs from running nodes
    echo ""
    echo "üîé Phase 2: Discovering peer IDs from running nodes..."

    PEER_ID_1=$(docker compose logs hermes-node1 2>&1 | grep -E '(Generated new keypair|Loaded keypair) with Peer ID:' | grep -oP '12D3[^ "]+' | head -1)
    PEER_ID_2=$(docker compose logs hermes-node2 2>&1 | grep -E '(Generated new keypair|Loaded keypair) with Peer ID:' | grep -oP '12D3[^ "]+' | head -1)
    PEER_ID_3=$(docker compose logs hermes-node3 2>&1 | grep -E '(Generated new keypair|Loaded keypair) with Peer ID:' | grep -oP '12D3[^ "]+' | head -1)

    if [ -z "$PEER_ID_1" ] || [ -z "$PEER_ID_2" ] || [ -z "$PEER_ID_3" ]; then
        echo "‚ùå Failed to discover peer IDs from logs"
        echo "   Node 1: ${PEER_ID_1:-NOT FOUND}"
        echo "   Node 2: ${PEER_ID_2:-NOT FOUND}"
        echo "   Node 3: ${PEER_ID_3:-NOT FOUND}"
        echo ""
        echo "üí° Check logs: docker compose logs"
        exit 1
    fi

    echo "   ‚úÖ Node 1 (172.20.0.10): $PEER_ID_1"
    echo "   ‚úÖ Node 2 (172.20.0.11): $PEER_ID_2"
    echo "   ‚úÖ Node 3 (172.20.0.12): $PEER_ID_3"

    # Update docker-compose.yml with discovered peer IDs
    echo ""
    echo "üìù Phase 3: Updating docker-compose.yml with discovered peer IDs..."

    # Create backup
    cp docker-compose.yml docker-compose.yml.backup

    # Update bootstrap peers using sed (portable across Linux/Mac)
    # Node 1: bootstrap from nodes 2,3
    sed -i.tmp "s|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.11/tcp/4001/p2p/[^,]*,/ip4/172.20.0.12/tcp/4001/p2p/[^\"]*|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.11/tcp/4001/p2p/$PEER_ID_2,/ip4/172.20.0.12/tcp/4001/p2p/$PEER_ID_3|g" docker-compose.yml

    # Node 2: bootstrap from nodes 1,3
    sed -i.tmp "s|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.10/tcp/4001/p2p/[^,]*,/ip4/172.20.0.12/tcp/4001/p2p/[^\"]*|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.10/tcp/4001/p2p/$PEER_ID_1,/ip4/172.20.0.12/tcp/4001/p2p/$PEER_ID_3|g" docker-compose.yml

    # Nodes 3-6: bootstrap from nodes 1,2,3
    sed -i.tmp "s|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.10/tcp/4001/p2p/[^,]*,/ip4/172.20.0.11/tcp/4001/p2p/[^,]*,/ip4/172.20.0.12/tcp/4001/p2p/[^\"]*|IPFS_BOOTSTRAP_PEERS=/ip4/172.20.0.10/tcp/4001/p2p/$PEER_ID_1,/ip4/172.20.0.11/tcp/4001/p2p/$PEER_ID_2,/ip4/172.20.0.12/tcp/4001/p2p/$PEER_ID_3|g" docker-compose.yml

    rm -f docker-compose.yml.tmp

    echo "   ‚úÖ docker-compose.yml updated (backup saved as docker-compose.yml.backup)"

    # Restart all nodes with new bootstrap config
    echo ""
    echo "üîÑ Phase 4: Restarting all nodes with correct bootstrap configuration..."
    docker compose down
    sleep 2
    docker compose up -d

    echo "‚è≥ Waiting for mesh to form..."
    sleep 15

    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "‚úÖ Bootstrap configuration synced!"
    echo ""
    echo "üìã Current Peer IDs (now in docker-compose.yml):"
    echo "   Node 1: $PEER_ID_1"
    echo "   Node 2: $PEER_ID_2"
    echo "   Node 3: $PEER_ID_3"
    echo ""
    echo "üí° Keypairs persist in Docker volumes (PR#694)"
    echo "   - Normal stop/restart: No action needed, peer IDs stay the same"
    echo "   - After 'just clean': Must run 'just init-bootstrap' again"
    echo ""
    echo "üîÆ Future: Pre-generate test keypairs to skip this step entirely"
    echo "   See FUTURE IMPROVEMENT in justfile comments"
    echo ""

    just status

# Restart nodes (stop + start, preserves data)
restart: stop start

# Full reset (clean + start fresh with new volumes)
reset: clean start

# ==============================================================================
# MONITORING
# ==============================================================================

# Show node status and endpoints
status:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "üìä Node Status:"
    docker compose ps
    echo ""
    echo "üì° Endpoints:"
    echo "   Node 1: http://localhost:5000 (IPFS: 4001, API: 5001) [172.20.0.10]"
    echo "   Node 2: http://localhost:5002 (IPFS: 4002, API: 5003) [172.20.0.11]"
    echo "   Node 3: http://localhost:5004 (IPFS: 4003, API: 5005) [172.20.0.12]"
    echo "   Node 4: http://localhost:5006 (IPFS: 4004, API: 5007) [172.20.0.13]"
    echo "   Node 5: http://localhost:5008 (IPFS: 4005, API: 5009) [172.20.0.14]"
    echo "   Node 6: http://localhost:5010 (IPFS: 4006, API: 5011) [172.20.0.15]"

# Follow logs from all nodes
logs:
    @docker compose logs -f

# Follow logs from specific node (1, 2, or 3)
logs-node node:
    @docker compose logs -f hermes-node{{node}}

# Check P2P connectivity (bootstrap, gossipsub, listening addresses)
check-connectivity:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "üîç Checking P2P connectivity..."
    echo ""

    echo "üìã Bootstrap status:"
    docker compose logs 2>&1 | grep "All bootstrap peers connected" | tail -3 || echo "   ‚ö†Ô∏è  No successful bootstrap connections logged yet"

    echo ""
    echo "üîó Gossipsub peer connections:"
    docker compose logs 2>&1 | grep "New peer connected" | tail -10 || echo "   ‚ö†Ô∏è  No peer connections found"

    echo ""
    echo "üëÇ Listening addresses:"
    docker compose logs 2>&1 | grep "listening on 0.0.0.0:4001" | head -3 || echo "   ‚ö†Ô∏è  Nodes may not be listening on port 4001"

# ==============================================================================
# TESTING
# ==============================================================================

# Run integration tests on all nodes (requires Athena WASM modules)
test: test-node1 test-node2 test-node3 test-node4 test-node5 test-node6
    @echo ""
    @echo "‚úÖ All nodes tested!"

# Run integration tests on node 1
test-node1:
    @echo "üß™ Testing Node 1..."
    @docker exec hermes-node1 /usr/local/bin/hermes test || echo "   ‚ö†Ô∏è  Tests not available (Athena not loaded)"

# Run integration tests on node 2
test-node2:
    @echo "üß™ Testing Node 2..."
    @docker exec hermes-node2 /usr/local/bin/hermes test || echo "   ‚ö†Ô∏è  Tests not available (Athena not loaded)"

# Run integration tests on node 3
test-node3:
    @echo "üß™ Testing Node 3..."
    @docker exec hermes-node3 /usr/local/bin/hermes test || echo "   ‚ö†Ô∏è  Tests not available (Athena not loaded)"

# Run integration tests on node 4
test-node4:
    @echo "üß™ Testing Node 4..."
    @docker exec hermes-node4 /usr/local/bin/hermes test || echo "   ‚ö†Ô∏è  Tests not available (Athena not loaded)"

# Run integration tests on node 5
test-node5:
    @echo "üß™ Testing Node 5..."
    @docker exec hermes-node5 /usr/local/bin/hermes test || echo "   ‚ö†Ô∏è  Tests not available (Athena not loaded)"

# Run integration tests on node 6
test-node6:
    @echo "üß™ Testing Node 6..."
    @docker exec hermes-node6 /usr/local/bin/hermes test || echo "   ‚ö†Ô∏è  Tests not available (Athena not loaded)"

# Test PubSub infrastructure (connectivity and Gossipsub)
test-pubsub:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "üß™ Testing PubSub infrastructure..."
    echo ""

    # Check if nodes are running
    if ! docker compose ps | grep -q "hermes-node1.*Up"; then
        echo "‚ùå Nodes not running. Start with: just start"
        exit 1
    fi

    echo "1Ô∏è‚É£  Checking Gossipsub protocol is active..."
    GOSSIPSUB_LINES=$(docker compose logs 2>&1 | grep -i "gossipsub" | wc -l)
    if [ "$GOSSIPSUB_LINES" -gt 0 ]; then
        echo "   ‚úÖ Gossipsub protocol active ($GOSSIPSUB_LINES log entries)"
    else
        echo "   ‚ùå Gossipsub not detected"
        exit 1
    fi

    echo ""
    echo "2Ô∏è‚É£  Checking peer connections..."
    CONNECTIONS=$(docker compose logs 2>&1 | grep "New peer connected" | wc -l)
    if [ "$CONNECTIONS" -ge 30 ]; then
        echo "   ‚úÖ Full mesh connected ($CONNECTIONS peer connections)"
    else
        echo "   ‚ö†Ô∏è  Only $CONNECTIONS peer connections (expected 30 for 6-node full mesh)"
    fi

    echo ""
    echo "3Ô∏è‚É£  Checking bootstrap status..."
    BOOTSTRAP_SUCCESS=$(docker compose logs 2>&1 | grep "All bootstrap peers connected" | wc -l || true)
    if [ "$BOOTSTRAP_SUCCESS" -ge 4 ]; then
        echo "   ‚úÖ Bootstrap complete on $BOOTSTRAP_SUCCESS nodes"
    elif [ "$CONNECTIONS" -ge 20 ]; then
        echo "   ‚ö†Ô∏è  Bootstrap retry still running, but nodes are connected"
    else
        echo "   ‚ö†Ô∏è  Bootstrap incomplete ($BOOTSTRAP_SUCCESS nodes)"
    fi

    echo ""
    echo "‚úÖ PubSub infrastructure verified (Gossipsub active, peers connected)"

# Test PubSub message propagation (posts from Node 1, verifies others receive)
test-pubsub-propagation:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "üß™ Testing PubSub Message Propagation"
    echo "======================================"
    echo ""

    # Check if nodes are running
    if ! docker compose ps | grep -q "hermes-node1.*Up"; then
        echo "‚ùå Nodes not running. Start with: just start"
        exit 1
    fi

    # Clear recent logs (keep last 10 lines to avoid losing important startup info)
    echo "üìã Preparing test environment..."
    sleep 1

    # Post a unique test message from Node 1
    TIMESTAMP=$(date +%s)
    TEST_MESSAGE="PubSub Test - Timestamp: $TIMESTAMP"

    echo "üì§ Posting message from Node 1..."
    echo "   Message: \"$TEST_MESSAGE\""
    echo ""

    RESPONSE=$(curl -s -X POST http://localhost:5000/api/doc-sync/post \
      -H "Host: athena.hermes.local" \
      -H "Content-Type: text/plain" \
      -d "$TEST_MESSAGE")

    CID=$(echo "$RESPONSE" | jq -r '.cid' 2>/dev/null || echo "unknown")
    SUCCESS=$(echo "$RESPONSE" | jq -r '.success' 2>/dev/null || echo "false")

    if [ "$SUCCESS" != "true" ]; then
        echo "‚ùå Failed to post message!"
        echo "   Response: $RESPONSE"
        exit 1
    fi

    echo "‚úÖ Message posted successfully"
    echo "   CID: $CID"
    echo ""

    # Wait for PubSub propagation
    echo "‚è≥ Waiting 3 seconds for PubSub propagation..."
    sleep 3

    # Check which nodes received the message
    echo ""
    echo "üì® Checking which nodes received the message..."
    echo ""

    RECEIVED_COUNT=0

    for NODE in {2..6}; do
        NODE_NAME="hermes-node$NODE"

        # Check if this node's logs contain the received message marker with our timestamp
        if docker compose logs "$NODE_NAME" 2>&1 | grep "RECEIVED PubSub message" | grep -q "$TIMESTAMP"; then
            echo "   ‚úÖ Node $NODE: RECEIVED"
            RECEIVED_COUNT=$((RECEIVED_COUNT + 1))
        else
            echo "   ‚ùå Node $NODE: Did NOT receive"
        fi
    done

    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo ""

    # Evaluate results
    if [ "$RECEIVED_COUNT" -ge 4 ]; then
        echo "‚úÖ SUCCESS: Message propagated to $RECEIVED_COUNT nodes!"
        echo "   PubSub is working correctly."
        exit 0
    elif [ "$RECEIVED_COUNT" -gt 0 ]; then
        echo "‚ö†Ô∏è  PARTIAL: Message received by $RECEIVED_COUNT nodes"
        echo "   Expected: 4-5 nodes (excluding sender)"
        exit 1
    else
        echo "‚ùå FAILED: No nodes received the message"
        echo "   PubSub propagation not working"
        echo ""
        echo "üí° Debug: Check logs with 'just logs | grep RECEIVED'"
        exit 1
    fi

# Full CI test suite (status + connectivity + pubsub)
test-ci:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "üß™ Running CI test suite..."
    echo ""

    # Check node status
    echo "üìä Node status check..."
    RUNNING=$(docker compose ps | grep -c "Up" || true)
    if [ "$RUNNING" -ne 6 ]; then
        echo "‚ùå Expected 6 nodes running, found $RUNNING"
        exit 1
    fi
    echo "   ‚úÖ All 6 nodes running"

    # Wait for initialization
    echo ""
    echo "‚è≥ Waiting for nodes to initialize (15s)..."
    sleep 15

    # Check connectivity
    echo ""
    echo "üîó Connectivity check..."
    just check-connectivity

    # Test PubSub infrastructure
    echo ""
    just test-pubsub

    # Test PubSub message propagation (end-to-end)
    echo ""
    just test-pubsub-propagation

    echo ""
    echo "‚úÖ CI test suite passed!"

# ==============================================================================
# HELP
# ==============================================================================

# Show detailed help with examples
help:
    @echo "================================================================================"
    @echo "Hermes P2P Testing Environment"
    @echo "================================================================================"
    @echo ""
    @echo "QUICK START:"
    @echo "  just start              # Start 3 nodes"
    @echo "  just test-pubsub        # Verify PubSub works"
    @echo "  just logs               # Monitor activity"
    @echo "  just stop               # Stop nodes"
    @echo ""
    @echo "COMMON WORKFLOWS:"
    @echo ""
    @echo "  Developer Testing:"
    @echo "    just start            # Interactive, prompts to rebuild"
    @echo "    just test-pubsub      # Quick infrastructure check"
    @echo "    just logs-node 1      # Debug specific node"
    @echo "    just restart          # Apply code changes"
    @echo ""
    @echo "  CI/CD Pipeline:"
    @echo "    just start-ci         # Non-interactive, always rebuilds"
    @echo "    just test-ci          # Full validation suite"
    @echo "    just clean            # Cleanup"
    @echo ""
    @echo "  From Scratch (simulates fresh git clone):"
    @echo "    just clean            # Remove everything"
    @echo "    just build-all        # Build from scratch"
    @echo "    just start-ci         # Start and verify"
    @echo ""
    @echo "BUILD COMMANDS:"
    @echo "  build                   Build Hermes binary only (fast)"
    @echo "  build-all               Build Hermes + Athena WASM (fast, ~1-2 min)"
    @echo "  build-images            Build Docker images"
    @echo "  build-ci                Build everything (CI mode)"
    @echo ""
    @echo "NODE MANAGEMENT:"
    @echo "  start                   Start nodes (interactive)"
    @echo "  start-ci                Start nodes (CI mode)"
    @echo "  stop                    Stop nodes (preserve data)"
    @echo "  clean                   Stop and remove data"
    @echo "  restart                 Stop + start"
    @echo "  reset                   Clean + start fresh"
    @echo ""
    @echo "MONITORING:"
    @echo "  status                  Show node status"
    @echo "  logs                    Follow all logs"
    @echo "  logs-node N             Follow node N logs (1-6)"
    @echo "  check-connectivity      Check P2P status"
    @echo ""
    @echo "TESTING:"
    @echo "  test                    Run integration tests"
    @echo "  test-nodeN              Test specific node (1-6)"
    @echo "  test-pubsub             Test PubSub infrastructure"
    @echo "  test-ci                 Full CI test suite"
    @echo ""
    @echo "NODE ENDPOINTS:"
    @echo "  Node 1: http://localhost:5000 (IPFS: 4001) [172.20.0.10]"
    @echo "  Node 2: http://localhost:5002 (IPFS: 4002) [172.20.0.11]"
    @echo "  Node 3: http://localhost:5004 (IPFS: 4003) [172.20.0.12]"
    @echo "  Node 4: http://localhost:5006 (IPFS: 4004) [172.20.0.13]"
    @echo "  Node 5: http://localhost:5008 (IPFS: 4005) [172.20.0.14]"
    @echo "  Node 6: http://localhost:5010 (IPFS: 4006) [172.20.0.15]"
    @echo ""
    @echo "WHY 6 NODES:"
    @echo "  Gossipsub default mesh_n=6 requires 6+ peers for optimal operation."
    @echo "  With fewer nodes, PubSub publish operations block waiting for mesh."
    @echo "  Alternative: fork rust-ipfs to add small mesh configuration support."
    @echo ""
    @echo "FEATURES:"
    @echo "  ‚Ä¢ Persistent peer IDs (keypairs stored in volumes)"
    @echo "  ‚Ä¢ Bootstrap retry logic (10s interval, 10 max attempts)"
    @echo "  ‚Ä¢ Gossipsub v1.2 PubSub protocol"
    @echo "  ‚Ä¢ Full mesh connectivity (each node connected to others)"
    @echo "  ‚Ä¢ Isolated Docker network (172.20.0.0/16)"
    @echo ""
    @echo "For more info: cat justfile"
    @echo "================================================================================"
